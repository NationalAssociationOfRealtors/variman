<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HIBERNATE - Relational Persistence for Idiomatic Java</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>HIBERNATE - Relational Persistence for Idiomatic Java</h1></div><div><h2 class="subtitle">Hibernate Reference Documentation</h2></div><div><p class="releaseinfo">2.1.6</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#quickstart">1. Quickstart with Tomcat</a></span></dt><dd><dl><dt><span class="sect1"><a href="#quickstart-intro">1.1. Getting started with Hibernate</a></span></dt><dt><span class="sect1"><a href="#quickstart-persistentclass">1.2. First persistent class</a></span></dt><dt><span class="sect1"><a href="#quickstart-mapping">1.3. Mapping the cat</a></span></dt><dt><span class="sect1"><a href="#quickstart-playingwithcats">1.4. Playing with cats</a></span></dt><dt><span class="sect1"><a href="#quickstart-summary">1.5. Finally</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Overview</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.2. JMX Integration</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.3. JCA Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. SessionFactory Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Programmatic Configuration</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obtaining a SessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-userjdbc">3.3. User provided JDBC connection</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.4. Hibernate provided JDBC connection</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.5. Optional configuration properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.5.1. SQL Dialects</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.5.2. Outer Join Fetching</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.5.3. Binary Streams</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.5.4. Custom CacheProvider</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.5.5. Transaction strategy configuration</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.5.6. JNDI-bound SessionFactory</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.5.7. Query Language Substitution</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.6. Logging</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.7. Implementing a NamingStrategy</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.8. XML Configuration File</a></span></dt></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. Persistent Classes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. A simple POJO example</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.1. Declare accessors and mutators for persistent fields</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.2. Implement a default constructor</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.3. Provide an identifier property (optional)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.4. Prefer non-final classes (optional)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Implementing inheritance</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Implementing equals() and hashCode()</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-lifecycle">4.4. Lifecycle Callbacks</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-validatable">4.5. Validatable callback</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-xdoclet">4.6. Using XDOclet markup</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. Basic O/R Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. Mapping declaration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dd><dl><dt><span class="sect3"><a href="#mapping-declaration-id-generator">5.1.4.1. generator</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-hilo">5.1.4.2. Hi/Lo Algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-uuid">5.1.4.3. UUID Algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-sequences">5.1.4.4. Identity columns and Sequences</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-assigned">5.1.4.5. Assigned Identifiers</a></span></dt></dl></dd><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.5. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.6. discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.7. version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.8. timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.9. property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.10. many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.11. one-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.12. component, dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.13. subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.14. joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-collections">5.1.15. map, set, list, bag</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.16. import</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entities and values</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Basic value types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-enum">5.2.3. Persistent enum types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.4. Custom value types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.2.5. Any type mappings</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.3. SQL quoted identifiers</a></span></dt><dt><span class="sect1"><a href="#mapping-modularfiles">5.4. Modular mapping files</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Collection Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Persistent Collections</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Mapping a Collection</a></span></dt><dt><span class="sect1"><a href="#collections-ofvalues">6.3. Collections of Values and Many-To-Many Associations</a></span></dt><dt><span class="sect1"><a href="#collections-onetomany">6.4. One-To-Many Associations</a></span></dt><dt><span class="sect1"><a href="#collections-lazy">6.5. Lazy Initialization</a></span></dt><dt><span class="sect1"><a href="#collections-sorted">6.6. Sorted Collections</a></span></dt><dt><span class="sect1"><a href="#collections-idbag">6.7. Using an &lt;idbag&gt;</a></span></dt><dt><span class="sect1"><a href="#collections-bidirectional">6.8. Bidirectional Associations</a></span></dt><dt><span class="sect1"><a href="#collections-ternary">6.9. Ternary Associations</a></span></dt><dt><span class="sect1"><a href="#collections-heterogeneous">6.10. Heterogeneous Associations</a></span></dt><dt><span class="sect1"><a href="#collections-example">6.11. Collection examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">7. Component Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">7.1. Dependent objects</a></span></dt><dt><span class="sect1"><a href="#components-incollections">7.2. Collections of dependent objects</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">7.3. Components as Map indices</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">7.4. Components as composite identifiers</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">7.5. Dynamic components</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">8. Inheritance Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">8.1. The Three Strategies</a></span></dt><dt><span class="sect1"><a href="#inheritance-limitations">8.2. Limitations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#manipulatingdata">9. Manipulating Persistent Data</a></span></dt><dd><dl><dt><span class="sect1"><a href="#manipulatingdata-creating">9.1. Creating a persistent object</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-loading">9.2. Loading an object</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-querying">9.3. Querying</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-scalarqueries">9.3.1. Scalar queries</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-queryinterface">9.3.2. The Query interface</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-scrolling">9.3.3. Scrollable iteration</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-filtering">9.3.4. Filtering collections</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-criteria">9.3.5. Criteria queries</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-nativesql">9.3.6. Queries in native SQL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-updating">9.4. Updating objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-updating-insession">9.4.1. Updating in the same Session</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-updating-detached">9.4.2. Updating detached objects</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-update-lock">9.4.3. Reattaching detached objects</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-deleting">9.5. Deleting persistent objects</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-flushing">9.6. Flush</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-endingsession">9.7. Ending a Session</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-endingsession-flushing">9.7.1. Flushing the Session</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-commit">9.7.2. Committing the database transaction</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-close">9.7.3. Closing the Session</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-exceptions">9.7.4. Exception handling</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-graphs">9.8. Lifecyles and object graphs</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-interceptors">9.9. Interceptors</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-metadata">9.10. Metadata API</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transactions">10. Transactions And Concurrency</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">10.1. Configurations, Sessions and Factories</a></span></dt><dt><span class="sect1"><a href="#transactions-threads">10.2. Threads and connections</a></span></dt><dt><span class="sect1"><a href="#transactions-identity">10.3. Considering object identity</a></span></dt><dt><span class="sect1"><a href="#transactions-optimistic">10.4. Optimistic concurrency control</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-longsession">10.4.1. Long session with automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">10.4.2. Many sessions with automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-manual">10.4.3. Application version checking</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-disconnection">10.5. Session disconnection</a></span></dt><dt><span class="sect1"><a href="#transactions-locking">10.6. Pessimistic Locking</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">11. HQL: The Hibernate Query Language</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">11.1. Case Sensitivity</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">11.2. The from clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">11.3. Associations and joins</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">11.4. The select clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">11.5. Aggregate functions</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">11.6. Polymorphic queries</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">11.7. The where clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">11.8. Expressions</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">11.9. The order by clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">11.10. The group by clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">11.11. Subqueries</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">11.12. HQL examples</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">11.13. Tips &amp; Tricks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">12. Criteria Queries</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">12.1. Creating a Criteria instance</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">12.2. Narrowing the result set</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">12.3. Ordering the results</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">12.4. Associations</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">12.5. Dynamic association fetching</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">12.6. Example queries</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">13. Native SQL Queries</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">13.1. Creating a SQL based Query</a></span></dt><dt><span class="sect1"><a href="#querysql-aliasreferences">13.2. Alias and property references</a></span></dt><dt><span class="sect1"><a href="#querysql-namedqueries">13.3. Named SQL queries</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">14. Improving performance</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-collections">14.1. Understanding Collection performance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">14.1.1. Taxonomy</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">14.1.2. Lists, maps and sets are the most efficient collections to update</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">14.1.3. Bags and lists are the most efficient inverse collections</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">14.1.4. One shot delete</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-proxies">14.2. Proxies for Lazy Initialization</a></span></dt><dt><span class="sect1"><a href="#performance-cache">14.3. The Second Level Cache</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">14.3.1. Cache mappings</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">14.3.2. Strategy: read only</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">14.3.3. Strategy: read/write</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">14.3.4. Strategy: nonstrict read/write</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">14.3.5. Strategy: transactional</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">14.4. Managing the Session Cache</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">14.5. The Query Cache</a></span></dt></dl></dd><dt><span class="chapter"><a href="#toolsetguide">15. Toolset Guide</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">15.1. Schema Generation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">15.1.1. Customizing the schema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">15.1.2. Running the tool</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">15.1.3. Properties</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">15.1.4. Using Ant</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">15.1.5. Incremental schema updates</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">15.1.6. Using Ant for incremental schema updates</a></span></dt></dl></dd><dt><span class="sect1"><a href="#toolsetguide-s2">15.2. Code Generation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s2-1">15.2.1. The config file (optional)</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s2-2">15.2.2. The meta attribute</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s2-3">15.2.3. Basic finder generator</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s2-4">15.2.4. Velocity based renderer/generator</a></span></dt></dl></dd><dt><span class="sect1"><a href="#toolsetguide-s3">15.3. Mapping File Generation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s3-1">15.3.1. Running the tool</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">16. Example: Parent/Child</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">16.1. A note about collections</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">16.2. Bidirectional one-to-many</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">16.3. Cascading lifecycle</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">16.4. Using cascading update()</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">16.5. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">17. Example: Weblog Application</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">17.1. Persistent Classes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">17.2. Hibernate Mappings</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">17.3. Hibernate Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">18. Example: Various Mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">18.1. Employer/Employee</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">18.2. Author/Work</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">18.3. Customer/Order/Product</a></span></dt></dl></dd><dt><span class="chapter"><a href="#best-practices">19. Best Practices</a></span></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>
            Working with object-oriented software and a relational database can be cumbersome
            and time consuming in today's enterprise environments. Hibernate is an object/relational
            mapping tool for Java environments. The term object/relational mapping (ORM) refers to
            the technique of mapping a data representation from an object model to a relational
            data model with a SQL-based schema.
        </p><p>
            Hibernate not only takes care of the mapping from Java classes to
            database tables (and from Java data types to SQL data types), but also provides data
            query and retrieval facilities and can significantly reduce development time otherwise
            spent with manual data handling in SQL and JDBC.
        </p><p>
            Hibernates goal is to relieve the developer from 95 percent of common data persistence
            related programming tasks. Hibernate may not be the best solution for data-centric
            applications that only use stored-procedures to implement the business logic in the
            database, it is most useful with object-oriented domain models and business logic in
            the Java-based middle-tier. However, Hibernate can certainly help you to remove or
            encapsulate vendor-specific SQL code and will help with the common task of result set
            translation from a tabular representation to a graph of objects.
        </p><p>
            If you are new to Hibernate and Object/Relational Mapping or even Java,
            please follow these steps:
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Read <a href="#quickstart" title="Chapter&nbsp;1.&nbsp;Quickstart with Tomcat">Chapter&nbsp;1, <i>Quickstart with Tomcat</i></a> for a 30 minute tutorial, using Tomcat.
                </p></li><li><p>
                    Read <a href="#architecture" title="Chapter&nbsp;2.&nbsp;Architecture">Chapter&nbsp;2, <i>Architecture</i></a> to understand the environments where
                    Hibernate can be used.
                </p></li><li><p>
                    Have a look at the <tt class="literal">eg/</tt> directory in the Hibernate
                    distribution, it contains a simple standalone application. Copy your
                    JDBC driver to the <tt class="literal">lib/</tt> directory and edit
                    <tt class="literal">etc/hibernate.properties</tt>, specifying correct values for
                    your database. From a command prompt in the distribution directory,
                    type <tt class="literal">ant eg</tt> (using Ant), or under Windows, type
                    <tt class="literal">build eg</tt>.
                </p></li><li><p>
                    Use this reference documentation as your primary source of information.
                    Consider reading <span class="emphasis"><em>Hibernate in Action</em></span>
                    (http://www.manning.com/bauer) if you need more help with application
                    design or if you prefer a step-by-step tutorial. Also visit
                    http://caveatemptor.hibernate.org and download the example application
                    for Hibernate in Action.
                </p></li><li><p>
					FAQs are answered on the Hibernate website.
				</p></li><li><p>
					Third party demos, examples and tutorials are linked on the Hibernate
					website.
				</p></li><li><p>
                    The Community Area on the Hibernate website is a good source for
                    design patterns and various integration solutions (Tomcat, JBoss, Spring,
                    Struts, EJB, etc.).
                </p></li><li><p>
                    An offline version of the Hibernate website is distributed with
                    Hibernate in the <tt class="literal">doc/wiki/</tt> subdirectory.
                </p></li></ol></div><p>
             If you have questions, use the user forum linked on the Hibernate website. We also
             provide a JIRA issue trackings system for bug reports and feature requests. If you
             are interested in the development of Hibernate, join the developer mailing list. If
             you are interested in translating this documentation into your language, contact us
             on the developer mailing list.
         </p><p>
             Commercial development support, production support and training for Hibernate is
             available through JBoss Inc. (see http://www.hibernate.org/SupportTraining/).
             Hibernate is a project of the JBoss Professional Open Source product suite.
         </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="quickstart"></a>Chapter&nbsp;1.&nbsp;Quickstart with Tomcat</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-intro"></a>1.1.&nbsp;Getting started with Hibernate</h2></div></div><div></div></div><p>
            This tutorial explains a setup of Hibernate 2.1 with the Apache Tomcat
            servlet container for a web-based application. Hibernate works
            well in a managed environment with all major J2EE application servers, or
            even in standalone Java applications. The database system used in this
            tutorial is PostgreSQL 7.3, support for other database is only a matter
            of changing the Hibernate SQL dialect configuration.
        </p><p>
            First, we have to copy all required libraries to the Tomcat installation.
            We use a separate web context (<tt class="literal">webapps/quickstart</tt>) for
            this tutorial, so we've to consider both the global library search path
            (<tt class="literal">TOMCAT/common/lib</tt>) and the classloader at the context level in
            <tt class="literal">webapps/quickstart/WEB-INF/lib</tt> (for JAR files) and
            <tt class="literal">webapps/quickstart/WEB-INF/classes</tt>. We refer to both classloader
            levels as the global classpath and the context classpath.
        </p><p>
            Now, copy the libraries to the two classpaths:
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Copy the JDBC driver for the database to the global classpath. This is
                    required for the DBCP connection pool software which comes bundled with Tomcat.
                    Hibernate uses JDBC connections to execute SQL on the database, so you
                    either have to provide pooled JDBC connections or configure Hibernate to
                    use one of the directly supported pools (C3P0, Proxool). For this tutorial,
                    copy the <tt class="literal">pg73jdbc3.jar</tt> library (for PostgreSQL 7.3 and JDK 1.4)
                    to the global classloaders path. If you'd like to use a different database, simply
                    copy its appropriate JDBC driver.
                </p></li><li><p>
					Never copy anything else into the global classloader path in Tomcat, or you
					will get  problems with various tools, including Log4j, commons-logging and
					others. Always use the context classpath for each web application, that is,
					copy libraries to <tt class="literal">WEB-INF/lib</tt> and your own classes and
                    configuration/property files to <tt class="literal">WEB-INF/classes</tt>. Both
                    directories are in the context level classpath by default.
				</p></li><li><p>
                    Hibernate is packaged as a JAR library. The <tt class="literal">hibernate2.jar</tt>
                    file should be copied in the context classpath together with other classes of
                    the application. Hibernate requires some 3rd party libraries at runtime, these
                    come bundled with the Hibernate distribution in the <tt class="literal">lib/</tt>
                    directory; see <a href="#3rdpartylibs" title="Table&nbsp;1.1.&nbsp;&#xA;                Hibernate 3rd party libraries&#xA;            ">Table&nbsp;1.1, &#8220;
                Hibernate 3rd party libraries
            &#8221;</a>. Copy the required 3rd party
                    libraries to the context classpath.
                </p></li></ol></div><div class="table"><a name="3rdpartylibs"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;
                Hibernate 3rd party libraries
            </b></p><table summary="&#xA;                Hibernate 3rd party libraries&#xA;            " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">
                            Library
                        </th><th align="center">
                            Description
                        </th></tr></thead><tbody><tr><td>
                            dom4j (required)
                        </td><td>
                            Hibernate uses dom4j to parse XML configuration and XML mapping
                            metadata files.
                        </td></tr><tr><td>
                            CGLIB (required)
                        </td><td>
                            Hibernate uses the code generation library to enhance classes
                            at runtime (in combination with Java reflection).
                        </td></tr><tr><td>
                            Commons Collections, Commons Logging (required)
                        </td><td>
                            Hibernate uses various utility libraries from the Apache Jakarta
                            Commons project.
                        </td></tr><tr><td>
                            ODMG4 (required)
                        </td><td>
                            Hibernate provides an optional ODMG compliant persistence manager
                            interface. It is required if you like to map collections, even
                            if you don't intend to use the ODMG API. We don't map collections
                            in this tutorial, but it's a good idea to copy the JAR anyway.
                        </td></tr><tr><td>
                            EHCache (required)
                        </td><td>
                            Hibernate can use various cache providers for the second-level
                            cache. EHCache is the default cache provider if not changed in
                            the configuration.
                        </td></tr><tr><td>
                            Log4j (optional)
                        </td><td>
                            Hibernate uses the Commons Logging API, which in turn can use
                            Log4j as the underlying logging mechanism. If the Log4j library is
                            available in the context library directory, Commons Logging will use
                            Log4j and the <tt class="literal">log4j.properties</tt> configuration in the
                            context classpath. An example properties file for Log4j is bundled
                            with the Hibernate distribution. So, copy log4j.jar and the configuration
                            file (from <tt class="literal">src/</tt>) to your context classpath if
                            you want to see whats going on behind the scenes.
                        </td></tr><tr><td>
                            Required or not?
                        </td><td>
                            Have a look at the file <tt class="literal">lib/README.txt</tt> in the
                            Hibernate distribution. This is an up-to-date list of 3rd party
                            libraries distributed with Hibernate. You will find all required
                            and optional libraries listed there.
                        </td></tr></tbody></table></div><p>
            We now set up the database connection pooling and sharing in both Tomcat and
            Hibernate. This means Tomcat will provide pooled JDBC connections (using its
            builtin DBCP pooling feature), Hibernate requests theses connections through
            JNDI. Tomcat binds the connection pool to JNDI, we add a resource declaration
            to Tomcats main configuration file, <tt class="literal">TOMCAT/conf/server.xml</tt>:
        </p><pre class="programlisting">&lt;Context path="/quickstart" docBase="quickstart"&gt;
    &lt;Resource name="jdbc/quickstart" scope="Shareable" type="javax.sql.DataSource"/&gt;
    &lt;ResourceParams name="jdbc/quickstart"&gt;
        &lt;parameter&gt;
            &lt;name&gt;factory&lt;/name&gt;
            &lt;value&gt;org.apache.commons.dbcp.BasicDataSourceFactory&lt;/value&gt;
        &lt;/parameter&gt;

        &lt;!-- DBCP database connection settings --&gt;
        &lt;parameter&gt;
            &lt;name&gt;url&lt;/name&gt;
            &lt;value&gt;jdbc:postgresql://localhost/quickstart&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;driverClassName&lt;/name&gt;&lt;value&gt;org.postgresql.Driver&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;username&lt;/name&gt;
            &lt;value&gt;quickstart&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;password&lt;/name&gt;
            &lt;value&gt;secret&lt;/value&gt;
        &lt;/parameter&gt;

        &lt;!-- DBCP connection pooling options --&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxWait&lt;/name&gt;
            &lt;value&gt;3000&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxIdle&lt;/name&gt;
            &lt;value&gt;100&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxActive&lt;/name&gt;
            &lt;value&gt;10&lt;/value&gt;
        &lt;/parameter&gt;
    &lt;/ResourceParams&gt;
&lt;/Context&gt;</pre><p>
			The context we configure in this example is named <tt class="literal">quickstart</tt>,
			its base is the <tt class="literal">TOMCAT/webapp/quickstart</tt> directory. To access
			any servlets, call the path <tt class="literal">http://localhost:8080/quickstart</tt>
			in your browser (of course, adding the name of the servlet as mapped in your
			<tt class="literal">web.xml</tt>). You may also go ahead and create a simple servlet
			now that has an empty <tt class="literal">process()</tt>
		</p><p>
            Tomcat uses the DBCP connection pool with this configuration and provides pooled
            JDBC <tt class="literal">Connection</tt>s through JNDI at
            <tt class="literal">java:comp/env/jdbc/quickstart</tt>. If you have trouble getting the
            connection pool running, refer to the Tomcat documentation. If you get JDBC driver
            exception messages, try to setup JDBC connection pool without Hibernate first.
            Tomcat &amp; JDBC tutorials are available on the Web.
        </p><p>
            The next step is to configure Hibernate, using the connections from the JNDI bound pool.
            We use Hibernates XML based configuration. The basic approach, using properties, is
            equivalent in features, but doesn't offer any advantages. We use the XML configuration
            because it is usually more convenient. The XML configuration file is placed in the
            context classpath (<tt class="literal">WEB-INF/classes</tt>), as
            <tt class="literal">hibernate.cfg.xml</tt>:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration
    PUBLIC "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-2.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;property name="connection.datasource"&gt;java:comp/env/jdbc/quickstart&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="dialect"&gt;net.sf.hibernate.dialect.PostgreSQLDialect&lt;/property&gt;

        &lt;!-- Mapping files --&gt;
        &lt;mapping resource="Cat.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
            We turn logging of SQL commands off and tell Hibernate what database SQL
            dialect is used and where to get the JDBC connections (by declaring the JNDI
            address of the Tomcat bound datasource pool). The dialect is a required setting,
            databases differ in their interpretation of the SQL "standard". Hibernate will take
            care of the differences and comes bundled with dialects for all major
            commercial and open source databases.
        </p><p>
            A <tt class="literal">SessionFactory</tt> is Hibernate's concept of a single
            datastore, multiple databases can be used by creating multiple XML
            configuration files and creating multiple <tt class="literal">Configuration</tt>
            and <tt class="literal">SessionFactory</tt> objects in your application.
        </p><p>
            The last element of the <tt class="literal">hibernate.cfg.xml</tt> declares
            <tt class="literal">Cat.hbm.xml</tt> as the name of a Hibernate XML mapping
            file for the persistent class <tt class="literal">Cat</tt>. This file contains
            the metadata for the mapping of the POJO class to a datbase table (or multiple
            tables). We'll come back to that file soon. Let's write the POJO class first
            and then declare the mapping metadata for it.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-persistentclass"></a>1.2.&nbsp;First persistent class</h2></div></div><div></div></div><p>
            Hibernate works best with the Plain Old Java Objects (POJOs, sometimes
            called Plain Ordinary Java Objects) programming model for persistent classes.
            A POJO is much like a JavaBean, with properties of the class accessible via getter
            and setter methods, shielding the internal representation from the publicly
            visible interface:
        </p><pre class="programlisting">package net.sf.hibernate.examples.quickstart;

public class Cat {

    private String id;
    private String name;
    private char sex;
    private float weight;

    public Cat() {
    }

    public String getId() {
        return id;
    }

    private void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    public float getWeight() {
        return weight;
    }

    public void setWeight(float weight) {
        this.weight = weight;
    }

}</pre><p>
            Hibernate is not restricted in its usage of property types, all Java JDK
            types and primitives (like <tt class="literal">String</tt>, <tt class="literal">char</tt>
            and <tt class="literal">Date</tt>) can be mapped, including classes from the Java
            collections framework. You can map them as values, collections of values, or
            associations to other entities. The <tt class="literal">id</tt> is a special property
            that represents the database identifer (primary key) of that class, it is
            highly recommended for entities like a <tt class="literal">Cat</tt>. Hibernate can
            use identifiers only internally, but we would lose some of the flexibility in our
            application architecture.
        </p><p>
            No special interface has to be implemented for persistent classes nor do we have
            to subclass from a special root persistent class. Hibernate also doesn't use any
            build time processing, such as byte-code manipulation, it relies solely on
            Java reflection and runtime class enhancement (through CGLIB). So, without any
            dependency in the POJO class on Hibernate, we can map it to a database table.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-mapping"></a>1.3.&nbsp;Mapping the cat</h2></div></div><div></div></div><p>
            The <tt class="literal">Cat.hbm.xml</tt> mapping file contains the metadata
            required for the object/relational mapping. The metadata includes declaration
            of persistent classes and the mapping of properties (to columns and
            foreign key relationships to other entities) to database tables.
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping
    PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping&gt;

    &lt;class name="net.sf.hibernate.examples.quickstart.Cat" table="CAT"&gt;

        &lt;!-- A 32 hex character is our surrogate key. It's automatically
            generated by Hibernate with the UUID pattern. --&gt;
        &lt;id name="id" type="string" unsaved-value="null" &gt;
            &lt;column name="CAT_ID" sql-type="char(32)" not-null="true"/&gt;
            &lt;generator class="uuid.hex"/&gt;
        &lt;/id&gt;

        &lt;!-- A cat has to have a name, but it shouldn' be too long. --&gt;
        &lt;property name="name"&gt;
            &lt;column name="NAME" length="16" not-null="true"/&gt;
        &lt;/property&gt;

        &lt;property name="sex"/&gt;

        &lt;property name="weight"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Every persistent class should have an identifer attribute (actually, only
            classes representing entities, not dependent value objects, which
            are mapped as components of an entity). This property is used to distinguish
            persistent objects: Two cats are equal if
            <tt class="literal">catA.getId().equals(catB.getId())</tt> is true, this concept is
            called <span class="emphasis"><em>database identity</em></span>. Hibernate comes bundled with
            various identifer generators for different scenarios (including native generators
            for database sequences, hi/lo identifier tables, and application assigned
            identifiers). We use the UUID generator (only recommended for testing, as integer
            surrogate keys generated by the database should be prefered) and also specify the
            column <tt class="literal">CAT_ID</tt> of the table <tt class="literal">CAT</tt> for the
            Hibernate generated identifier value (as a primary key of the table).
        </p><p>
            All other properties of <tt class="literal">Cat</tt> are mapped to the same table. In
            the case of the <tt class="literal">name</tt> property, we mapped it with an explicit
            database column declaration. This is especially useful when the database
            schema is automatically generated (as SQL DDL statements) from the mapping
            declaration with Hibernate's <span class="emphasis"><em>SchemaExport</em></span> tool. All other
            properties are mapped using Hibernate's default settings, which is what you
            need most of the time. The table <tt class="literal">CAT</tt> in the database looks
            like this:
        </p><pre class="programlisting"> Column |         Type          | Modifiers
--------+-----------------------+-----------
 cat_id | character(32)         | not null
 name   | character varying(16) | not null
 sex    | character(1)          |
 weight | real                  |
Indexes: cat_pkey primary key btree (cat_id)</pre><p>
			You should now create this table in your database manually, and later read
			<a href="#toolsetguide" title="Chapter&nbsp;15.&nbsp;Toolset Guide">Chapter&nbsp;15, <i>Toolset Guide</i></a> if you want to automate this step with the
			SchemaExport tool. This tool can create a full SQL DDL, including table
			definition, custom column type constraints, unique constraints and indexes.
    	</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-playingwithcats"></a>1.4.&nbsp;Playing with cats</h2></div></div><div></div></div><p>
            We're now ready to start Hibernate's <tt class="literal">Session</tt>. It is the
            <span class="emphasis"><em>persistence manager</em></span>interface, we use it
            to store and retrieve <tt class="literal">Cat</tt>s to and from the database.
            But first, we've to get a <tt class="literal">Session</tt> (Hibernate's unit-of-work)
            from the <tt class="literal">SessionFactory</tt>:
        </p><pre class="programlisting">SessionFactory sessionFactory =
            new Configuration().configure().buildSessionFactory();</pre><p>
			A <tt class="literal">SessionFactory</tt> is responsible for one database and
			may only use one XML configuration file (<tt class="literal">hibernate.cfg.xml</tt>).
			You can set other properties (and even change the mapping metadata) by
			accessing the <tt class="literal">Configuration</tt> <span class="emphasis"><em>before</em></span>
			you build the <tt class="literal">SessionFactory</tt> (it is immutable). Where
			do we create the <tt class="literal">SessionFactory</tt> and how can we access
			it in our application?
        </p><p>
			A <tt class="literal">SessionFactory</tt> is usually only build once,
			e.g. at startup with a <span class="emphasis"><em>load-on-startup</em></span> servlet.
            This also means you should not keep it in an instance variable in your
            servlets, but in some other location. Furthermore, we need some kind of
            <span class="emphasis"><em>Singleton</em></span>, so we can access the
            <tt class="literal">SessionFactory</tt> easily in application code. The approach
            shown next solves both problems: configuration and easy access to a
            <tt class="literal">SessionFactory</tt>.
		</p><p>
		    We implement a <tt class="literal">HibernateUtil</tt> helper class:
		</p><pre class="programlisting">import net.sf.hibernate.*;
import net.sf.hibernate.cfg.*;

public class HibernateUtil {

    private static Log log = LogFactory.getLog(HibernateUtil.class);

    private static final SessionFactory sessionFactory;

    static {
        try {
            // Create the SessionFactory
            sessionFactory = new Configuration().configure().buildSessionFactory();
        } catch (Throwable ex) {
            log.error("Initial SessionFactory creation failed.", ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static final ThreadLocal session = new ThreadLocal();

    public static Session currentSession() throws HibernateException {
        Session s = (Session) session.get();
        // Open a new Session, if this Thread has none yet
        if (s == null) {
            s = sessionFactory.openSession();
            session.set(s);
        }
        return s;
    }

    public static void closeSession() throws HibernateException {
        Session s = (Session) session.get();
        session.set(null);
        if (s != null)
            s.close();
    }
}</pre><p>
			This class does not only take care of the <tt class="literal">SessionFactory</tt>
			with its static attribute, but also has a <tt class="literal">ThreadLocal</tt> to
			hold the <tt class="literal">Session</tt> for the current executing thread. Make
			sure you understand the Java concept of a thread-local variable before you
			try to use this helper.
		</p><p>
            A <tt class="literal">SessionFactory</tt> is threadsafe, many threads can access
            it concurrently and request <tt class="literal">Session</tt>s. A <tt class="literal">Session</tt>
            is a non-threadsafe object that represents a single unit-of-work with the database.
            <tt class="literal">Session</tt>s are opened by a <tt class="literal">SessionFactory</tt> and
            are closed when all work is completed:
        </p><pre class="programlisting">Session session = HibernateUtil.currentSession();

Transaction tx= session.beginTransaction();

Cat princess = new Cat();
princess.setName("Princess");
princess.setSex('F');
princess.setWeight(7.4f);

session.save(princess);
tx.commit();

HibernateUtil.closeSession();</pre><p>
            In a <tt class="literal">Session</tt>, every database operation occurs inside a
            transaction that isolates the database operations (even read-only operations).
            We use Hibernates <tt class="literal">Transaction</tt> API to abstract from the underlying
            transaction strategy (in our case, JDBC transactions). This allows our code
            to be deployed with container-managed transactions (using JTA) without any changes.
            Please note that the example above does not handle any exceptions.
        </p><p>
			Also note that you may call <tt class="literal">HibernateUtil.currentSession();</tt>
			as many times as you like, you will always get the current <tt class="literal">Session</tt>
			of this thread. You have to make sure the <tt class="literal">Session</tt> is closed
			after your unit-of-work completes, either in your servlet code or in a servlet filter
			before the HTTP response is send. The nice side effect of the latter is easy
			lazy initialization: the <tt class="literal">Session</tt> is still open when the view is
			rendered, so Hibernate can load unitialized objects while you navigate the graph.
        </p><p>
            Hibernate has various methods that can be used to retrieve objects from the
            database. The most flexible way is using the Hibernate Query Language (HQL),
            which is an easy to learn and powerful object-oriented extension to SQL:
        </p><pre class="programlisting">Transaction tx = session.beginTransaction();

Query query = session.createQuery("select c from Cat as c where c.sex = :sex");
query.setCharacter("sex", 'F');
for (Iterator it = query.iterate(); it.hasNext();) {
    Cat cat = (Cat) it.next();
    out.println("Female Cat: " + cat.getName() );
}

tx.commit();</pre><p>
            Hibernate also offers an object-oriented <span class="emphasis"><em>query by criteria</em></span> API
            that can be used to formulate type-safe queries. Hibernate of course uses
            <tt class="literal">PreparedStatement</tt>s and parameter binding for all SQL communication
            with the database. You may also use Hibernate's direct SQL query feature or
            get a plain JDBC connection from a <tt class="literal">Session</tt> in rare cases.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-summary"></a>1.5.&nbsp;Finally</h2></div></div><div></div></div><p>
            We only scratched the surface of Hibernate in this small tutorial. Please note that
            we don't include any servlet specific code in our examples. You have to create a
            servlet yourself and insert the Hibernate code as you see fit.
        </p><p>
			Keep in mind that Hibernate, as a data access layer, is tightly integrated into
			your application. Usually, all other layers depent on the persistence mechanism.
			Make sure you understand the implications of this design.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapter&nbsp;2.&nbsp;Architecture</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-overview"></a>2.1.&nbsp;Overview</h2></div></div><div></div></div><p>
            A (very) high-level view of the Hibernate architecture:
        </p><div class="mediaobject" align="center"><img src="../shared/images/overview.gif" align="middle"></div><p>
            This diagram shows Hibernate using the database and configuration data to
            provide persistence services (and persistent objects) to the application.
        </p><p>
            We would like to show a more detailed view of the runtime architecture.
            Unfortunately, Hibernate is flexible and supports several approaches. We will
            show the two extremes. The "lite" architecture has the application
            provide its own JDBC connections and manage its own transactions. This approach
            uses a minimal subset of Hibernate's APIs:
        </p><div class="mediaobject" align="center"><img src="../shared/images/lite.gif" align="middle"></div><p>
            The "full cream" architecture abstracts the application away from the
            underlying JDBC/JTA APIs and lets Hibernate take care of the details.
        </p><div class="mediaobject" align="center"><img src="../shared/images/full_cream.gif" align="middle"></div><p>
            Heres some definitions of the objects in the diagrams:

            </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<tt class="literal">net.sf.hibernate.SessionFactory</tt>)</span></dt><dd><p>
                            A threadsafe (immutable) cache of compiled mappings for a single database.
                            A factory for <tt class="literal">Session</tt> and a client of
                            <tt class="literal">ConnectionProvider</tt>. Might hold an optional (second-level)
                            cache of data that is reusable between transactions, at a
                            process- or cluster-level.
                        </p></dd><dt><span class="term">Session (<tt class="literal">net.sf.hibernate.Session</tt>)</span></dt><dd><p>
                            A single-threaded, short-lived object representing a conversation between
                            the application and the persistent store. Wraps a JDBC connection. Factory
                            for <tt class="literal">Transaction</tt>. Holds a mandatory (first-level) cache
                            of persistent objects, used when navigating the object graph or looking up
                            objects by identifier.
                        </p></dd><dt><span class="term">Persistent Objects and Collections</span></dt><dd><p>
                            Short-lived, single threaded objects containing persistent state and business
                            function. These might be ordinary JavaBeans/POJOs, the only special thing about
                            them is that they are currently associated with (exactly one)
                            <tt class="literal">Session</tt>. As soon as the <tt class="literal">Session</tt> is closed,
                            they will be detached and free to use in any application layer (e.g. directly
                            as data transfer objects to and from presentation).
                        </p></dd><dt><span class="term">Transient Objects and Collections</span></dt><dd><p>
                            Instances of persistent classes that are not currently associated with a
                            <tt class="literal">Session</tt>. They may have been instantiated by
                            the application and not (yet) persisted or they may have been instantiated by a
                            closed <tt class="literal">Session</tt>.
                        </p></dd><dt><span class="term">Transaction (<tt class="literal">net.sf.hibernate.Transaction</tt>)</span></dt><dd><p>
                            (Optional) A single-threaded, short-lived object used by the application to
                            specify atomic units of work. Abstracts application from underlying JDBC,
                            JTA or CORBA transaction. A <tt class="literal">Session</tt> might span several
                            <tt class="literal">Transaction</tt>s in some cases.
                        </p></dd><dt><span class="term">ConnectionProvider (<tt class="literal">net.sf.hibernate.connection.ConnectionProvider</tt>)</span></dt><dd><p>
                            (Optional) A factory for (and pool of) JDBC connections. Abstracts application from
                            underlying <tt class="literal">Datasource</tt> or <tt class="literal">DriverManager</tt>.
                            Not exposed to application, but can be extended/implemented by the developer.
                        </p></dd><dt><span class="term">TransactionFactory (<tt class="literal">net.sf.hibernate.TransactionFactory</tt>)</span></dt><dd><p>
                            (Optional) A factory for <tt class="literal">Transaction</tt> instances. Not exposed to the
                            application, but can be extended/implemented by the developer.
                        </p></dd></dl></div><p>
        </p><p>
            Given a "lite" architecture, the application bypasses the
            <tt class="literal">Transaction</tt>/<tt class="literal">TransactionFactory</tt> and/or
            <tt class="literal">ConnectionProvider</tt> APIs to talk to JTA or JDBC directly.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jmx"></a>2.2.&nbsp;JMX Integration</h2></div></div><div></div></div><p>
            JMX is the J2EE standard for management of Java components. Hibernate may be managed via
            a JMX standard MBean but because most application servers do not yet support JMX, Hibernate
            also affords some non-standard configuration mechanisms.
        </p><p>
            Please see the Hibernate website for more information on how to configure Hibernate to
            run as a JMX component inside JBoss.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-jca"></a>2.3.&nbsp;JCA Support</h2></div></div><div></div></div><p>
            Hibernate may also be configured as a JCA connector. Please see the website for more
            details.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="session-configuration"></a>Chapter&nbsp;3.&nbsp;SessionFactory Configuration</h2></div></div><div></div></div><p>
        Because Hibernate is designed to operate in many different environments, there
        are a large number of configuration parameters. Fortunately, most have sensible
        default values and Hibernate is distributed with an example 
        <tt class="literal">hibernate.properties</tt> file that shows the various options.
        You usually only have to put that file in your classpath and customize it.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Programmatic Configuration</h2></div></div><div></div></div><p>
            An instance of <tt class="literal">net.sf.hibernate.cfg.Configuration</tt>
            represents an entire set of mappings of an application's Java types to a
            SQL database. The <tt class="literal">Configuration</tt> is used to build a
            (immutable)` <tt class="literal">SessionFactory</tt>. The mappings are compiled
            from various XML mapping files.
        </p><p>
            You may obtain a <tt class="literal">Configuration</tt> instance by
            instantiating it directly. Heres an example of setting up a datastore from 
            mappings defined in two XML configuration files (in the classpath):
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml");</pre><p>
            An alternative (sometimes better) way is to let Hibernate load a mapping file
            using <tt class="literal">getResourceAsStream()</tt>:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>
            Then Hibernate will look for mapping files named
            <tt class="literal">/org/hibernate/autcion/Item.hbm.xml</tt> and
            <tt class="literal">/org/hibernate/autcion/Bid.hbm.xml</tt> in the classpath.
            This approach eliminates any hardcoded filenames.
        </p><p>
            A <tt class="literal">Configuration</tt> also specifies various optional properties:
        </p><pre class="programlisting">Properties props = new Properties();
...
Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperties(props);</pre><p>
            A <tt class="literal">Configuration</tt> is intended as a configuration-time object, to be
            discarded once a <tt class="literal">SessionFactory</tt> is built.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-sessionfactory"></a>3.2.&nbsp;Obtaining a SessionFactory</h2></div></div><div></div></div><p>
            When all mappings have been parsed by the <tt class="literal">Configuration</tt>, the application
            must obtain a factory for <tt class="literal">Session</tt> instances. This factory is intended
            to be shared by all application threads:
        </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>
            However, Hibernate does allow your application to instantiate more than one
            <tt class="literal">SessionFactory</tt>. This is useful if you are using more than one database.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-userjdbc"></a>3.3.&nbsp;User provided JDBC connection</h2></div></div><div></div></div><p>
            A <tt class="literal">SessionFactory</tt> may open a <tt class="literal">Session</tt> on 
            a user-provided JDBC connection. This design choice frees the application to 
            obtain JDBC connections wherever it pleases:
        </p><pre class="programlisting">java.sql.Connection conn = datasource.getConnection();
Session session = sessions.openSession(conn);

// do some data access work</pre><p>
            The application must be careful not to open two concurrent
            <tt class="literal">Session</tt>s on the same JDBC connection!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-hibernatejdbc"></a>3.4.&nbsp;Hibernate provided JDBC connection</h2></div></div><div></div></div><p>
            Alternatively, you can have the <tt class="literal">SessionFactory</tt>
            open connections for you. The <tt class="literal">SessionFactory</tt>
            must be provided with JDBC connection properties in one of the
            following ways:
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Pass an instance of <tt class="literal">java.util.Properties</tt> to
                    <tt class="literal">Configuration.setProperties()</tt>.
                </p></li><li><p>
                    Place <tt class="literal">hibernate.properties</tt> in a root directory of
                    the classpath.
                </p></li><li><p>
                    Set <tt class="literal">System</tt> properties using
                    <tt class="literal">java -Dproperty=value</tt>.
                </p></li><li><p>
                    Include <tt class="literal">&lt;property&gt;</tt> elements in
                    <tt class="literal">hibernate.cfg.xml</tt> (discussed later).
                </p></li></ol></div><p>
            If you take this approach, opening a <tt class="literal">Session</tt> is as simple as:
        </p><pre class="programlisting">Session session = sessions.openSession(); // open a new Session
// do some data access work, a JDBC connection will be used on demand</pre><p>
            All Hibernate property names and semantics are defined on the class 
            <tt class="literal">net.sf.hibernate.cfg.Environment</tt>. We will now describe the most
            important settings for JDBC connection configuration.
        </p><p>
            Hibernate will obtain (and pool) connections using <tt class="literal">java.sql.DriverManager</tt> 
            if you set the following properties:
        </p><div class="table"><a name="d0e765"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Hibernate JDBC Properties</b></p><table summary="Hibernate JDBC Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td><span class="emphasis"><em>jdbc driver class</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td><span class="emphasis"><em>jdbc URL</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>database user</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>database user password</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.pool_size</tt></td><td><span class="emphasis"><em>maximum number of pooled connections</em></span></td></tr></tbody></table></div><p>
            Hibernate's own connection pooling algorithm is quite rudimentary. It is intended
            to help you get started and is <span class="emphasis"><em>not intended for use in a production system</em></span> 
            or even for performance testing. Use a third party pool for best performance and stability,
            i.e., replace the <tt class="literal">hibernate.connection.pool_size</tt> property with
            connection pool specific settings.
        </p><p>
            C3P0 is an open source JDBC connection pool distributed along with 
            Hibernate in the <tt class="literal">lib</tt> directory. Hibernate will use the built-in 
            <tt class="literal">C3P0ConnectionProvider</tt> for connection pooling if you set 
            the <tt class="literal">hibernate.c3p0.*</tt> properties.
            There is also built-in support for Apache DBCP and for Proxool. You must set the
            properties <tt class="literal">hibernate.dbcp.*</tt> (DBCP connection pool properties) 
            to enable the <tt class="literal">DBCPConnectionProvider</tt>. Prepared statement caching is
            enabled (highly recommend) if <tt class="literal">hibernate.dbcp.ps.*</tt>
            (DBCP statement cache properties) are set. Please refer the the Apache commons-pool 
            documentation for the interpretation of these properties.  You should set the 
            <tt class="literal">hibernate.proxool.*</tt> properties if you wish to use Proxool.
        </p><p>
            This is an example using C3P0:
        </p><a name="c3p0-configuration"></a><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = net.sf.hibernate.dialect.PostgreSQLDialect</pre><p>
            For use inside an application server, Hibernate may obtain connections from a
            <tt class="literal">javax.sql.Datasource</tt> registered in JNDI. Set the following 
            properties:
        </p><div class="table"><a name="d0e853"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Hibernate Datasource Properties</b></p><table summary="Hibernate Datasource Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Propery name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.datasource</tt></td><td><span class="emphasis"><em>datasource JNDI name</em></span></td></tr><tr><td><tt class="literal">hibernate.jndi.url</tt></td><td><span class="emphasis"><em>URL of the JNDI provider</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.jndi.class</tt></td><td><span class="emphasis"><em>class of the JNDI <tt class="literal">InitialContextFactory</tt></em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>database user</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>database user password</em></span> (optional)
                </td></tr></tbody></table></div><p>
            This is an example using an application server provided JNDI datasource:
        </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/MyDB
hibernate.transaction.factory_class = \
    net.sf.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    net.sf.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = \
    net.sf.hibernate.dialect.PostgreSQLDialect</pre><p>
            JDBC connections obtained from a JNDI datasource will automatically participate
            in the container-managed transactions of the application server.
        </p><p>
            Arbitrary connection properties may be given by prepending
            "<tt class="literal">hibernate.connnection</tt>" to the property name. For example, you
            may specify a <tt class="literal">charSet</tt> using <tt class="literal">hibernate.connnection.charSet</tt>.
        </p><p>
            You may define your own plugin strategy for obtaining JDBC connections by implementing the
            interface <tt class="literal">net.sf.hibernate.connection.ConnectionProvider</tt>. You may select
            a custom implementation by setting <tt class="literal">hibernate.connection.provider_class</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-optional"></a>3.5.&nbsp;Optional configuration properties</h2></div></div><div></div></div><p>
            There are a number of other properties that control the behaviour of Hibernate
            at runtime. All are optional and have reasonable default values.
        </p><p>
            System-level properties can only be set via <tt class="literal">java -Dproperty=value</tt> or
            be defined in <tt class="literal">hibernate.properties</tt> and not with an instance of
            <tt class="literal">Properties</tt> passed to the <tt class="literal">Configuration</tt>.
        </p><div class="table"><a name="configuration-optional-properties"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Hibernate Configuration Properties</b></p><table summary="Hibernate Configuration Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.dialect</tt></td><td>
                            The classname of a Hibernate <tt class="literal">Dialect</tt> - enables
                            certain platform dependent features.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">full.classname.of.Dialect</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_schema</tt></td><td>
                            Qualify unqualified tablenames with the given schema/tablespace
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">SCHEMA_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.session_factory_name</tt></td><td>
                            The <tt class="literal">SessionFactory</tt> will be automatically
                            bound to this name in JNDI after it has been created.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/composite/name</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_outer_join</tt></td><td>
                            Enables outer join fetching. Deprecated, use <tt class="literal">max_fetch_depth</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.max_fetch_depth</tt></td><td>
                            Set a maximum "depth" for the outer join fetch tree
                            for single-ended associations (one-to-one, many-to-one).
                            A <tt class="literal">0</tt> disables default outer join fetching.
                            <p>
                                <span class="strong">eg.</span> 
                                recommended values between <tt class="literal">0</tt> and <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.fetch_size</tt></td><td>
                            A non-zero value determines the JDBC fetch size (calls
                            <tt class="literal">Statement.setFetchSize()</tt>).
                        </td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_size</tt></td><td>
                            A non-zero value enables use of JDBC2 batch updates by Hibernate.
                            <p>
                                <span class="strong">eg.</span>
                                recommended values between <tt class="literal">5</tt> and <tt class="literal">30</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_versioned_data</tt></td><td>
                            Set this property to <tt class="literal">true</tt> if your JDBC driver returns
                            correct row counts from <tt class="literal">executeBatch()</tt> (it is usually
                            safe to turn this option on). Hibernate will then use batched DML for
                            automatically versioned data. Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_scrollable_resultset</tt></td><td>
                            Enables use of JDBC2 scrollable resultsets by Hibernate.
                            This property is only necessary when using user supplied
                            JDBC connections, Hibernate uses connection metadata otherwise.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_streams_for_binary</tt></td><td>
                            Use streams when writing/reading <tt class="literal">binary</tt>
                            or <tt class="literal">serializable</tt> types to/from JDBC
                            (system-level property).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_get_generated_keys</tt></td><td>
                            Enable use of JDBC3 <tt class="literal">PreparedStatement.getGeneratedKeys()</tt>
                            to retrieve natively generated keys after insert. Requires JDBC3+ driver
                            and JRE1.4+, set to false if your driver has problems with the Hibernate
                            identifier generators. By default, tries to determine the driver capabilites
                            using connection metadata.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cglib.use_reflection_optimizer</tt></td><td>
                            Enables use of CGLIB instead of runtime reflection (System-level
                            property). Reflection can sometimes be useful when troubleshooting,
                            note that Hibernate always requires CGLIB even if you turn off the
                            optimizer. You can not set this property in <tt class="literal">hibernate.cfg.xml</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jndi.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                            Pass the property <tt class="literal">propertyName</tt> to
                            the JNDI <tt class="literal">InitialContextFactory</tt>.
                        </td></tr><tr><td><tt class="literal">hibernate.connection.isolation</tt></td><td>
                        Set the JDBC transaction isolation level. Check
                        <tt class="literal">java.sql.Connection</tt> for meaningful values but
                        note that most databases do not support all isolation levels.
                        <p>
                            <span class="strong">eg.</span> 
                            <tt class="literal">1, 2, 4, 8</tt>
                        </p></td></tr><tr><td><tt class="literal">hibernate.connection.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                        Pass the JDBC property <tt class="literal">propertyName</tt>
                        to <tt class="literal">DriverManager.getConnection()</tt>.
                    </td></tr><tr><td><tt class="literal">hibernate.connection.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">ConnectionProvider</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.ConnectionProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">CacheProvider</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.CacheProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_minimal_puts</tt></td><td>
                            Optimize second-level cache operation to minimize writes, at the
                            cost of more frequent reads (useful for clustered caches).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_query_cache</tt></td><td>
                            Enable the query cache, individual queries still have to be set cachable.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.query_cache_factory</tt></td><td>
                            The classname of a custom <tt class="literal">QueryCache</tt> interface,
                            defaults to the built-in <tt class="literal">StandardQueryCache</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.QueryCache</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.region_prefix</tt></td><td>
                            A prefix to use for second-level cache region names.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">prefix</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.factory_class</tt></td><td>
                            The classname of a <tt class="literal">TransactionFactory</tt>
                            to use with Hibernate <tt class="literal">Transaction</tt> API
                            (defaults to <tt class="literal">JDBCTransactionFactory</tt>).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">jta.UserTransaction</tt></td><td>
                            A JNDI name used by <tt class="literal">JTATransactionFactory</tt> to
                            obtain the JTA <tt class="literal">UserTransaction</tt> from the
                            application server.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/composite/name</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.manager_lookup_class</tt></td><td>
                            The classname of a <tt class="literal">TransactionManagerLookup</tt>
                            - required when JVM-level caching is enabled in a JTA environment.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionManagerLookup</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.substitutions</tt></td><td>
                            Mapping from tokens in Hibernate queries to SQL tokens
                            (tokens might be function or literal names, for example).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.show_sql</tt></td><td>
                            Write all SQL statements to console.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.hbm2ddl.auto</tt></td><td>
                            Automatically export schema DDL to the database when the
                            <tt class="literal">SessionFactory</tt> is created. With
                            <tt class="literal">create-drop</tt>, the database schema
                            will be dropped when the <tt class="literal">SessionFactory</tt>
                            is closed explicitely.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">update</tt> | <tt class="literal">create</tt> | <tt class="literal">create-drop</tt>
                            </p></td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-dialects"></a>3.5.1.&nbsp;SQL Dialects</h3></div></div><div></div></div><p>
                You should always set the <tt class="literal">hibernate.dialect</tt> property to the correct
                <tt class="literal">net.sf.hibernate.dialect.Dialect</tt> subclass for your database. This is not
                strictly essential unless you wish to use <tt class="literal">native</tt> or
                <tt class="literal">sequence</tt> primary key generation or pessimistic locking (with, eg.
                <tt class="literal">Session.lock()</tt> or <tt class="literal">Query.setLockMode()</tt>).
                However, if you specify a dialect, Hibernate will use sensible defaults for some of the
                other properties listed above, saving you the effort of specifying them manually.
            </p><div class="table"><a name="sql-dialects"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Hibernate SQL Dialects (<tt class="literal">hibernate.dialect</tt>)</b></p><table summary="Hibernate SQL Dialects (hibernate.dialect)" border="1"><colgroup><col><col></colgroup><thead><tr><th>RDBMS</th><th>Dialect</th></tr></thead><tbody><tr><td>DB2</td><td><tt class="literal">net.sf.hibernate.dialect.DB2Dialect</tt></td></tr><tr><td>DB2 AS/400</td><td><tt class="literal">net.sf.hibernate.dialect.DB2400Dialect</tt></td></tr><tr><td>DB2 OS390</td><td><tt class="literal">net.sf.hibernate.dialect.DB2390Dialect</tt></td></tr><tr><td>PostgreSQL</td><td><tt class="literal">net.sf.hibernate.dialect.PostgreSQLDialect</tt></td></tr><tr><td>MySQL</td><td><tt class="literal">net.sf.hibernate.dialect.MySQLDialect</tt></td></tr><tr><td>Oracle (any version)</td><td><tt class="literal">net.sf.hibernate.dialect.OracleDialect</tt></td></tr><tr><td>Oracle 9/10g</td><td><tt class="literal">net.sf.hibernate.dialect.Oracle9Dialect</tt></td></tr><tr><td>Sybase</td><td><tt class="literal">net.sf.hibernate.dialect.SybaseDialect</tt></td></tr><tr><td>Sybase Anywhere</td><td><tt class="literal">net.sf.hibernate.dialect.SybaseAnywhereDialect</tt></td></tr><tr><td>Microsoft SQL Server</td><td><tt class="literal">net.sf.hibernate.dialect.SQLServerDialect</tt></td></tr><tr><td>SAP DB</td><td><tt class="literal">net.sf.hibernate.dialect.SAPDBDialect</tt></td></tr><tr><td>Informix</td><td><tt class="literal">net.sf.hibernate.dialect.InformixDialect</tt></td></tr><tr><td>HypersonicSQL</td><td><tt class="literal">net.sf.hibernate.dialect.HSQLDialect</tt></td></tr><tr><td>Ingres</td><td><tt class="literal">net.sf.hibernate.dialect.IngresDialect</tt></td></tr><tr><td>Progress</td><td><tt class="literal">net.sf.hibernate.dialect.ProgressDialect</tt></td></tr><tr><td>Mckoi SQL</td><td><tt class="literal">net.sf.hibernate.dialect.MckoiDialect</tt></td></tr><tr><td>Interbase</td><td><tt class="literal">net.sf.hibernate.dialect.InterbaseDialect</tt></td></tr><tr><td>Pointbase</td><td><tt class="literal">net.sf.hibernate.dialect.PointbaseDialect</tt></td></tr><tr><td>FrontBase</td><td><tt class="literal">net.sf.hibernate.dialect.FrontbaseDialect</tt></td></tr><tr><td>Firebird</td><td><tt class="literal">net.sf.hibernate.dialect.FirebirdDialect</tt></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-outerjoin"></a>3.5.2.&nbsp;Outer Join Fetching</h3></div></div><div></div></div><p>
                If your database supports ANSI or Oracle style outer joins, <span class="emphasis"><em>outer join
                fetching</em></span> might increase performance by limiting the number of round
                trips to and from the database (at the cost of possibly more work performed by
                the database itself). Outer join fetching allows a graph of objects connected
                by many-to-one, one-to-many or one-to-one associations to be retrieved in a single
                SQL <tt class="literal">SELECT</tt>.
            </p><p>
                By default, the fetched graph when loading an objects ends at leaf objects,
                collections, objects with proxies, or where circularities occur.
            </p><p>
                For a <span class="emphasis"><em>particular  association</em></span>, fetching may be enabled
                or disabled (and the default behaviour overridden) by setting the
                <tt class="literal">outer-join</tt> attribute in the XML mapping.
            </p><p>
                Outer join fetching may be disabled <span class="emphasis"><em>globally</em></span> by setting
                the property <tt class="literal">hibernate.max_fetch_depth</tt> to <tt class="literal">0</tt>.
                A setting of <tt class="literal">1</tt> or higher enables outer join fetching for
                all one-to-one and many-to-one associations, which are, also by default, set
                to <tt class="literal">auto</tt> outer join. However, one-to-many associations and
                collections are never fetched with an outer-join, unless explicitely declared
                for each particular association. This behavior can also be overriden at runtime
                with Hibernate queries.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-binarystreams"></a>3.5.3.&nbsp;Binary Streams</h3></div></div><div></div></div><p>
                Oracle limits the size of <tt class="literal">byte</tt> arrays that may
                be passed to/from its JDBC driver. If you wish to use large instances of
                <tt class="literal">binary</tt> or <tt class="literal">serializable</tt> type, you should
                enable <tt class="literal">hibernate.jdbc.use_streams_for_binary</tt>.
                <span class="emphasis"><em>This is a JVM-level setting only.</em></span>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-cacheprovider"></a>3.5.4.&nbsp;Custom <tt class="literal">CacheProvider</tt></h3></div></div><div></div></div><p>
                You may integrate a JVM-level (or clustered) second-level cache system by
                implementing the interface <tt class="literal">net.sf.hibernate.cache.CacheProvider</tt>.
                You may select the custom implementation by setting
                <tt class="literal">hibernate.cache.provider_class</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-transactionstrategy"></a>3.5.5.&nbsp;Transaction strategy configuration</h3></div></div><div></div></div><p>
                If you wish to use the Hibernate <tt class="literal">Transaction</tt> API, you must
                specify a factory class for <tt class="literal">Transaction</tt> instances by
                setting the property <tt class="literal">hibernate.transaction.factory_class</tt>.
                The <tt class="literal">Transaction</tt> API hides the underlying transaction
                mechanism and allows Hibernate code to run in managed and non-managed environments.
            </p><p>
                There are two standard (built-in) choices:
            </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">net.sf.hibernate.transaction.JDBCTransactionFactory</tt></span></dt><dd><p>delegates to database (JDBC) transactions (default)</p></dd><dt><span class="term"><tt class="literal">net.sf.hibernate.transaction.JTATransactionFactory</tt></span></dt><dd><p>delegates to JTA (if an existing transaction is underway, the <tt class="literal">Session</tt>
                        performs its work in that context, otherwise a new transaction is started)</p></dd></dl></div><p>
                You may also define your own transaction strategies (for a CORBA transaction service,
                for example).
            </p><p>
                If you wish to use JVM-level caching of mutable data in a JTA environment, you must specify
                a strategy for obtaining the JTA <tt class="literal">TransactionManager</tt>, as this is
                not standardized for J2EE containers:
            </p><div class="table"><a name="jtamanagerlookup"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;JTA TransactionManagers</b></p><table summary="JTA TransactionManagers" border="1"><colgroup><col><col></colgroup><thead><tr><th>Transaction Factory</th><th align="center">Application Server</th></tr></thead><tbody><tr><td><tt class="literal">net.sf.hibernate.transaction.JBossTransactionManagerLookup</tt></td><td align="center">JBoss</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.WeblogicTransactionManagerLookup</tt></td><td align="center">Weblogic</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.WebSphereTransactionManagerLookup</tt></td><td align="center">WebSphere</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.OrionTransactionManagerLookup</tt></td><td align="center">Orion</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.ResinTransactionManagerLookup</tt></td><td align="center">Resin</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JOTMTransactionManagerLookup</tt></td><td align="center">JOTM</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JOnASTransactionManagerLookup</tt></td><td align="center">JOnAS</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.JRun4TransactionManagerLookup</tt></td><td align="center">JRun4</td></tr><tr><td><tt class="literal">net.sf.hibernate.transaction.BESTransactionManagerLookup</tt></td><td align="center">Borland ES</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-jndi"></a>3.5.6.&nbsp;JNDI-bound <tt class="literal">SessionFactory</tt></h3></div></div><div></div></div><p>
                A JNDI bound Hibernate <tt class="literal">SessionFactory</tt> can simplify the lookup
                of the factory and the creation of new <tt class="literal">Session</tt>s.
            </p><p>
                If you wish to have the <tt class="literal">SessionFactory</tt> bound to a JNDI namespace, specify
                a name (eg. <tt class="literal">java:comp/env/hibernate/SessionFactory</tt>) using the property
                <tt class="literal">hibernate.session_factory_name</tt>. If this property is omitted, the 
                <tt class="literal">SessionFactory</tt> will not be bound to JNDI. (This is especially useful in 
                environments with a read-only JNDI default implementation, eg. Tomcat.)
            </p><p>
                When binding the <tt class="literal">SessionFactory</tt> to JNDI, Hibernate will use the values of
                <tt class="literal">hibernate.jndi.url</tt>, <tt class="literal">hibernate.jndi.class</tt> to instantiate 
                an initial context. If they are not specified, the default <tt class="literal">InitialContext</tt>
                will be used.
            </p><p>
                If you do choose to use JNDI, an EJB or other utility class may obtain the 
                <tt class="literal">SessionFactory</tt> using a JNDI lookup.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-querysubstitution"></a>3.5.7.&nbsp;Query Language Substitution</h3></div></div><div></div></div><p>
                You may define new Hibernate query tokens using <tt class="literal">hibernate.query.substitutions</tt>.
                For example:
            </p><pre class="programlisting">hibernate.query.substitutions true=1, false=0</pre><p>
                would cause the tokens <tt class="literal">true</tt> and <tt class="literal">false</tt> to be translated to
                integer literals in the generated SQL.
            </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>
                would allow you to rename the SQL <tt class="literal">LOWER</tt> function.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-logging"></a>3.6.&nbsp;Logging</h2></div></div><div></div></div><p>
            Hibernate logs various events using Apache commons-logging.
        </p><p>
            The commons-logging service will direct output to either Apache Log4j
            (if you include <tt class="literal">log4j.jar</tt> in your classpath) or
            JDK1.4 logging (if running under JDK1.4 or above). You may download
            Log4j from <tt class="literal">http://jakarta.apache.org</tt>.
            To use Log4j you will need to place a <tt class="literal">log4j.properties</tt>
            file in your classpath, an example properties file is distributed with
            Hibernate in the <tt class="literal">src/</tt> directory.
        </p><p>
            We strongly recommend that you familiarize yourself with Hibernate's log
            messages. A lot of work has been put into making the Hibernate log as
            detailed as possible, without making it unreadable. It is an essential
            troubleshooting device. Also don't forget to enable SQL logging as
            described above (<tt class="literal">hibernate.show_sql</tt>), it is your first
            step when looking for performance problems.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namingstrategy"></a>3.7.&nbsp;Implementing a <tt class="literal">NamingStrategy</tt></h2></div></div><div></div></div><p>
            The interface <tt class="literal">net.sf.hibernate.cfg.NamingStrategy</tt> allows you
            to specify a "naming standard" for database objects and schema elements.
        </p><p>
            You may provide rules for automatically generating database identifiers from
            Java identifiers or for processing "logical" column and table names given in
            the mapping file into  "physical" table and column names. This feature helps
            reduce the verbosity of the mapping document, eliminating repetitive noise
            (<tt class="literal">TBL_</tt> prefixes, for example). The default strategy used by
            Hibernate is quite minimal.
        </p><p>
            You may specify a different strategy by calling
            <tt class="literal">Configuration.setNamingStrategy()</tt> before adding mappings:
        </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p>
            <tt class="literal">net.sf.hibernate.cfg.ImprovedNamingStrategy</tt> is a built-in
            strategy that might be a useful starting point for some applications.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xmlconfig"></a>3.8.&nbsp;XML Configuration File</h2></div></div><div></div></div><p>
            An alternative approach is to specify a full configuration in a file named
            <tt class="literal">hibernate.cfg.xml</tt>. This file can be used as a replacement
            for the <tt class="literal">hibernate.properties</tt> file or, if both are present,
            override properties.
        </p><p>
            The XML configuration file is by default expected to be in the root o
            your <tt class="literal">CLASSPATH</tt>. Here is an example:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 2.0//EN"

 "http://hibernate.sourceforge.net/hibernate-configuration-2.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:comp/env/hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"&gt;my/first/datasource&lt;/property&gt;
        &lt;property name="dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="use_outer_join"&gt;true&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            net.sf.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
           Configuring Hibernate is then as simple as
       </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>
           You can pick a different XML configuration file using
       </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="persistent-classes"></a>Chapter&nbsp;4.&nbsp;Persistent Classes</h2></div></div><div></div></div><p>
        Persistent classes are classes in an application that implement the entities
        of the business problem (e.g. Customer and Order in an E-commerce application).
        Persistent classes have, as the name implies, transient and also persistent
        instance stored in the database.
    </p><p>
        Hibernate works best if these classes follow some simple rules, also known
        as the Plain Old Java Object (POJO) programming model.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-pojo"></a>4.1.&nbsp;A simple POJO example</h2></div></div><div></div></div><p>
            Most Java applications require a persistent class representing felines.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identifier
    private String name;
    private Date birthdate;
    private Cat mate;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }

    void setMate(Cat mate) {
        this.mate = mate;
    }
    public Cat getMate() {
        return mate;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }
    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }
}</pre><p>
            There are four main rules to follow here:
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-accessors"></a>4.1.1.&nbsp;Declare accessors and mutators for persistent fields</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> declares accessor methods for all its persistent fields.
                Many other ORM tools directly persist instance variables. We believe 
                it is far better to decouple this implementation detail from the persistence 
                mechanism. Hibernate persists JavaBeans style properties, and recognizes method 
                names of the form <tt class="literal">getFoo</tt>, <tt class="literal">isFoo</tt> and
                <tt class="literal">setFoo</tt>.
            </p><p>
                Properties need <span class="emphasis"><em>not</em></span> be declared public - Hibernate can
                persist a property with a default, <tt class="literal">protected</tt> or <tt class="literal">
                private</tt> get / set pair.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-constructor"></a>4.1.2.&nbsp;Implement a default constructor</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> has an implicit default (no-argument) constructor. All 
                persistent classes must have a default constructor (which may be non-public) so 
                Hibernate can instantiate them using <tt class="literal">Constructor.newInstance()</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-identifier"></a>4.1.3.&nbsp;Provide an identifier property (optional)</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> has a property called <tt class="literal">id</tt>. This property 
                holds the primary key column of a database table. The property might have been called 
                anything, and its type might have been any primitive type, any primitive "wrapper" 
                type, <tt class="literal">java.lang.String</tt> or <tt class="literal">java.util.Date</tt>. (If 
                your legacy database table has composite keys, you can even use a user-defined class 
                with properties of these types - see the section on composite identifiers below.)
            </p><p>
                The identifier property is optional. You can leave it off and let Hibernate keep track 
                of object identifiers internally. However, for many applications it is still
                a good (and very popular) design decision.
            </p><p>
                What's more, some functionality is available only to classes which declare an
                identifier property:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        Cascaded updates (see "Lifecycle Objects")
                    </p></li><li><p>
                        <tt class="literal">Session.saveOrUpdate()</tt>
                    </p></li></ul></div><p>
                We recommend you declare consistently-named identifier properties on persistent
                classes. We further recommend that you use a nullable (ie. non-primitive) type.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-pojo-final"></a>4.1.4.&nbsp;Prefer non-final classes (optional)</h3></div></div><div></div></div><p>
                A central feature of Hibernate, <span class="emphasis"><em>proxies</em></span>, depends upon the
                persistent class being either non-final, or the implementation of an interface
                that declares all public methods.
            </p><p>
                You can persist <tt class="literal">final</tt> classes that do not implement an interface
                with Hibernate, but you won't be able to use proxies - which will limit your options
                for performance tuning somewhat.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-inheritance"></a>4.2.&nbsp;Implementing inheritance</h2></div></div><div></div></div><p>
            A subclass must also observe the first and second rules. It inherits its
            identifier property from <tt class="literal">Cat</tt>.
        </p><pre class="programlisting">package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-equalshashcode"></a>4.3.&nbsp;Implementing <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt></h2></div></div><div></div></div><p>
            You have to override the <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt>
            methods if you intend to mix objects of persistent classes (e.g. in a <tt class="literal">Set</tt>).
        </p><p>
            <span class="emphasis"><em>This only applies if these objects are loaded in two different
            <tt class="literal">Session</tt>s, as Hibernate only guarantees JVM identity (<tt class="literal"> a == b </tt>,
            the default implementation of <tt class="literal">equals()</tt>) inside a single
            <tt class="literal">Session</tt>!</em></span>
        </p><p>
            Even if both objecs <tt class="literal">a</tt> and <tt class="literal">b</tt> are the same database row
            (they have the same primary key value as their identifier), we can't guarantee that they are
            the same Java instance outside of a particular <tt class="literal">Session</tt> context.
        </p><p>
            The most obvious way is to implement <tt class="literal">equals()</tt>/<tt class="literal">hashCode()</tt>
            by comparing the identifier value of both objects. If the value is the same, both must
            be the same database row, they are therefore equal (if both are added to a <tt class="literal">Set</tt>,
            we will only have one element in the <tt class="literal">Set</tt>). Unfortunately, we can't use that
            approach. Hibernate will only assign identifier values to objects that are persistent,
            a newly created instance will not have any identifier value! We recommend implementing
            <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt> using
            <span class="emphasis"><em>Business key equality</em></span>.
        </p><p>
            Business key equality means that the <tt class="literal">equals()</tt>
            method compares only the properties that form the business key, a key that would
            identify our instance in the real world (a <span class="emphasis"><em>natural</em></span> candidate key):
        </p><pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if (!(other instanceof Cat)) return false;

        final Cat cat = (Cat) other;

        if (!getName().equals(cat.getName())) return false;
        if (!getBirthday().equals(cat.getBirthday())) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getName().hashCode();
        result = 29 * result + getBirthday().hashCode();
        return result;
    }

}</pre><p>
            Keep in mind that our candidate key (in this case a composite of name and birthday)
            has to be only valid for a particular comparison operation (maybe even only in a
            single use case). We don't need the stability criteria we usually apply to a real
            primary key!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-lifecycle"></a>4.4.&nbsp;Lifecycle Callbacks</h2></div></div><div></div></div><p>
            Optionally, a persistent class might implement the interface 
            <tt class="literal">Lifecycle</tt> which provides some callbacks that allow
            the persistent object to perform necessary initialization/cleanup after
            save or load and before deletion or update.
        </p><p>
            
            The Hibernate <tt class="literal">Interceptor</tt> offers a less intrusive
            alternative, however.
        </p><div class="programlistingco"><pre class="programlisting">public interface Lifecycle {
        public boolean onSave(Session s) throws CallbackException;   <span class="co">(1)</span>
        public boolean onUpdate(Session s) throws CallbackException; <span class="co">(2)</span>
        public boolean onDelete(Session s) throws CallbackException; <span class="co">(3)</span>
        public void onLoad(Session s, Serializable id);              <span class="co">(4)</span>
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">onSave</tt> - called just before the object is saved or
                        inserted
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">onUpdate</tt> - called just before an object is updated 
                        (when the object is passed to <tt class="literal">Session.update()</tt>)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">onDelete</tt> - called just before an object is deleted
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">onLoad</tt> - called just after an object is loaded
                    </p></td></tr></table></div></div><p>
            <tt class="literal">onSave()</tt>, <tt class="literal">onDelete()</tt> and
            <tt class="literal">onUpdate()</tt> may be used to cascade saves and
            deletions of dependent objects. This is an alternative to declaring cascaded
            operations in the mapping file. <tt class="literal">onLoad()</tt> may
            be used to initialize transient properties of the object from its persistent
            state. It may not be used to load dependent objects since the
            <tt class="literal">Session</tt> interface may not be invoked from
            inside this method. A further intended usage of <tt class="literal">onLoad()</tt>, 
            <tt class="literal">onSave()</tt> and <tt class="literal">onUpdate()</tt> is to store a 
            reference to the current <tt class="literal">Session</tt> for later use.
        </p><p>
            Note that <tt class="literal">onUpdate()</tt> is not called every time the object's
            persistent state is updated. It is called only when a transient object is passed
            to <tt class="literal">Session.update()</tt>.
        </p><p>
            If <tt class="literal">onSave()</tt>, <tt class="literal">onUpdate()</tt> or
            <tt class="literal">onDelete()</tt> return <tt class="literal">true</tt>, the operation is 
            silently vetoed. If a <tt class="literal">CallbackException</tt> is thrown, the operation 
            is vetoed and the exception is passed back to the application.
        </p><p>
            Note that <tt class="literal">onSave()</tt> is called after an identifier is assigned to 
            the object, except when native key generation is used.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-validatable"></a>4.5.&nbsp;Validatable callback</h2></div></div><div></div></div><p>
            If the persistent class needs to check invariants before its state is
            persisted, it may implement the following interface:
        </p><pre class="programlisting">public interface Validatable {
        public void validate() throws ValidationFailure;
}</pre><p>
            The object should throw a <tt class="literal">ValidationFailure</tt> if an invariant 
            was violated. An instance of <tt class="literal">Validatable</tt> should not change 
            its state from inside <tt class="literal">validate()</tt>.
        </p><p>
            Unlike the callback methods of the <tt class="literal">Lifecycle</tt> interface, 
            <tt class="literal">validate()</tt> might be called at unpredictable times. The
            application should not rely upon calls to <tt class="literal">validate()</tt> for
            business functionality.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-xdoclet"></a>4.6.&nbsp;Using XDOclet markup</h2></div></div><div></div></div><p>
            In the next chapter we will show how Hibernate mappings may be expressed using
            a simple, readable XML format. Many Hibernate users prefer to embed mapping
            information directly in sourcecode using XDoclet <tt class="literal">@hibernate.tags</tt>.
            We will not cover this approach in this document, since strictly it is considered
            part of XDoclet. However, we include the following example of the <tt class="literal">Cat</tt>
            class with XDoclet mappings.
        </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mate;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /**
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="MATE_ID"
     */
    public Cat getMate() {
        return mate;
    }
    void setMate(Cat mate) {
        this.mate = mate;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  lazy="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mapping"></a>Chapter&nbsp;5.&nbsp;Basic O/R Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-declaration"></a>5.1.&nbsp;Mapping declaration</h2></div></div><div></div></div><p>
            Object/relational mappings are defined in an XML document. The mapping document
            is designed to be readable and hand-editable. The mapping language is Java-centric,
            meaning that mappings are constructed around persistent class declarations, not
            table declarations.
        </p><p>
            Note that, even though many Hibernate users choose to define XML mappings be hand,
            a number of tools exist to generate the mapping document, including XDoclet,
            Middlegen and AndroMDA.
        </p><p>
            Lets kick off with an example mapping:
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS" discriminator-value="C"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;discriminator column="subclass" type="character"/&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true" update="false"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate" column="mate_id"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;subclass name="DomesticCat" discriminator-value="D"&gt;
                        &lt;property name="name" type="string"/&gt;
                &lt;/subclass&gt;
        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
             We will now discuss the content of the mapping document. We will only describe the 
             document elements and attributes that are used by Hibernate at runtime. The mapping 
             document also contains some extra optional attributes and elements that affect the 
             database schemas exported by the schema export tool. (For example the <tt class="literal">
             not-null</tt> attribute.)
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-doctype"></a>5.1.1.&nbsp;Doctype</h3></div></div><div></div></div><p>
                All XML mappings should declare the doctype shown. The actual DTD may be found 
                at the URL above, in the directory <tt class="literal">hibernate-x.x.x/src/net/sf/hibernate
                </tt> or in <tt class="literal">hibernate.jar</tt>. Hibernate will always look for 
                the DTD in its classpath first.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-mapping"></a>5.1.2.&nbsp;hibernate-mapping</h3></div></div><div></div></div><p>
                This element has three optional attributes. The <tt class="literal">schema</tt> attribute
                specifies that tables referred to by this mapping belong to the named schema. If specified, 
                tablenames will be qualified by the given schema name. If missing, tablenames will be 
                unqualified. The <tt class="literal">default-cascade</tt> attribute specifies what cascade style
                should be assumed for properties and collections which do not specify a 
                <tt class="literal">cascade</tt> attribute. The <tt class="literal">auto-import</tt> attribute lets us
                use unqualified class names in the query language, by default.
            </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schema="schemaName"                          <span class="co">(1)</span>
         default-cascade="none|save-update"           <span class="co">(2)</span>
         auto-import="true|false"                     <span class="co">(3)</span>
         package="package.name"                       <span class="co">(4)</span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                             <tt class="literal">schema</tt> (optional): The name of a database schema.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                             <tt class="literal">default-cascade</tt> (optional - defaults to <tt class="literal">none</tt>): 
                             A default cascade style.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                             <tt class="literal">auto-import</tt> (optional - defaults to <tt class="literal">true</tt>):
                             Specifies whether we can use unqualified class names (of classes in this mapping)
                             in the query language.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                             <tt class="literal">package</tt> (optional): Specifies a package prefix to assume for 
                             unqualified class names in the mapping document.
                         </p></td></tr></table></div></div><p>
                 If you have two persistent classes with the same (unqualified) name, you should set 
                 <tt class="literal">auto-import="false"</tt>. Hibernate will throw an exception if you attempt
                 to assign two classes to the same "imported" name.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-class"></a>5.1.3.&nbsp;class</h3></div></div><div></div></div><p>
                You may declare a persistent class using the <tt class="literal">class</tt> element:
            </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="ClassName"                              <span class="co">(1)</span>
        table="tableName"                             <span class="co">(2)</span>
        discriminator-value="discriminator_value"     <span class="co">(3)</span>
        mutable="true|false"                          <span class="co">(4)</span>
        schema="owner"                                <span class="co">(5)</span>
        proxy="ProxyInterface"                        <span class="co">(6)</span>
        dynamic-update="true|false"                   <span class="co">(7)</span>
        dynamic-insert="true|false"                   <span class="co">(8)</span>
        select-before-update="true|false"             <span class="co">(9)</span>
        polymorphism="implicit|explicit"              <span class="co">(10)</span>
        where="arbitrary sql where condition"         <span class="co">(11)</span>
        persister="PersisterClass"                    <span class="co">(12)</span>
        batch-size="N"                                <span class="co">(13)</span>
        optimistic-lock="none|version|dirty|all"      <span class="co">(14)</span>
        lazy="true|false"                             <span class="co">(15)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified Java class name of the persistent class 
                            (or interface).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: The name of its database table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optional - defaults to the class name): A value
                            that distiguishes individual subclasses, used for polymorphic behaviour. Acceptable
                            values include <tt class="literal">null</tt> and <tt class="literal">not null</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">mutable</tt> (optional, defaults to <tt class="literal">true</tt>): Specifies 
                            that instances of the class are (not) mutable.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optional): Override the schema name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies an interface to use for lazy
                            initializing proxies. You may specify the name of the class itself.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-update</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that <tt class="literal">UPDATE</tt> SQL should be generated at runtime and 
                            contain only those columns whose values have changed.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-insert</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that <tt class="literal">INSERT</tt> SQL should be generated at runtime and 
                            contain only the columns whose values are not null.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">select-before-update</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that Hibernate should <span class="emphasis"><em>never</em></span> perform an SQL <tt class="literal">UPDATE</tt> 
                            unless it is certain that an object is actually modified. In certain cases (actually, only
                            when a transient object has been associated with a new session using <tt class="literal">update()</tt>),
                            this means that Hibernate will perform an extra SQL <tt class="literal">SELECT</tt> to determine
                            if an <tt class="literal">UPDATE</tt> is actually required.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">polymorphism</tt> (optional, defaults to <tt class="literal">implicit</tt>): 
                            Determines whether implicit or explicit query polymorphism is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">where</tt> (optional) specify an arbitrary SQL <tt class="literal">WHERE</tt> 
                            condition to be used when retrieving objects of this class
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">persister</tt> (optional): Specifies a custom <tt class="literal">ClassPersister</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">batch-size</tt> (optional, defaults to <tt class="literal">1</tt>) specify a "batch size" 
                            for fetching instances of this class by identifier.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional, defaults to <tt class="literal">version</tt>): 
                            Determines the optimistic locking strategy.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional): Setting <tt class="literal">lazy="true"</tt> is a shortcut 
                            equalivalent to specifying the name of the class itself as the <tt class="literal">proxy</tt>
                            interface.
                        </p></td></tr></table></div></div><p>
                It is perfectly acceptable for the named persistent class to be an interface. You would then
                declare implementing classes of that interface using the <tt class="literal">&lt;subclass&gt;</tt>
                element. You may persist any <span class="emphasis"><em>static</em></span> inner class. You should specify the
                class name using the standard form ie. <tt class="literal">eg.Foo$Bar</tt>.
            </p><p>
                Immutable classes, <tt class="literal">mutable="false"</tt>, may not be updated or deleted by the 
                application. This allows Hibernate to make some minor performance optimizations.
            </p><p>
                The optional <tt class="literal">proxy</tt> attribute enables lazy initialization of persistent
                instances of the class. Hibernate will initially return CGLIB proxies which implement 
                the named interface. The actual persistent object will be loaded when a method of the 
                proxy is invoked. See "Proxies for Lazy Initialization" below.
            </p><p><span class="emphasis"><em>Implicit</em></span> polymorphism means that instances of the class will be returned
                by a query that names any superclass or implemented interface or the class and that instances
                of any subclass of the class will be returned by a query that names the class itself. 
                <span class="emphasis"><em>Explicit</em></span> polymorphism means that class instances will be returned only
                be queries that explicitly name that class and that queries that name the class will return
                only instances of subclasses mapped inside this <tt class="literal">&lt;class&gt;</tt> declaration
                as a <tt class="literal">&lt;subclass&gt;</tt> or <tt class="literal">&lt;joined-subclass&gt;</tt>. For
                most purposes the default, <tt class="literal">polymorphism="implicit"</tt>, is appropriate.
                Explicit polymorphism is useful when two different classes are mapped to the same table
                (this allows a "lightweight" class that contains a subset of the table columns).
            </p><p>
                The <tt class="literal">persister</tt> attribute lets you customize the persistence strategy used for
                the class. You may, for example, specify your own subclass of 
                <tt class="literal">net.sf.hibernate.persister.EntityPersister</tt> or you might even provide a
                completely new implementation of the interface 
                <tt class="literal">net.sf.hibernate.persister.ClassPersister</tt> that implements persistence via,
                for example, stored procedure calls, serialization to flat files or LDAP. See
                <tt class="literal">net.sf.hibernate.test.CustomPersister</tt> for a simple example (of "persistence"
                to a <tt class="literal">Hashtable</tt>).
            </p><p>
                Note that the <tt class="literal">dynamic-update</tt> and <tt class="literal">dynamic-insert</tt>
                settings are not inherited by subclasses and so may also be specified on the
                <tt class="literal">&lt;subclass&gt;</tt> or <tt class="literal">&lt;joined-subclass&gt;</tt> elements. 
                These settings may increase performance in some cases, but might actually decrease 
                performance in others. Use judiciously.
            </p><p>
                Use of <tt class="literal">select-before-update</tt> will usually decrease performance. It is very
                useful to prevent a database update trigger being called unnecessarily.
            </p><p>
            	If you enable <tt class="literal">dynamic-update</tt>, you will have a choice of optimistic
            	locking strategies:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
            			<tt class="literal">version</tt> check the version/timestamp columns
            		</p></li><li><p>
            			<tt class="literal">all</tt> check all columns
            		</p></li><li><p>
            			<tt class="literal">dirty</tt> check the changed columns
            		</p></li><li><p>
            			<tt class="literal">none</tt> do not use optimistic locking
            		</p></li></ul></div><p>
            	We <span class="emphasis"><em>very</em></span> strongly recommend that you use version/timestamp
            	columns for optimistic locking with Hibernate. This is the optimal strategy with
            	respect to performance and is the only strategy that correctly handles modifications
            	made outside of the session (ie. when <tt class="literal">Session.update()</tt> is used).
            	Keep in mind that a version or timestamp property should never be null, no matter
            	what <tt class="literal">unsaved-value</tt> strategy, or an instance will be detected as
            	transient.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-id"></a>5.1.4.&nbsp;id</h3></div></div><div></div></div><p>
                Mapped classes <span class="emphasis"><em>must</em></span> declare the primary key column of the database 
                table. Most classes will also have a JavaBeans-style property holding the unique identifier 
                of an instance. The <tt class="literal">&lt;id&gt;</tt> element defines the mapping from that
                property to the primary key column.
            </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="propertyName"                      <span class="co">(1)</span>
        type="typename"                          <span class="co">(2)</span>
        column="column_name"                     <span class="co">(3)</span>
        unsaved-value="any|none|null|id_value"   <span class="co">(4)</span>
        access="field|property|ClassName"&gt;       <span class="co">(5)</span>

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (optional): The name of the identifier property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional): A name that indicates the Hibernate type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The
                            name of the primary key column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">null</tt>): 
                            An identifier property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr></table></div></div><p>
                If the <tt class="literal">name</tt> attribute is missing, it is assumed that the class has no 
                identifier property.
            </p><p>
                The <tt class="literal">unsaved-value</tt> attribute is important! If the identfier property of your 
                class does not default to <tt class="literal">null</tt>, then you should specify the actual default.
            </p><p>
                There is an alternative <tt class="literal">&lt;composite-id&gt;</tt> declaration to allow access to
                legacy data with composite keys. We strongly discourage its use for anything else.
            </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-generator"></a>5.1.4.1.&nbsp;generator</h4></div></div><div></div></div><p>
                    The required <tt class="literal">&lt;generator&gt;</tt> child element names a Java class used
                    to generate unique identifiers for instances of the persistent class. If any parameters
                    are required to configure or initialize the generator instance, they are passed using the
                    <tt class="literal">&lt;param&gt;</tt> element.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="uid" unsaved-value="0"&gt;
        &lt;generator class="net.sf.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    All generators implement the interface <tt class="literal">net.sf.hibernate.id.IdentifierGenerator</tt>.
                    This is a very simple interface; some applications may choose to provide their own specialized
                    implementations. However, Hibernate provides a range of built-in implementations. There are shortcut
                    names for the built-in generators:

                    </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">increment</tt></span></dt><dd><p>
                                generates identifiers of type <tt class="literal">long</tt>, <tt class="literal">short</tt> or
                                <tt class="literal">int</tt> that are unique only when no other process is inserting data
                                into the same table.
                                <span class="emphasis"><em>Do not use in a cluster.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">identity</tt></span></dt><dd><p>
                                supports identity columns in DB2, MySQL, MS SQL Server, Sybase and
                                HypersonicSQL. The returned identifier is of type <tt class="literal">long</tt>,
                                <tt class="literal">short</tt> or <tt class="literal">int</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">sequence</tt></span></dt><dd><p>
                                uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator
                                in Interbase. The returned identifier is of type <tt class="literal">long</tt>,
                                <tt class="literal">short</tt> or <tt class="literal">int</tt>
                            </p></dd><dt><span class="term"><tt class="literal">hilo</tt></span></dt><dd><p><a name="mapping-declaration-id-hilodescription"></a>
                                uses a hi/lo algorithm to efficiently generate identifiers of
                                type <tt class="literal">long</tt>, <tt class="literal">short</tt> or <tt class="literal">int</tt>,
                                given a table and column (by default <tt class="literal">hibernate_unique_key</tt> and
                                <tt class="literal">next_hi</tt> respectively) as a source of hi values. The hi/lo algorithm
                                generates identifiers that are unique only for a particular database. <span class="emphasis"><em>Do not
                                use this generator with connections enlisted with JTA or with a user-supplied
                                connection.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">seqhilo</tt></span></dt><dd><p>
                                uses a hi/lo algorithm to efficiently generate identifiers of type
                                <tt class="literal">long</tt>, <tt class="literal">short</tt> or <tt class="literal">int</tt>,
                                given a named database sequence.
                            </p></dd><dt><span class="term"><tt class="literal">uuid.hex</tt></span></dt><dd><p>
                                uses a 128-bit UUID algorithm to generate identifiers of type string,
                                unique within a network (the IP address is used). The UUID is encoded
                                as a string of hexadecimal digits of length 32.
                            </p></dd><dt><span class="term"><tt class="literal">uuid.string</tt></span></dt><dd><p>
                                uses the same UUID algorithm. The UUID is encoded a string of length 16
                                consisting of (any) ASCII characters. <span class="emphasis"><em>Do not use with PostgreSQL.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">native</tt></span></dt><dd><p>
                                picks <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> or
                                <tt class="literal">hilo</tt> depending upon the capabilities of the
                                underlying database.
                            </p></dd><dt><span class="term"><tt class="literal">assigned</tt></span></dt><dd><p>
                                lets the application to assign an identifier to the object before
                                <tt class="literal">save()</tt> is called.
                            </p></dd><dt><span class="term"><tt class="literal">foreign</tt></span></dt><dd><p>
                                uses the identifier of another associated object. Usually used in conjunction
                                with a <tt class="literal">&lt;one-to-one&gt;</tt> primary key association.
                            </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-hilo"></a>5.1.4.2.&nbsp;Hi/Lo Algorithm</h4></div></div><div></div></div><p>
                    The <tt class="literal">hilo</tt> and <tt class="literal">seqhilo</tt> generators provide two alternate
                    implementations of the hi/lo algorithm, a favorite approach to identifier generation. The
                    first implementation requires a "special" database table to hold the next available "hi" value.
                    The second uses an Oracle-style sequence (where supported).
                </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    Unfortunately, you can't use <tt class="literal">hilo</tt> when supplying your own
                    <tt class="literal">Connection</tt>  to Hibernate, or when Hibernate is using an application
                    server datasource to obtain connections enlisted with JTA. Hibernate must be able to
                    fetch the "hi" value in a new transaction. A standard approach in an EJB environment is
                    to implement the hi/lo algorithm using a stateless session bean.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-uuid"></a>5.1.4.3.&nbsp;UUID Algorithm</h4></div></div><div></div></div><p>
                    The UUIDs contain: IP address, startup time of the JVM (accurate to a quarter
                    second), system time and a counter value (unique within the JVM). It's not
                    possible to obtain a MAC address or memory address from Java code, so this is
                    the best we can do without using JNI.
                </p><p>
                    Don't try to use <tt class="literal">uuid.string</tt> in PostgreSQL.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-sequences"></a>5.1.4.4.&nbsp;Identity columns and Sequences</h4></div></div><div></div></div><p>
                    For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you
                    may use <tt class="literal">identity</tt> key generation. For databases that support
                    sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you may use
                    <tt class="literal">sequence</tt> style key generation. Both these strategies require
                    two SQL queries to insert a new object.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="uid"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="uid" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>
                    For cross-platform development, the <tt class="literal">native</tt> strategy will
                    choose from the <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> and
                    <tt class="literal">hilo</tt> strategies, dependant upon the capabilities of the
                    underlying database.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-assigned"></a>5.1.4.5.&nbsp;Assigned Identifiers</h4></div></div><div></div></div><p>
                    If you want the application to assign identifiers (as opposed to having
                    Hibernate generate them), you may use the <tt class="literal">assigned</tt> generator.
                    This special generator will use the identifier value already assigned to the
                    object's identifier property. Be very careful when using this feature to assign
                    keys with business meaning (almost always a terrible design decision).
                </p><p>
                    Due to its inherent nature, entities that use this generator cannot be saved
                    via the Session's saveOrUpdate() method. Instead you have to explicitly specify to
                    Hibernate if the object should be saved or updated by calling either the
                    <tt class="literal">save()</tt> or <tt class="literal">update()</tt> method of the Session.
                </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-compositeid"></a>5.1.5.&nbsp;composite-id</h3></div></div><div></div></div><pre class="programlisting">&lt;composite-id
        name="propertyName"
        class="ClassName"
        unsaved-value="any|none"
        access="field|property|ClassName"&gt;

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</pre><p>
                For a table with a composite key, you may map multiple properties of the class
                as identifier properties. The <tt class="literal">&lt;composite-id&gt;</tt> element
                accepts <tt class="literal">&lt;key-property&gt;</tt> property mappings and
                <tt class="literal">&lt;key-many-to-one&gt;</tt> mappings as child elements.
            </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>
                Your persistent class <span class="emphasis"><em>must</em></span> override <tt class="literal">equals()</tt>
                and <tt class="literal">hashCode()</tt> to implement composite identifier equality. It must
                also implements <tt class="literal">Serializable</tt>.
            </p><p>
                Unfortunately, this approach to composite identifiers means that a persistent object 
                is its own identifier. There is no convenient "handle" other than the object itself. 
                You must instantiate an instance of the persistent class itself and populate its 
                identifier properties before you can <tt class="literal">load()</tt> the persistent state
                associated with a composite key. We will describe a much more
                convenient approach where the composite identifier is implemented as a seperate class
                in <a href="#components-compositeid" title="7.4.&nbsp;Components as composite identifiers">Section&nbsp;7.4, &#8220;Components as composite identifiers&#8221;</a>. The attributes described below apply only
                to this alternative approach:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">name</tt> (optional): A property of component type that holds the
                        composite identifier (see next section).
                    </p></li><li><p>
                        <tt class="literal">class</tt> (optional - defaults to the property type determined by 
                        reflection): The component class used as a composite identifier (see next section).
                    </p></li><li><p>
                        <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">none</tt>): 
                        Indicates that transient instances should be considered newly instantiated, if set 
                        to <tt class="literal">any</tt>.
                    </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-discriminator"></a>5.1.6.&nbsp;discriminator</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;discriminator&gt;</tt> element is required for polymorphic persistence 
                using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the 
                table. The discriminator column contains marker values that tell the persistence layer what 
                subclass to instantiate for a particular row. A restricted set of types may be used: 
                <tt class="literal">string</tt>, <tt class="literal">character</tt>, <tt class="literal">integer</tt>, 
                <tt class="literal">byte</tt>, <tt class="literal">short</tt>, <tt class="literal">boolean</tt>, 
                <tt class="literal">yes_no</tt>, <tt class="literal">true_false</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="discriminator_column"  <span class="co">(1)</span>
        type="discriminator_type"      <span class="co">(2)</span>
        force="true|false"             <span class="co">(3)</span>
        insert="true|false"            <span class="co">(4)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to <tt class="literal">class</tt>) the
                            name of the discriminator column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional - defaults to <tt class="literal">string</tt>) a
                            name that indicates the Hibernate type
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">force</tt> (optional - defaults to <tt class="literal">false</tt>) 
                            "force" Hibernate to specify allowed discriminator values even when retrieving 
                            all instances of the root class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optional - defaults to <tt class="literal">true</tt>)
                            set this to <tt class="literal">false</tt> if your discriminator column is also part
                            of a mapped composite identifier.
                        </p></td></tr></table></div></div><p>
                Actual values of the discriminator column are specified by the
                <tt class="literal">discriminator-value</tt> attribute of the <tt class="literal">&lt;class&gt;</tt> and
                <tt class="literal">&lt;subclass&gt;</tt> elements.
            </p><p>
                The <tt class="literal">force</tt> attribute is (only) useful if the table contains rows with
                "extra" discriminator values that are not mapped to a persistent class. This will not
                usually be the case.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-version"></a>5.1.7.&nbsp;version (optional)</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;version&gt;</tt> element is optional and indicates that
                the table contains versioned data. This is particularly useful if you plan to
                use <span class="emphasis"><em>long transactions</em></span> (see below).
            </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="version_column"                            <span class="co">(1)</span>
        name="propertyName"                                <span class="co">(2)</span>
        type="typename"                                    <span class="co">(3)</span>
        access="field|property|ClassName"                  <span class="co">(4)</span>
        unsaved-value="null|negative|undefined"            <span class="co">(5)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The name
                            of the column holding the version number.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of a property  of the persistent class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional - defaults to <tt class="literal">integer</tt>): 
                            The type of the version number.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">undefined</tt>): 
                            A version property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session. (<tt class="literal">undefined</tt> specifies that the identifier
                            property value should be used.)
                        </p></td></tr></table></div></div><p>
                Version numbers may be of type <tt class="literal">long</tt>, <tt class="literal">integer</tt>,
                <tt class="literal">short</tt>, <tt class="literal">timestamp</tt> or <tt class="literal">calendar</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-timestamp"></a>5.1.8.&nbsp;timestamp (optional)</h3></div></div><div></div></div><p>
                The optional <tt class="literal">&lt;timestamp&gt;</tt> element indicates that the table contains 
                timestamped data. This is intended as an alternative to versioning. Timestamps are by nature
                a less safe implementation of optimistic locking. However, sometimes the application might
                use the timestamps in other ways.
            </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="timestamp_column"           <span class="co">(1)</span>
        name="propertyName"                 <span class="co">(2)</span>
        access="field|property|ClassName"   <span class="co">(3)</span>
        unsaved-value="null|undefined"      <span class="co">(4)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The name
                            of a column holding the timestamp.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of a JavaBeans style property of
                            Java type <tt class="literal">Date</tt> or <tt class="literal">Timestamp</tt> of the
                            persistent class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">null</tt>): 
                            A version property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session. (<tt class="literal">undefined</tt> specifies that the identifier
                            property value should be used.)
                        </p></td></tr></table></div></div><p>
                Note that <tt class="literal">&lt;timestamp&gt;</tt> is equivalent to 
                <tt class="literal">&lt;version type="timestamp"&gt;</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-property"></a>5.1.9.&nbsp;property</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;property&gt;</tt> element declares a persistent, JavaBean style 
                property of the class.
            </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="propertyName"                 <span class="co">(1)</span>
        column="column_name"                <span class="co">(2)</span>
        type="typename"                     <span class="co">(3)</span>
        update="true|false"                 <span class="co">(4)</span>
        insert="true|false"                 <span class="co">(4)</span>
        formula="arbitrary SQL expression"  <span class="co">(5)</span>
        access="field|property|ClassName"   <span class="co">(6)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: the name of the property, with an initial lowercase
                            letter.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): the name
                            of the mapped database table column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional): a name that indicates the Hibernate type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optional - defaults to <tt class="literal">true</tt>) :
                            specifies that the mapped columns should be included in SQL <tt class="literal">UPDATE</tt> 
                            and/or <tt class="literal">INSERT</tt> statements. Setting both to <tt class="literal">false</tt>
                            allows a pure "derived" property whose value is initialized from some other
                            property that maps to the same colum(s) or by a trigger or other application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): an SQL expression that defines the value for a
                            <span class="emphasis"><em>computed</em></span> property. Computed properties do not have a column
                            mapping of their own.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr></table></div></div><p>
                <span class="emphasis"><em>typename</em></span> could be:
            </p><div class="orderedlist"><ol type="1" compact><li><p>
                        The name of a Hibernate basic type (eg. <tt class="literal">integer, string, character,
                        date, timestamp, float, binary, serializable, object, blob</tt>).
                    </p></li><li><p>
                        The name of a Java class with a default basic type (eg. <tt class="literal">int, float,
                        char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</tt>).
                    </p></li><li><p>
                        The name of a subclass of <tt class="literal">PersistentEnum</tt> (eg. <tt class="literal">eg.Color</tt>).
                    </p></li><li><p>
                        The name of a serializable Java class.
                    </p></li><li><p>
                        The class name of a custom type (eg. <tt class="literal">com.illflow.type.MyCustomType</tt>).
                    </p></li></ol></div><p>
                If you do not specify a type, Hibernate will use reflection upon the named
                property to take a guess at the correct Hibernate type. Hibernate will try to
                interpret the name of the return class of the property getter using rules 2, 3,
                4 in that order. However, this is not always enough.
                In certain cases you will still need the <tt class="literal">type</tt>
                attribute. (For example, to distinguish between <tt class="literal">Hibernate.DATE</tt> and
                <tt class="literal">Hibernate.TIMESTAMP</tt>, or to specify a custom type.)
            </p><p>
            	The <tt class="literal">access</tt> attribute lets you control how Hibernate will access
            	the property at runtime. By default, Hibernate will call the property get/set pair.
            	If you specify <tt class="literal">access="field"</tt>, Hibernate will bypass the get/set
            	pair and access the field directly, using reflection. You may specify your own
            	strategy for property access by naming a class that implements the interface
            	<tt class="literal">net.sf.hibernate.property.PropertyAccessor</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-manytoone"></a>5.1.10.&nbsp;many-to-one</h3></div></div><div></div></div><p>
                An ordinary association to another persistent class is declared using a
                <tt class="literal">many-to-one</tt> element. The relational model is a
                many-to-one association. (Its really just an object reference.)
            </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="propertyName"                                <span class="co">(1)</span>
        column="column_name"                               <span class="co">(2)</span>
        class="ClassName"                                  <span class="co">(3)</span>
        cascade="all|none|save-update|delete"              <span class="co">(4)</span>
        outer-join="true|false|auto"                       <span class="co">(5)</span>
        update="true|false"                                <span class="co">(6)</span>
        insert="true|false"                                <span class="co">(6)</span>
        property-ref="propertyNameFromAssociatedClass"     <span class="co">(7)</span>
        access="field|property|ClassName"                  <span class="co">(8)</span>
		unique="true|false"                                      <span class="co">(9)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional): The name of the column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional): Specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">outer-join</tt> (optional - defaults to <tt class="literal">auto</tt>): 
                            enables outer-join fetching for this association when 
                            <tt class="literal">hibernate.use_outer_join</tt> is set.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optional - defaults to <tt class="literal">true</tt>) 
                            specifies that the mapped columns should be included in SQL <tt class="literal">UPDATE</tt> 
                            and/or <tt class="literal">INSERT</tt> statements. Setting both to <tt class="literal">false</tt>
                            allows a pure "derived" association whose value is initialized from some other
                            property that maps to the same colum(s) or by a trigger or other application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (optional) The name of a property of the associated 
                            class that is joined to this foreign key. If not specified, the primary key of
                            the associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
							 <tt class="literal">unique</tt> (optional): Enable the DDL generation of a unique
							 constraint for the foreign-key column.
						 </p></td></tr></table></div></div><p>
                The <tt class="literal">cascade</tt> attribute permits the following values: 
                <tt class="literal">all</tt>, <tt class="literal">save-update</tt>, <tt class="literal">delete</tt>,
                <tt class="literal">none</tt>. Setting a value other than <tt class="literal">none</tt>
                will propagate certain operations to the associated (child) object.
                See "Lifecycle Objects" below.
            </p><p>
                The <tt class="literal">outer-join</tt> attribute accepts three different values:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">auto</tt> (default) Fetch the association using an
                        outerjoin if the associated class has no proxy
                    </p></li><li><p>
                        <tt class="literal">true</tt> Always fetch the association using an 
                        outerjoin
                    </p></li><li><p>
                        <tt class="literal">false</tt> Never fetch the association using an
                        outerjoin
                    </p></li></ul></div><p>
                A typical <tt class="literal">many-to-one</tt> declaration looks as simple as
            </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>
                The <tt class="literal">property-ref</tt> attribute should only be used for mapping legacy
                data where a foreign key refers to a unique key of the associated table other than
                the primary key. This is an ugly relational model. For example, suppose the 
                <tt class="literal">Product</tt> class had a unique serial number, that is not the primary 
                key. (The <tt class="literal">unique</tt> attribute controls Hibernate's DDL generation with
                the SchemaExport tool.)
            </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>
                Then the mapping for <tt class="literal">OrderItem</tt> might use:
            </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>
                This is certainly not encouraged, however.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-onetoone"></a>5.1.11.&nbsp;one-to-one</h3></div></div><div></div></div><p>
                A one-to-one association to another persistent class is declared using a 
                <tt class="literal">one-to-one</tt> element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="propertyName"                                <span class="co">(1)</span>
        class="ClassName"                                  <span class="co">(2)</span>
        cascade="all|none|save-update|delete"              <span class="co">(3)</span>
        constrained="true|false"                           <span class="co">(4)</span>
        outer-join="true|false|auto"                       <span class="co">(5)</span>
        property-ref="propertyNameFromAssociatedClass"     <span class="co">(6)</span>
        access="field|property|ClassName"                  <span class="co">(7)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional) specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">constrained</tt> (optional) specifies that a foreign key constraint
                            on the primary key of the mapped table references the table of the associated
                            class. This option affects the order in which <tt class="literal">save()</tt> and
                            <tt class="literal">delete()</tt> are cascaded (and is also used by the schema export
                            tool).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">outer-join</tt> (optional - defaults to <tt class="literal">auto</tt>): 
                            Enable outer-join fetching for this association when 
                            <tt class="literal">hibernate.use_outer_join</tt> is set.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (optional) The name of a property of the associated class
                            that is joined to the primary key of this class. If not specified, the primary key of
                            the associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr></table></div></div><p>
                There are two varieties of one-to-one association:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                primary key associations
            </p></li><li><p>
                unique foreign key associations
            </p></li></ul></div><p>
                Primary key associations don't need an extra table column; if two rows are related by
                the association then the two table rows share the same primary key value. So if you want 
                two objects to be related by a primary key association, you must make sure that they
                are assigned the same identifier value!
            </p><p>
                For a primary key association, add the following mappings to <tt class="literal">Employee</tt> and 
                <tt class="literal">Person</tt>, respectively.
            </p><pre class="programlisting">&lt;one-to-one name="person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</pre><p>
                Now we must ensure that the primary keys of related rows in the PERSON and
                EMPLOYEE tables are equal. We use a special Hibernate identifier generation strategy
                called <tt class="literal">foreign</tt>:
            </p><pre class="programlisting">&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>
                A newly saved instance of <tt class="literal">Person</tt> is then assigned the same primar
                key value as the <tt class="literal">Employee</tt> instance refered with the <tt class="literal">employee</tt>
                property of that <tt class="literal">Person</tt>.
            </p><p>
                Alternatively, a foreign key with a unique constraint, from <tt class="literal">Employee</tt> to 
                <tt class="literal">Person</tt>, may be expressed as:
            </p><pre class="programlisting">&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>
                And this association may be made bidirectional by adding the following to the 
                <tt class="literal">Person</tt> mapping:
            </p><pre class="programlisting">&lt;one-to-one name"employee" class="Employee" property-ref="person"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-component"></a>5.1.12.&nbsp;component, dynamic-component</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;component&gt;</tt> element maps properties of a
                child object to columns of the table of a parent class. Components may, in
                turn, declare their own properties, components or collections. See
                "Components" below.
            </p><div class="programlistingco"><pre class="programlisting">&lt;component 
        name="propertyName"                 <span class="co">(1)</span>
        class="className"                   <span class="co">(2)</span>
        insert="true|false"                 <span class="co">(3)</span>
        upate="true|false"                  <span class="co">(4)</span>
        access="field|property|ClassName"&gt;  <span class="co">(5)</span>
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the component (child) class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">INSERT</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">UPDATE</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr></table></div></div><p>
                The child <tt class="literal">&lt;property&gt;</tt> tags map properties of the
                child class to table columns.
            </p><p>
                The <tt class="literal">&lt;component&gt;</tt> element allows a <tt class="literal">&lt;parent&gt;</tt>
                subelement that maps a property of the component class as a reference back to the
                containing entity.
            </p><p>
                The <tt class="literal">&lt;dynamic-component&gt;</tt> element allows a <tt class="literal">Map</tt>
                to be mapped as a component, where the property names refer to keys of the map.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-subclass"></a>5.1.13.&nbsp;subclass</h3></div></div><div></div></div><p>
                Finally, polymorphic persistence requires the declaration of each subclass of
                the root persistent class. For the (recommended) table-per-class-hierarchy
                mapping strategy, the <tt class="literal">&lt;subclass&gt;</tt> declaration is used.
            </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="ClassName"                              <span class="co">(1)</span>
        discriminator-value="discriminator_value"     <span class="co">(2)</span>
        proxy="ProxyInterface"                        <span class="co">(3)</span>
        lazy="true|false"                             <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optional - defaults to the class name): A
                            value that distiguishes individual subclasses.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use for 
                            lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional): Setting <tt class="literal">lazy="true"</tt> is a shortcut 
                            equalivalent to specifying the name of the class itself as the <tt class="literal">proxy</tt>
                            interface.
                        </p></td></tr></table></div></div><p>
                Each subclass should declare its own persistent properties and subclasses.
                <tt class="literal">&lt;version&gt;</tt> and <tt class="literal">&lt;id&gt;</tt> properties
                are assumed to be inherited from the root class. Each subclass in a heirarchy must
                define a unique <tt class="literal">discriminator-value</tt>. If none is specified, the
                fully qualified Java class name is used.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-joinedsubclass"></a>5.1.14.&nbsp;joined-subclass</h3></div></div><div></div></div><p>
                Alternatively, a subclass that is persisted to its own table (table-per-subclass 
                mapping strategy) is declared using a <tt class="literal">&lt;joined-subclass&gt;</tt>
                element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="ClassName"                    <span class="co">(1)</span>
        proxy="ProxyInterface"              <span class="co">(2)</span>
        lazy="true|false"                   <span class="co">(3)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/joined-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use 
                            for lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional): Setting <tt class="literal">lazy="true"</tt> is a shortcut 
                            equalivalent to specifying the name of the class itself as the <tt class="literal">proxy</tt>
                            interface.
                        </p></td></tr></table></div></div><p>
                No discriminator column is required for this mapping strategy. Each subclass must,
                however, declare a table column holding the object identifier using the
                <tt class="literal">&lt;key&gt;</tt> element. The mapping at the start of the chapter
                would be re-written as:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                	&lt;key column="CAT"/&gt;
                        &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-collections"></a>5.1.15.&nbsp;map, set, list, bag</h3></div></div><div></div></div><p>
                Collections are discussed later.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-import"></a>5.1.16.&nbsp;import</h3></div></div><div></div></div><p>
                Suppose your application has two persistent classes with the same name, and you don't want to
                specify the fully qualified (package) name in Hibernate queries. Classes may be "imported" 
                explicitly, rather than relying upon <tt class="literal">auto-import="true"</tt>. You may even import 
                classes and interfaces that are not explicitly mapped.
            </p><pre class="programlisting">&lt;import class="java.lang.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="ClassName"              <span class="co">(1)</span>
        rename="ShortName"             <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt>: The fully qualified class name of of any Java class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">rename</tt> (optional - defaults to the unqualified class name):
                            A name that may be used in the query language.
                        </p></td></tr></table></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-types"></a>5.2.&nbsp;Hibernate Types</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-entitiesvalues"></a>5.2.1.&nbsp;Entities and values</h3></div></div><div></div></div><p>
                To understand the behaviour of various Java language-level objects with respect
                to the persistence service, we need to classify them into two groups:
            </p><p>
                An <span class="emphasis"><em>entity</em></span> exists independently of any other objects holding
                references to the entity. Contrast this with the usual Java model where an
                unreferenced object is garbage collected. Entities must be explicitly saved and
                deleted (except that saves and deletions may be <span class="emphasis"><em>cascaded</em></span>
                from a parent entity to its children). This is different from the ODMG model of
                object persistence by reachablity - and corresponds more closely to how
                application objects are usually used in large systems. Entities support
                circular and shared references. They may also be versioned.
            </p><p>
                An entity's persistent state consists of references to other entities and
                instances of <span class="emphasis"><em>value</em></span> types. Values are primitives,
                collections, components and certain immutable objects. Unlike entities, values
                (in particular collections and components) <span class="emphasis"><em>are</em></span>
                persisted and deleted by reachability. Since value objects (and primitives) are
                persisted and deleted along with their containing entity they may not be
                independently versioned. Values have no independent identity, so they cannot be
                shared by two entities or collections.
            </p><p>
                All Hibernate types except collections support null semantics.
            </p><p>
                Up until now, we've been using the term "persistent class" to refer to
                entities. We will continue to do that. Strictly speaking, however, not all
                user-defined classes with persistent state are entities. A
                <span class="emphasis"><em>component</em></span> is a user defined class with value semantics.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-basictypes"></a>5.2.2.&nbsp;Basic value types</h3></div></div><div></div></div><p>
                The <span class="emphasis"><em>basic types</em></span> may be roughly categorized into

                </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">integer, long, short, float, double, character, byte,
                            boolean, yes_no, true_false</tt></span></dt><dd><p>
                                Type mappings from Java primitives or wrapper classes to appropriate
                                (vendor-specific) SQL column types. <tt class="literal">boolean, yes_no</tt>
                                and <tt class="literal">true_false</tt> are all alternative encodings for
                                a Java <tt class="literal">boolean</tt> or <tt class="literal">java.lang.Boolean</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">string</tt></span></dt><dd><p>
                                A type mapping from <tt class="literal">java.lang.String</tt> to
                                <tt class="literal">VARCHAR</tt> (or Oracle <tt class="literal">VARCHAR2</tt>).
                            </p></dd><dt><span class="term"><tt class="literal">date, time, timestamp</tt></span></dt><dd><p>
                                Type mappings from <tt class="literal">java.util.Date</tt> and its subclasses 
                                to SQL types <tt class="literal">DATE</tt>, <tt class="literal">TIME</tt> and
                                <tt class="literal">TIMESTAMP</tt> (or equivalent).
                            </p></dd><dt><span class="term"><tt class="literal">calendar, calendar_date</tt></span></dt><dd><p>
                                Type mappings from <tt class="literal">java.util.Calendar</tt> to
                                SQL types <tt class="literal">TIMESTAMP</tt> and <tt class="literal">DATE</tt>
                                (or equivalent).
                            </p></dd><dt><span class="term"><tt class="literal">big_decimal</tt></span></dt><dd><p>
                                A type mapping from <tt class="literal">java.math.BigDecimal</tt> to
                                <tt class="literal">NUMERIC</tt> (or Oracle <tt class="literal">NUMBER</tt>).
                            </p></dd><dt><span class="term"><tt class="literal">locale, timezone, currency</tt></span></dt><dd><p>
                                Type mappings from <tt class="literal">java.util.Locale</tt>,
                                <tt class="literal">java.util.TimeZone</tt> and 
                                <tt class="literal">java.util.Currency</tt> 
                                to <tt class="literal">VARCHAR</tt> (or Oracle <tt class="literal">VARCHAR2</tt>).
                                Instances of <tt class="literal">Locale</tt> and <tt class="literal">Currency</tt> are 
                                mapped to their ISO codes. Instances of <tt class="literal">TimeZone</tt> are
                                mapped to their <tt class="literal">ID</tt>. 
                            </p></dd><dt><span class="term"><tt class="literal">class</tt></span></dt><dd><p>
                                A type mapping from <tt class="literal">java.lang.Class</tt> to
                                <tt class="literal">VARCHAR</tt> (or Oracle <tt class="literal">VARCHAR2</tt>).
                                A <tt class="literal">Class</tt> is mapped to its fully qualified name.
                            </p></dd><dt><span class="term"><tt class="literal">binary</tt></span></dt><dd><p>
                                Maps byte arrays to an appropriate SQL binary type.
                            </p></dd><dt><span class="term"><tt class="literal">text</tt></span></dt><dd><p>
                                Maps long Java strings to a SQL <tt class="literal">CLOB</tt> or 
                                <tt class="literal">TEXT</tt> type.
                            </p></dd><dt><span class="term"><tt class="literal">serializable</tt></span></dt><dd><p>
                                Maps serializable Java types to an appropriate SQL binary type. You
                                may also indicate the Hibernate type <tt class="literal">serializable</tt> with
                                the name of a serializable Java class or interface that does not default 
                                to a basic type or implement <tt class="literal">PersistentEnum</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">clob, blob</tt></span></dt><dd><p>
                                Type mappings for the JDBC classes <tt class="literal">java.sql.Clob</tt> and
                                <tt class="literal">java.sql.Blob</tt>. These types may be inconvenient for some
                                applications, since the blob or clob object may not be reused outside of
                                a transaction. (Furthermore, driver support is patchy and inconsistent.)
                            </p></dd></dl></div><p>
            
            </p><p>
                Unique identifiers of entities and collections may be of any basic type except
                <tt class="literal">binary</tt>, <tt class="literal">blob</tt> and <tt class="literal">clob</tt>. 
                (Composite identifiers are also allowed, see below.)
            </p><p>
                The basic value types have corresponding <tt class="literal">Type</tt> constants defined on
                <tt class="literal">net.sf.hibernate.Hibernate</tt>. For example, <tt class="literal">Hibernate.STRING</tt>
                represents the <tt class="literal">string</tt> type.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-enum"></a>5.2.3.&nbsp;Persistent enum types</h3></div></div><div></div></div><p>
                An <span class="emphasis"><em>enumerated</em></span> type is a common Java idiom where a class has
                a constant (small) number of immutable instances. You may create a persistent
                enumerated type by implementing <tt class="literal">net.sf.hibernate.PersistentEnum</tt>,
                defining the operations <tt class="literal">toInt()</tt> and <tt class="literal">fromInt()</tt>:
            </p><pre class="programlisting">package eg;
import net.sf.hibernate.PersistentEnum;

public class Color implements PersistentEnum {
    private final int code;
    private Color(int code) {
        this.code = code;
    }
    public static final Color TABBY = new Color(0);
    public static final Color GINGER = new Color(1);
    public static final Color BLACK = new Color(2);

    public int toInt() { return code; }

    public static Color fromInt(int code) {
        switch (code) {
            case 0: return TABBY;
            case 1: return GINGER;
            case 2: return BLACK;
            default: throw new RuntimeException("Unknown color code");
        }
    }
}</pre><p>
                The Hibernate type name is simply the name of the enumerated class, in this case
                <tt class="literal">eg.Color</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-custom"></a>5.2.4.&nbsp;Custom value types</h3></div></div><div></div></div><p>
                It is relatively easy for developers to create their own value types. For example,
                you might want to persist properties of type <tt class="literal">java.lang.BigInteger</tt>
                to <tt class="literal">VARCHAR</tt> columns. Hibernate does not provide a built-in type 
                for this. But custom types are not limited to mapping a property (or collection element) 
                to a single table column. So, for example, you might have a Java property 
                <tt class="literal">getName()</tt>/<tt class="literal">setName()</tt> of type
                <tt class="literal">java.lang.String</tt> that is persisted to the columns 
                <tt class="literal">FIRST_NAME</tt>, <tt class="literal">INITIAL</tt>, <tt class="literal">SURNAME</tt>. 
            </p><p>
                To implement a custom type, implement either <tt class="literal">net.sf.hibernate.UserType</tt> 
                or <tt class="literal">net.sf.hibernate.CompositeUserType</tt> and declare properties using the 
                fully qualified classname of the type. Check out 
                <tt class="literal">net.sf.hibernate.test.DoubleStringType</tt> to see the kind of things that 
                are possible.
            </p><pre class="programlisting">&lt;property name="twoStrings" type="net.sf.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p>
                Notice the use of <tt class="literal">&lt;column&gt;</tt> tags to map a property to multiple
                columns.
            </p><p>
                Even though Hibernate's rich range of built-in types and support for components means you
                will very rarely <span class="emphasis"><em>need</em></span> to use a custom type, it is nevertheless
                considered good form to use custom types for (non-entity) classes that occur frequently
                in your application. For example, a <tt class="literal">MonetoryAmount</tt> class is a good
                candidate for a <tt class="literal">CompositeUserType</tt>, even though it could easily be mapped 
                as a component. One motivation for this is abstraction. With a custom type, your mapping 
                documents would be future-proofed against possible changes in your way of representing 
                monetory values.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-anymapping"></a>5.2.5.&nbsp;Any type mappings</h3></div></div><div></div></div><p>
                There is one further type of property mapping. The <tt class="literal">&lt;any&gt;</tt> mapping element 
                defines a polymorphic association to classes from multiple tables. This type of mapping always
                requires more than one column. The first column holds the type of the associated entity. 
                The remaining columns hold the identifier. It is impossible to specify a foreign key constraint
                for this kind of association, so this is most certainly not meant as the usual way of mapping 
                (polymorphic) associations. You should use this only in very special cases (eg. audit logs,
                user session data, etc).
            </p><pre class="programlisting">&lt;any name="anyEntity" id-type="long" meta-type="eg.custom.Class2TablenameType"&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><p>
                 The <tt class="literal">meta-type</tt> attribute lets the application specify a custom type that 
                 maps database column values to persistent classes which have identifier properties of the 
                 type specified by <tt class="literal">id-type</tt>. If the meta-type returns instances of 
                 <tt class="literal">java.lang.Class</tt>, nothing else is required. On the other hand, if it is
                 a basic type like <tt class="literal">string</tt> or <tt class="literal">character</tt>, you must
                 specify the mapping from values to classes.
            </p><pre class="programlisting">&lt;any name="anyEntity" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="propertyName"                      <span class="co">(1)</span>
        id-type="idtypename"                     <span class="co">(2)</span>
        meta-type="metatypename"                 <span class="co">(3)</span>
        cascade="none|all|save-update"           <span class="co">(4)</span>
        access="field|property|ClassName"        <span class="co">(5)</span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: the property name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">id-type</tt>: the identifier type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">meta-type</tt> (optional - defaults to <tt class="literal">class</tt>): 
                            a type that maps <tt class="literal">java.lang.Class</tt> to a single database column
                            or, alternatively, a type that is allowed for a discriminator mapping.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional- defaults to <tt class="literal">none</tt>): 
                            the cascade style.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy Hibernate should use for accessing the property value.
                        </p></td></tr></table></div></div><p>
                The old <tt class="literal">object</tt> type that filled a similar role in Hibernate 1.2 is still 
                supported, but is now semi-deprecated.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-quotedidentifiers"></a>5.3.&nbsp;SQL quoted identifiers</h2></div></div><div></div></div><p>
                You may force Hibernate to quote an identifier in the generated SQL by enclosing the table or
                column name in backticks in the mapping document. Hibernate will use the correct quotation
                style for the SQL <tt class="literal">Dialect</tt> (usually double quotes, but brackets for SQL
                Server and backticks for MySQL).
            </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-modularfiles"></a>5.4.&nbsp;Modular mapping files</h2></div></div><div></div></div><p>
            It is possible to define <tt class="literal">subclass</tt> and <tt class="literal">joined-subclass</tt>
            mappings in seperate mapping documents, directly beneath <tt class="literal">hibernate-mapping</tt>.
            This allows you to extend a class hierachy just by adding a new mapping file. You must
            specify an <tt class="literal">extends</tt> attribute in the subclass mapping, naming a previously
            mapped superclass. Use of this feature makes the ordering of the mapping documents important!
        </p><pre class="programlisting">
&lt;hibernate-mapping&gt;
        &lt;subclass name="eg.subclass.DomesticCat" extends="eg.Cat" discriminator-value="D"&gt;
             &lt;property name="name" type="string"/&gt;
        &lt;/subclass&gt;
&lt;/hibernate-mapping&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="collections"></a>Chapter&nbsp;6.&nbsp;Collection Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-persistent"></a>6.1.&nbsp;Persistent Collections</h2></div></div><div></div></div><p>
            This section does not contain much example Java code. We assume you already know
            how to use Java's collections framework. If so, there's not really anything more
            to know - with a single caveat, you may use Java collections the same way you
            always have.
        </p><p>
            Hibernate can persist instances of
            <tt class="literal">java.util.Map</tt>,
            <tt class="literal">java.util.Set</tt>,
            <tt class="literal">java.util.SortedMap</tt>,
            <tt class="literal">java.util.SortedSet</tt>,
            <tt class="literal">java.util.List</tt>,
            and any array of persistent entities or values. Properties of type
            <tt class="literal">java.util.Collection</tt> or
            <tt class="literal">java.util.List</tt>
            may also be persisted with "bag" semantics.
        </p><p>
            Now the caveat: persistent collections do not retain any extra semantics added by the class
            implementing the collection interface (eg. iteration order of a <tt class="literal">LinkedHashSet</tt>).
            The persistent collections actually behave like
            <tt class="literal">HashMap</tt>,
            <tt class="literal">HashSet</tt>,
            <tt class="literal">TreeMap</tt>,
            <tt class="literal">TreeSet</tt> and
            <tt class="literal">ArrayList</tt>
            respectively. Furthermore, the Java type of a property holding a collection must be
            the interface type (ie. <tt class="literal">Map</tt>, <tt class="literal">Set</tt> or
            <tt class="literal">List</tt>; never <tt class="literal">HashMap</tt>, <tt class="literal">TreeSet</tt> or
            <tt class="literal">ArrayList</tt>). This restriction exists because, when you're not looking,
            Hibernate sneakily replaces your instances of <tt class="literal">Map</tt>, <tt class="literal">Set</tt>
            and <tt class="literal">List</tt> with instances of its own persistent implementations of
            <tt class="literal">Map</tt>, <tt class="literal">Set</tt> or <tt class="literal">List</tt>. (So also be careful
            when using <tt class="literal">==</tt> on your collections.)
        </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.save(cat);
kittens = cat.getKittens(); //Okay, kittens collection is a Set
(HashSet) cat.getKittens(); //Error!</pre><p>
            Collections obey the usual rules for value types: no shared
            references, created and deleted along with containing entity. Due to the underlying
            relational model, they do not support null value semantics; Hibernate does not
            distinguish between a null collection reference and an empty collection.
        </p><p>
            Collections are automatically persisted when referenced by a persistent object
            and automatically deleted when unreferenced. If a collection is passed from one
            persistent object to another, its elements might be moved from one table to
            another. You shouldn't have to worry much about any of this. Just use
            Hibernate's collections the same way you use ordinary Java collections, but
            make sure you understand the semantics of bidirectional associations (discussed
            later) before using them.
        </p><p>
            Collection instances are distinguished in the database by a foreign key to
            the owning entity. This foreign key is referred to as the
            <span class="emphasis"><em>collection key </em></span>. The collection key is mapped by
            the <tt class="literal">&lt;key&gt;</tt> element.
        </p><p>
            Collections may contain almost any other Hibernate type, including all basic types,
            custom types, entity types and components. This is an important definition: An object
            in a collection can either be handled with "pass by value" semantics (it therefore
            fully depends on the collection owner) or it can be a reference to another entity
            with an own lifecycle. Collections may not contain other collections. The contained type
            is referred to as the <span class="emphasis"><em>collection element type</em></span>. Collection elements
            are mapped by <tt class="literal">&lt;element&gt;</tt>, <tt class="literal">&lt;composite-element&gt;</tt>,
            <tt class="literal">&lt;one-to-many&gt;</tt>, <tt class="literal">&lt;many-to-many&gt;</tt> or
            <tt class="literal">&lt;many-to-any&gt;</tt>. The first two map elements with value semantics,
            the other three are used to map entity associations.
        </p><p>
            All collection types except <tt class="literal">Set</tt> and bag have an <span class="emphasis"><em>index
            </em></span> column - a column that maps to an array or <tt class="literal">List</tt> index or
            <tt class="literal">Map</tt> key. The index of a <tt class="literal">Map</tt> may be of any
            basic type, an entity type or even a composite type (it may not be a collection). The
            index of an array or list is always of type <tt class="literal">integer</tt>. Indexes are
            mapped using <tt class="literal">&lt;index&gt;</tt>, <tt class="literal">&lt;index-many-to-many&gt;</tt>,
            <tt class="literal">&lt;composite-index&gt;</tt> or <tt class="literal">&lt;index-many-to-any&gt;</tt>.
        </p><p>
            There are quite a range of mappings that can be generated for collections,
            covering many common relational models. We suggest you experiment with the
            schema generation tool to get a feeling for how various mapping declarations
            translate to database tables.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-mapping"></a>6.2.&nbsp;Mapping a Collection</h2></div></div><div></div></div><p>
            Collections are declared by the
            <tt class="literal">&lt;set&gt;</tt>,
            <tt class="literal">&lt;list&gt;</tt>,
            <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt>,
            <tt class="literal">&lt;array&gt;</tt> and
            <tt class="literal">&lt;primitive-array&gt;</tt> elements.
            <tt class="literal">&lt;map&gt;</tt> is representative:
        </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span class="co">(1)</span>
    table="table_name"                                          <span class="co">(2)</span>
    schema="schema_name"                                        <span class="co">(3)</span>
    lazy="true|false"                                           <span class="co">(4)</span>
    inverse="true|false"                                        <span class="co">(5)</span>
    cascade="all|none|save-update|delete|all-delete-orphan"     <span class="co">(6)</span>
    sort="unsorted|natural|comparatorClass"                     <span class="co">(7)</span>
    order-by="column_name asc|desc"                             <span class="co">(8)</span>
    where="arbitrary sql where condition"                       <span class="co">(9)</span>
    outer-join="true|false|auto"                                <span class="co">(10)</span>
    batch-size="N"                                              <span class="co">(11)</span>
    access="field|property|ClassName"                           <span class="co">(12)</span>
&gt;

    &lt;key .... /&gt;
    &lt;index .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">name</tt> the collection property name
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">table</tt> (optional - defaults to property name) the
                        name of the collection table (not used for one-to-many associations)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">schema</tt> (optional) the name of a table schema to
                        override the schema declared on the root element
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>)
                        enable lazy initialization (not used for arrays)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">inverse</tt> (optional - defaults to <tt class="literal">false</tt>)
                        mark this collection as the "inverse" end of a bidirectional association
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                        <tt class="literal">cascade</tt> (optional - defaults to <tt class="literal">none</tt>)
                        enable operations to cascade to child entities
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">sort</tt> (optional) specify a sorted collection with
                        <tt class="literal">natural</tt> sort order, or a given comparator class
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">order-by</tt> (optional, JDK1.4 only) specify a table column (or columns)
                        that define the iteration order of the <tt class="literal">Map</tt>, <tt class="literal">Set</tt>
                        or bag, together with an optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt>
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                        <tt class="literal">where</tt> (optional) specify an arbitrary SQL <tt class="literal">WHERE</tt>
                        condition to be used when retrieving or removing the collection (useful if the
                        collection should contain only a subset of the available data)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                        <tt class="literal">outer-join</tt> (optional) specify that the collection should be fetched
                        by outer join, whenever possible. Only one collection may be fetched by outer join per
                        SQL <tt class="literal">SELECT</tt>.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                        <tt class="literal">batch-size</tt> (optional, defaults to <tt class="literal">1</tt>) specify a
                        "batch size" for lazily fetching instances of this collection.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                        <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                        strategy Hibernate should use for accessing the property value.
                    </p></td></tr></table></div></div><p>
            The mapping of a <tt class="literal">List</tt> or array requires a seperate table column holding the array
            or list index (the <tt class="literal">i</tt> in <tt class="literal">foo[i]</tt>). If your relational model doesn't
            have an index column, e.g. if you're working with legacy data, use an unordered <tt class="literal">Set</tt>
            instead. This seems to put people off who assume that <tt class="literal">List</tt> should just be a more
            convenient way of accessing an unordered collection. Hibernate collections strictly obey the actual
            semantics attached to the <tt class="literal">Set</tt>, <tt class="literal">List</tt> and <tt class="literal">Map</tt>
            interfaces. <tt class="literal">List</tt> elements don't just spontaneously rearrange themselves!
        </p><p>
            On the other hand, people who planned to use the <tt class="literal">List</tt> to emulate
            <span class="emphasis"><em>bag</em></span> semantics have a legitimate grievance here.
            A bag is an unordered, unindexed collection which may contain the same element multiple times.
            The Java collections framework lacks a <tt class="literal">Bag</tt> interface, hence you have to emulate
            it with a <tt class="literal">List</tt>. Hibernate lets you map properties of type <tt class="literal">List</tt>
            or <tt class="literal">Collection</tt> with the <tt class="literal">&lt;bag&gt;</tt> element. Note that bag
            semantics are not really part of the <tt class="literal">Collection</tt> contract and they actually
            conflict with the semantics of the <tt class="literal">List</tt> contract (however, you can sort
            the bag arbitrarily, discussed later in this chapter).
        </p><p>
            Note: Large Hibernate bags mapped with <tt class="literal">inverse="false"</tt> are inefficient and
            should be  avoided; Hibernate can't create, delete or update rows individually, because there is
            no key that may be used to identify an individual row.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-ofvalues"></a>6.3.&nbsp;Collections of Values and Many-To-Many Associations</h2></div></div><div></div></div><p>
            A collection table is required for any collection of values and any collection of
            references to other entities mapped as a many-to-many association (the natural semantics
            for a Java collection). The table requires (foreign) key column(s), element column(s) and
            possibly index column(s).
        </p><p>
            The foreign key from the collection table to the table of the owning class is
            declared using a <tt class="literal">&lt;key&gt;</tt> element.
        </p><div class="programlistingco"><pre class="programlisting">&lt;key column="column_name"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the foreign key column.
                    </p></td></tr></table></div></div><p>
            For indexed collections like maps and lists, we require an <tt class="literal">&lt;index&gt;</tt>
            element. For lists, this column contains sequential integers numbered from zero. Make sure
            that your index really starts from zero if you have to deal with legacy data. For maps,
            the column may contain any values of any Hibernate type.
        </p><div class="programlistingco"><pre class="programlisting">&lt;index
        column="column_name"                <span class="co">(1)</span>
        type="typename"                     <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the column holding the
                        collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (optional, defaults to <tt class="literal">integer</tt>):
                        The type of the collection index.
                    </p></td></tr></table></div></div><p>
            Alternatively, a map may be indexed by objects of entity type. We use the
            <tt class="literal">&lt;index-many-to-many&gt;</tt> element.
        </p><div class="programlistingco"><pre class="programlisting">&lt;index-many-to-many
        column="column_name"                <span class="co">(1)</span>
        class="ClassName"                   <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the foreign key
                        column for the collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The entity class used as the
                        collection index.
                    </p></td></tr></table></div></div><p>
            For a collection of values, we use the <tt class="literal">&lt;element&gt;</tt> tag.
        </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="column_name"                <span class="co">(1)</span>
        type="typename"                     <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the column holding the
                        collection element values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (required): The type of the collection element.
                    </p></td></tr></table></div></div><p>
            A collection of entities with its own table corresponds to the relational notion
            of <span class="emphasis"><em>many-to-many association</em></span>. A many to many association is the
            most natural mapping of a Java collection but is not usually the best relational model.
        </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="column_name"                               <span class="co">(1)</span>
        class="ClassName"                                  <span class="co">(2)</span>
        outer-join="true|false|auto"                       <span class="co">(3)</span>
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the element foreign key column.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The name of the associated class.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">outer-join</tt> (optional - defaults to <tt class="literal">auto</tt>):
                        enables outer-join fetching for this association when
                        <tt class="literal">hibernate.use_outer_join</tt> is set.
                    </p></td></tr></table></div></div><p>
            Some examples, first, a set of strings:
        </p><pre class="programlisting">&lt;set name="names" table="NAMES"&gt;
    &lt;key column="GROUPID"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</pre><p>
            A bag containing integers (with an iteration order determined by the
            <tt class="literal">order-by</tt> attribute):
        </p><pre class="programlisting">&lt;bag name="sizes" table="SIZES" order-by="SIZE ASC"&gt;
    &lt;key column="OWNER"/&gt;
    &lt;element column="SIZE" type="integer"/&gt;
&lt;/bag&gt;</pre><p>
            An array of entities - in this case, a many to many association (note that
            the entities are lifecycle objects, <tt class="literal">cascade="all"</tt>):
        </p><pre class="programlisting">&lt;array name="foos" table="BAR_FOOS" cascade="all"&gt;
    &lt;key column="BAR_ID"/&gt;
    &lt;index column="I"/&gt;
    &lt;many-to-many column="FOO_ID" class="org.hibernate.Foo"/&gt;
&lt;/array&gt;</pre><p>
            A map from string indices to dates:
        </p><pre class="programlisting">&lt;map name="holidays" table="holidays" schema="dbo" order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            A list of components (discussed in the next chapter):
        </p><pre class="programlisting">&lt;list name="carComponents" table="car_components"&gt;
    &lt;key column="car_id"/&gt;
    &lt;index column="posn"/&gt;
    &lt;composite-element class="org.hibernate.car.CarComponent"&gt;
            &lt;property name="price" type="float"/&gt;
            &lt;property name="type" type="org.hibernate.car.ComponentType"/&gt;
            &lt;property name="serialNumber" column="serial_no" type="string"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-onetomany"></a>6.4.&nbsp;One-To-Many Associations</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>one to many association</em></span> links the tables of two classes
            <span class="emphasis"><em>directly</em></span>, with no intervening collection table.
            (This implements a <span class="emphasis"><em>one-to-many</em></span> relational model.) This
            relational model loses some of the semantics of Java collections:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    No null values may be contained in a map, set or list
                </p></li><li><p>
                    An instance of the contained entity class may not belong to more than
                    one instance of the collection
                </p></li><li><p>
                    An instance of the contained entity class may not appear at more than
                    one value of the collection index
                </p></li></ul></div><p>
            An association from <tt class="literal">Foo</tt> to <tt class="literal">Bar</tt> requires the
            addition of a key column and possibly an index column to the table of the contained
            entity class, <tt class="literal">Bar</tt>. These columns are mapped using the
            <tt class="literal">&lt;key&gt;</tt> and <tt class="literal">&lt;index&gt;</tt> elements
            described above.
        </p><p>
            The <tt class="literal">&lt;one-to-many&gt;</tt> tag indicates a one to many association.
        </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many class="ClassName"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The name of the associated class.
                    </p></td></tr></table></div></div><p>
            Example:
        </p><pre class="programlisting">&lt;set name="bars"&gt;
    &lt;key column="foo_id"/&gt;
    &lt;one-to-many class="org.hibernate.Bar"/&gt;
&lt;/set&gt;</pre><p>
            Notice that the <tt class="literal">&lt;one-to-many&gt;</tt> element does not need to
            declare any columns. Nor is it necessary to specify the <tt class="literal">table</tt>
            name anywhere.
        </p><p>
            <span class="emphasis"><em>Very Important Note:</em></span> If the <tt class="literal">&lt;key&gt;</tt>
            column of a <tt class="literal">&lt;one-to-many&gt;</tt> association is declared
            <tt class="literal">NOT NULL</tt>, Hibernate may cause constraint violations
            when it creates or updates the association. To prevent this problem,
            <span class="emphasis"><em>you must use a bidirectional association</em></span> with the many valued
            end (the set or bag) marked as <tt class="literal">inverse="true"</tt>.
            See the discussion of bidirectional associations later in this chapter.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-lazy"></a>6.5.&nbsp;Lazy Initialization</h2></div></div><div></div></div><p>
            Collections (other than arrays) may be lazily initialized, meaning they load
            their state from the database only when the application needs to access it.
            Initialization happens transparently to the user so the application would not
            normally need to worry about this (in fact, transparent lazy initialization is
            the main reason why Hibernate needs its own collection implementations).
            However, if the application tries something like this:
        </p><pre class="programlisting">s = sessions.openSession();
User u = (User) s.find("from User u where u.name=?", userName, Hibernate.STRING).get(0);
Map permissions = u.getPermissions();
s.connection().commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>
            It could be in for a nasty surprise. Since the permissions collection was not
            initialized when the <tt class="literal">Session</tt> was committed,
            the collection will never be able to load its state. The fix is to move the
            line that reads from the collection to just before the commit. (There are
            other more advanced ways to solve this problem, however.)
        </p><p>
            Alternatively, use a non-lazy collection. Since lazy initialization can lead to
            bugs like that above, non-laziness is the default. However, it is intended that
            lazy initialization be used for almost all collections, especially for
            collections of entities (for reasons of efficiency).
        </p><p>
            Exceptions that occur while lazily initializing a collection are wrapped in a
            <tt class="literal">LazyInitializationException</tt>.
        </p><p>
            Declare a lazy collection using the optional <tt class="literal">lazy</tt> attribute:
        </p><pre class="programlisting">&lt;set name="names" table="NAMES" lazy="true"&gt;
    &lt;key column="group_id"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</pre><p>
            In some application architectures, particularly where the code that accesses data
            using Hibernate, and the code that uses it are in different application layers, it
            can be a problem to ensure that the <tt class="literal">Session</tt> is open when a
            collection is initialized. They are two basic ways to deal with this issue:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    In a web-based application, a servlet filter can be used to close the
                    <tt class="literal">Session</tt> only at the very end of a user request, once
                    the rendering of the view is complete. Of course, this places heavy
                    demands upon the correctness of the exception handling of your application
                    infrastructure. It is vitally important that the <tt class="literal">Session</tt>
                    is closed and the transaction ended before returning to the user, even
                    when an exception occurs during rendering of the view. The servlet filter
                    has to be able to access the <tt class="literal">Session</tt> for this approach.
                    We recommend that a <tt class="literal">ThreadLocal</tt> variable be used to
                    hold the current <tt class="literal">Session</tt> (see chapter 1,
                    <a href="#quickstart-playingwithcats" title="1.4.&nbsp;Playing with cats">Section&nbsp;1.4, &#8220;Playing with cats&#8221;</a>, for an example implementation).
                </p></li><li><p>
                    In an application with a seperate business tier, the business logic must
                    "prepare" all collections that will be needed by the web tier before
                    returning. This means that the business tier should load all the data and
                    return all the data already initialized to the presentation/web tier that
                    is required for a particular use case. Usually, the application calls
                    <tt class="literal">Hibernate.initialize()</tt> for each collection that will
                    be needed in the web tier (this call must occur before the session is closed)
                    or retrieves the collection eagerly using a Hibernate query with a
                    <tt class="literal">FETCH</tt> clause.
                </p></li><li><p>
                    You may also attach a previously loaded object to a new <tt class="literal">Session</tt>
                    with <tt class="literal">update()</tt> or <tt class="literal">lock()</tt> before
                    accessing unitialized collections (or other proxies). Hibernate can not
                    do this automatically, as it would introduce ad hoc transaction semantics!
                </p></li></ul></div><p>
            You can use the <tt class="literal">filter()</tt> method of the Hibernate Session API to
            get the size of a collection without initializing it:
        </p><pre class="programlisting">( (Integer) s.filter( collection, "select count(*)" ).get(0) ).intValue()</pre><p>
            <tt class="literal">filter()</tt> or <tt class="literal">createFilter()</tt> are also used to
            efficiently retrieve subsets of a collection without needing to initialize the whole
            collection.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-sorted"></a>6.6.&nbsp;Sorted Collections</h2></div></div><div></div></div><p>
            Hibernate supports collections implementing <tt class="literal">java.util.SortedMap</tt> and
            <tt class="literal">java.util.SortedSet</tt>. You must specify a comparator in the mapping file:
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>
            Allowed values of the <tt class="literal">sort</tt> attribute are <tt class="literal">unsorted</tt>,
            <tt class="literal">natural</tt> and the name of a class implementing
            <tt class="literal">java.util.Comparator</tt>.
        </p><p>
            Sorted collections actually behave like <tt class="literal">java.util.TreeSet</tt> or
            <tt class="literal">java.util.TreeMap</tt>.
        </p><p>
            If you want the database itself to order the collection elements use the
            <tt class="literal">order-by</tt> attribute of <tt class="literal">set</tt>, <tt class="literal">bag</tt>
            or <tt class="literal">map</tt> mappings. This solution is only available under
            JDK 1.4 or higher (it is implemented using <tt class="literal">LinkedHashSet</tt> or
            <tt class="literal">LinkedHashMap</tt>). This performs the ordering in the SQL query, not in
            memory.
        </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="name asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><p>
            Note that the value of the <tt class="literal">order-by</tt> attribute is an SQL ordering, not
            a HQL ordering!
        </p><p>
            Associations may even be sorted by some arbitrary criteria at runtime using a
            <tt class="literal">filter()</tt>.
        </p><pre class="programlisting">sortedUsers = s.filter( group.getUsers(), "order by this.name" );</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-idbag"></a>6.7.&nbsp;<tt class="literal">Using an &lt;idbag&gt;</tt></h2></div></div><div></div></div><p>
            If you've fully embraced our view that composite keys are a bad thing and that
            entities should have synthetic identifiers (surrogate keys), then you might
            find it a bit odd that the many to many associations and collections of values
            that we've shown so far all map to tables with composite keys! Now, this point
            is quite arguable; a pure association table doesn't seem to benefit much from
            a surrogate key (though a collection of composite values <span class="emphasis"><em>might</em></span>).
            Nevertheless, Hibernate provides a (slightly experimental) feature that allows
            you to map many to many associations and collections of values to a table with
            a surrogate key.
        </p><p>
            The <tt class="literal">&lt;idbag&gt;</tt> element lets you map a <tt class="literal">List</tt>
            (or <tt class="literal">Collection</tt>) with bag semantics.
        </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS" lazy="true"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="eg.Person" outer-join="true"/&gt;
&lt;/idbag&gt;</pre><p>
            As you can see, an <tt class="literal">&lt;idbag&gt;</tt> has a synthetic id generator,
            just like an entity class! A different surrogate key is assigned to each collection
            row. Hibernate does not provide any mechanism to discover the surrogate key value
            of a particular row, however.
        </p><p>
            Note that the update performance of an <tt class="literal">&lt;idbag&gt;</tt> is
            <span class="emphasis"><em>much</em></span> better than a regular <tt class="literal">&lt;bag&gt;</tt>!
            Hibernate can locate individual rows efficiently and update or delete them
            individually, just like a list, map or set.
        </p><p>
            In the current implementation, the <tt class="literal">identity</tt> identifier generation
            strategy is not supported for <tt class="literal">&lt;idbag&gt;</tt> collection identifiers.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-bidirectional"></a>6.8.&nbsp;Bidirectional Associations</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional association</em></span> allows navigation from both
            "ends" of the association. Two kinds of bidirectional association are
            supported:

            </p><div class="variablelist"><dl><dt><span class="term">one-to-many</span></dt><dd><p>
                            set or bag valued at one end, single-valued at the other
                        </p></dd><dt><span class="term">many-to-many</span></dt><dd><p>
                            set or bag valued at both ends
                        </p></dd></dl></div><p>

        </p><p>
            Please note that Hibernate does not support bidirectional one-to-many associations
            with an indexed collection (list, map or array) as the "many" end, you have to
            use a set or bag mapping.
        </p><p>
            You may specify a bidirectional many-to-many association simply by mapping two
            many-to-many associations to the same database table and declaring one end as
            <span class="emphasis"><em>inverse</em></span> (which one is your choice). Here's an example of
            a bidirectional many-to-many association from a class back to <span class="emphasis"><em>itself</em></span>
            (each category can have many items and each item can be in many categories):
        </p><pre class="programlisting">&lt;class name="org.hibernate.auction.Category"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM" lazy="true"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="org.hibernate.auction.Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="org.hibernate.auction.Item"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true" lazy="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="org.hibernate.auction.Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>
            Changes made only to the inverse end of the association are <span class="emphasis"><em>not</em></span>
            persisted. This means that Hibernate has two representations in memory for every
            bidirectional association, one link from A to B and another link from B to A. This
            is easier to understand if you think about the Java object model and how we create
            a many-to-many relationship in Java:
        </p><pre class="programlisting">
category.getItems().add(item);          // The category now "knows" about the relationship
item.getCategories().add(category);     // The item now "knows" about the relationship

session.update(item);                     // No effect, nothing will be saved!
session.update(category);                 // The relationship will be saved</pre><p>
            The non-inverse side is used to save the in-memory representation to the database.
            We would get an unneccessary INSERT/UPDATE and probably even a foreign key violation
            if both would trigger changes! The same is of course also true for bidirectional
            one-to-many associations.
        </p><p>
            You may map a bidirectional one-to-many association by mapping a one-to-many association
            to the same table column(s) as a many-to-one association and declaring the many-valued
            end <tt class="literal">inverse="true"</tt>.
        </p><pre class="programlisting">&lt;class name="eg.Parent"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;set name="children" inverse="true" lazy="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="eg.Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="eg.Child"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;many-to-one name="parent" class="eg.Parent" column="parent_id"/&gt;
&lt;/class&gt;</pre><p>
            Mapping one end of an association with <tt class="literal">inverse="true"</tt> doesn't
            affect the operation of cascades, both are different concepts!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-ternary"></a>6.9.&nbsp;Ternary Associations</h2></div></div><div></div></div><p>
            There are two possible approaches to mapping a ternary association. One approach is to use
            composite elements (discussed below). Another is to use a <tt class="literal">Map</tt> with an
            association as its index:
        </p><pre class="programlisting">&lt;map name="contracts" lazy="true"&gt;
    &lt;key column="employer_id"/&gt;
    &lt;index-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many column="contract_id" class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="connections" lazy="true"&gt;
    &lt;key column="node1_id"/&gt;
    &lt;index-many-to-many column="node2_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-heterogeneous"></a>6.10.&nbsp;Heterogeneous Associations</h2></div></div><div></div></div><p>
	        The <tt class="literal">&lt;many-to-any&gt;</tt> and <tt class="literal">&lt;index-many-to-any&gt;</tt>
	        elements provide for true heterogeneous associations. These mapping elements work in the
	        same way as the <tt class="literal">&lt;any&gt;</tt> element - and should also be used
	        rarely, if ever.
	    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-example"></a>6.11.&nbsp;Collection examples</h2></div></div><div></div></div><p>
            The previous sections are pretty confusing. So lets look at an example. This
            class:
        </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>
            has a collection of <tt class="literal">eg.Child</tt> instances. If each
            child has at most one parent, the most natural mapping is a one-to-many
            association:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="eg.Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            This maps to the following table definitions:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            If the parent is <span class="emphasis"><em>required</em></span>, use a bidirectional one-to-many
            association:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="eg.Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="eg.Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Notice the <tt class="literal">NOT NULL</tt> constraint:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            On the other hand, if a child might have multiple parents, a many-to-many
            association is appropriate:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" lazy="true" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="eg.Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Table definitions:
        </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="components"></a>Chapter&nbsp;7.&nbsp;Component Mapping</h2></div></div><div></div></div><p>
        The notion of a <span class="emphasis"><em>component</em></span> is re-used in several different contexts,
        for different purposes, throughout Hibernate.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dependentobjects"></a>7.1.&nbsp;Dependent objects</h2></div></div><div></div></div><p>
            A component is a contained object that is persisted as a value type, not an entity.
            The term "component" refers to the object-oriented notion of composition
            (not to architecture-level components). For example, you might model a person like this:
        </p><pre class="programlisting">public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</pre><p>
            Now <tt class="literal">Name</tt> may be persisted as a component of
            <tt class="literal">Person</tt>. Notice that <tt class="literal">Name</tt> defines getter
            and setter methods for its persistent properties, but doesn't need to declare
            any interfaces or identifier properties.
        </p><p>
            Our Hibernate mapping would look like:
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>
            The person table would have the columns <tt class="literal">pid</tt>,
            <tt class="literal">birthday</tt>,
            <tt class="literal">initial</tt>,
            <tt class="literal">first</tt> and
            <tt class="literal">last</tt>.
        </p><p>
            Like all value types, components do not support shared references. The null
            value semantics of a component are <span class="emphasis"><em>ad hoc</em></span>. When reloading the
            containing object, Hibernate will assume that if all component columns are
            null, then the entire component is null. This should be okay for most purposes.
        </p><p>
            The properties of a component may be of any Hibernate type (collections, many-to-one 
            associations, other components, etc). Nested components should <span class="emphasis"><em>not</em></span> 
            be considered an exotic usage. Hibernate is intended to support a very fine-grained 
            object model.
        </p><p>
            The <tt class="literal">&lt;component&gt;</tt> element allows a <tt class="literal">&lt;parent&gt;</tt>
            subelement that maps a property of the component class as a reference back to the
            containing entity.
        </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- reference back to the Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-incollections"></a>7.2.&nbsp;Collections of dependent objects</h2></div></div><div></div></div><p>
            Collections of components are supported (eg. an array of type
            <tt class="literal">Name</tt>). Declare your component collection by
            replacing the <tt class="literal">&lt;element&gt;</tt> tag with a
            <tt class="literal">&lt;composite-element&gt;</tt> tag.
        </p><pre class="programlisting">&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><p>
            Note: if you define a <tt class="literal">Set</tt> of composite elements, it is 
            very important to implement <tt class="literal">equals()</tt> and 
            <tt class="literal">hashCode()</tt> correctly.
        </p><p>
            Composite elements may contain components but not collections. If your
            composite element itself contains 
            components, use the <tt class="literal">&lt;nested-composite-element&gt;</tt> 
            tag. This is a pretty exotic case - a collection of components which 
            themselves have components. By this stage you should be asking yourself 
            if a one-to-many association is more appropriate. Try remodelling the 
            composite element as an entity - but note that even though the Java model 
            is the same, the relational model and persistence semantics are still 
            slightly different.
        </p><p>
            Please note that a composite element mapping doesn't support null-able properties
            if you're using a <tt class="literal">&lt;set&gt;</tt>. Hibernate
            has to use each columns value to identify a record when deleting objects
            (there is no separate primary key column in the composite element table),
            which is not possible with null values. You have to either use only
            not-null properties in a composite-element or choose a
            <tt class="literal">&lt;list&gt;</tt>, <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt> or <tt class="literal">&lt;idbag&gt;</tt>.
        </p><p>
            A special case of a composite element is a composite element with a nested
            <tt class="literal">&lt;many-to-one&gt;</tt> element. A mapping like this allows
            you to map extra columns of a many-to-many association table to the
            composite element class. The following is a many-to-many association
            from <tt class="literal">Order</tt> to <tt class="literal">Item</tt> where 
            <tt class="literal">purchaseDate</tt>, <tt class="literal">price</tt> and
            <tt class="literal">quantity</tt> are properties of the association:
        </p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>Even ternary (or quaternary, etc) associations are possible:</p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Composite elements may appear in queries using the same syntax as
            associations to other entities.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-asmapindex"></a>7.3.&nbsp;Components as Map indices</h2></div></div><div></div></div><p>
            The <tt class="literal">&lt;composite-index&gt;</tt> element lets you map a
            component class as the key of a <tt class="literal">Map</tt>. Make sure you override
            <tt class="literal">hashCode()</tt> and <tt class="literal">equals()</tt> correctly on
            the component class.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-compositeid"></a>7.4.&nbsp;Components as composite identifiers</h2></div></div><div></div></div><p>
            You may use a component as an identifier of an entity class. Your component
            class must satisfy certain requirements:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    It must implement <tt class="literal">java.io.Serializable</tt>.
                </p></li><li><p>
                    It must re-implement <tt class="literal">equals()</tt> and
                    <tt class="literal">hashCode()</tt>, consistently with the database's 
                    notion of composite key equality.
                </p></li></ul></div><p>
            You can't use an <tt class="literal">IdentifierGenerator</tt> to generate composite keys.
            Instead the application must assign its own identifiers.
        </p><p>
            Since a composite identifier must be assigned to the object before saving it,
            we can't use <tt class="literal">unsaved-value</tt> of the identifier to distinguish
            between newly instantiated instances and instances saved in a previous session.
        </p><p>
            You may instead implement <tt class="literal">Interceptor.isUnsaved()</tt> if
            you wish to use <tt class="literal">saveOrUpdate()</tt> or cascading save / update.
            As an alternative, you may also set the <tt class="literal">unsaved-value</tt>
            attribute on a <tt class="literal">&lt;version&gt;</tt> (or
            <tt class="literal">&lt;timestamp&gt;</tt>) element to specify a
            value that indicates a new transient instance. In this case, the version
            of the entity is used instead of the (assigned) identifier and you don't have
            to implement <tt class="literal">Interceptor.isUnsaved()</tt> yourself.
        </p><p>
            Use the <tt class="literal">&lt;composite-id&gt;</tt> tag (same attributes and
            elements as <tt class="literal">&lt;component&gt;</tt>) in place of
            <tt class="literal">&lt;id&gt;</tt> for the declaration of a composite identifier
            class:
        </p><pre class="programlisting">&lt;class name="eg.Foo" table"FOOS"&gt;
    &lt;composite-id name="compId" class="eg.FooCompositeID"&gt;
        &lt;key-property name="string"/&gt;
        &lt;key-property name="short"/&gt;
        &lt;key-property name="date" column="date_" type="date"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="name"/&gt;
    ....
&lt;/class&gt;</pre><p>
            Now, any foreign keys into the table <tt class="literal">FOOS</tt> are also composite.
            You must declare this in your mappings for other classes. An association to
            <tt class="literal">Foo</tt> would be declared like this:
        </p><pre class="programlisting">&lt;many-to-one name="foo" class="eg.Foo"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="foo_string"/&gt;
    &lt;column name="foo_short"/&gt;
    &lt;column name="foo_date"/&gt;
&lt;/many-to-one&gt;</pre><p>
        This new <tt class="literal">&lt;column&gt;</tt> tag is also used by multi-column custom types.
        Actually it is an alternative to the <tt class="literal">column</tt> attribute everywhere. A
        collection with elements of type <tt class="literal">Foo</tt> would use:
    </p><pre class="programlisting">&lt;set name="foos"&gt;
    &lt;key column="owner_id"/&gt;
    &lt;many-to-many class="eg.Foo"&gt;
        &lt;column name="foo_string"/&gt;
        &lt;column name="foo_short"/&gt;
        &lt;column name="foo_date"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p>
            On the other hand, <tt class="literal">&lt;one-to-many&gt;</tt>, as usual, declares no columns.
        </p><p>
            If <tt class="literal">Foo</tt> itself contains collections, they will also need a
            composite foreign key.
        </p><pre class="programlisting">&lt;class name="eg.Foo"&gt;
    ....
    ....
    &lt;set name="dates" lazy="true"&gt;
        &lt;key&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="foo_string"/&gt;
            &lt;column name="foo_short"/&gt;
            &lt;column name="foo_date"/&gt;
        &lt;/key&gt;
        &lt;element column="foo_date" type="date"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dynamic"></a>7.5.&nbsp;Dynamic components</h2></div></div><div></div></div><p>
            You may even map a property of type <tt class="literal">Map</tt>:
        </p><pre class="programlisting">&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO"/&gt;
    &lt;property name="bar" column="BAR"/&gt;
    &lt;many-to-one name="baz" class="eg.Baz" column="BAZ"/&gt;
&lt;/dynamic-component&gt;</pre><p>
            The semantics of a <tt class="literal">&lt;dynamic-component&gt;</tt> mapping are identical
            to <tt class="literal">&lt;component&gt;</tt>. The advantage of this kind of mapping is 
            the ability to determine the actual properties of the bean at deployment time, just
            by editing the mapping document. (Runtime manipulation of the mapping document is 
            also possible, using a DOM parser.)
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="inheritance"></a>Chapter&nbsp;8.&nbsp;Inheritance Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-strategies"></a>8.1.&nbsp;The Three Strategies</h2></div></div><div></div></div><p>
            Hibernate supports the three basic inheritance mapping strategies.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            table per class hierarchy
        </p></li><li><p>
            table per subclass
        </p></li><li><p>
            table per concrete class (some limitations)
        </p></li></ul></div><p>
            It is even possible to use different mapping strategies for different
            branches of the same inheritance hierarchy, but the same limitations
            apply as apply to table-per-concrete class mappings. Hibernate does
            not support mixing <tt class="literal">&lt;subclass&gt;</tt> mappings and
            <tt class="literal">&lt;joined-subclass&gt;</tt> mappings inside the same
            <tt class="literal">&lt;class&gt;</tt> element.
        </p><p>
            Suppose we have an interface <tt class="literal">Payment</tt>, with implementors
            <tt class="literal">CreditCardPayment</tt>, <tt class="literal">CashPayment</tt>,
            <tt class="literal">ChequePayment</tt>. The table-per-hierarchy mapping would
            look like:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Exactly one table is required. There is one big limitation of this
            mapping strategy: columns declared by the subclasses may not have
            <tt class="literal">NOT NULL</tt> constraints.
        </p><p>
            A table-per-subclass mapping would look like:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Four tables are required. The three subclass tables have primary
            key associations to the superclass table (so the relational model
            is actually a one-to-one association).
        </p><p>
            Note that Hibernate's implementation of table-per-subclass requires
            no discriminator column. Other object/relational mappers use a
            different implementation of table-per-subclass which requires a type
            discriminator column in the superclass table. The approach taken by
            Hibernate is much more difficult to implement but arguably more
            correct from a relational point of view.
        </p><p>
            For either of these two mapping strategies, a polymorphic
            association to <tt class="literal">Payment</tt> is mapped using
            <tt class="literal">&lt;many-to-one&gt;</tt>.
        </p><pre class="programlisting">&lt;many-to-one name="payment"
    column="PAYMENT"
    class="Payment"/&gt;</pre><p>The table-per-concrete-class strategy is very different.</p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>
            Three tables were required. Notice that nowhere do we
            mention the <tt class="literal">Payment</tt> interface explicitly.
            Instead, we make use of Hibernate's <span class="emphasis"><em>implicit
            polymorphism</em></span>. Also notice that properties of
            <tt class="literal">Payment</tt> are mapped in each of the
            subclasses.
        </p><p>
            In this case, a polymorphic association to <tt class="literal">Payment</tt>
            is mapped using <tt class="literal">&lt;any&gt;</tt>.
        </p><pre class="programlisting">&lt;any name="payment"
        meta-type="class"
        id-type="long"&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre><p>
            It would be better if we defined a <tt class="literal">UserType</tt>
            as the <tt class="literal">meta-type</tt>, to handle the mapping from
            type discriminator strings to <tt class="literal">Payment</tt> subclass.
        </p><pre class="programlisting">&lt;any name="payment"
        meta-type="PaymentMetaType"
        id-type="long"&gt;
    &lt;column name="PAYMENT_TYPE"/&gt; &lt;!-- CREDIT, CASH or CHEQUE --&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre><p>
            There is one further thing to notice about this mapping.
            Since the subclasses are each mapped in their own
            <tt class="literal">&lt;class&gt;</tt> element (and since
            <tt class="literal">Payment</tt> is just an interface), each of
            the subclasses could easily be part of another table-per-class
            or table-per-subclass inheritance hierarchy! (And you can
            still use polymorphic queries against the
            <tt class="literal">Payment</tt> interface.)
       </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Once again, we don't mention <tt class="literal">Payment</tt> explicitly. If we
            execute a query against the <tt class="literal">Payment</tt> interface - for
            example, <tt class="literal">from Payment</tt> - Hibernate
            automatically returns instances of <tt class="literal">CreditCardPayment</tt>
            (and its subclasses, since they also implement <tt class="literal">Payment</tt>),
            <tt class="literal">CashPayment</tt> and <tt class="literal">ChequePayment</tt> but
            not instances of <tt class="literal">NonelectronicTransaction</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-limitations"></a>8.2.&nbsp;Limitations</h2></div></div><div></div></div><p>
            Hibernate assumes that an association maps to exactly one foreign key column.
            Multiple associations per foreign key are tolerated (you might need to specify
            <tt class="literal">inverse="true"</tt> or <tt class="literal">insert="false" update="false"</tt>),
            but there is no way to map any association to multiple foreign keys. This means that:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            when an association is modified, it is always the same foreign key that is
            updated
        </p></li><li><p>
            when an association is fetched lazily, a single database query is used
        </p></li><li><p>
            when an association is fetched eagerly, it may be fetched using a single
            outer join
        </p></li></ul></div><p>
            In particular, it implies that polymorphic one-to-many associations to
            classes mapped using the table-per-concrete-class strategy are
            <span class="emphasis"><em>not supported</em></span>. (Fetching this association would
            require multiple queries or multiple joins.)
        </p><p>
            The following table shows the limitations of table-per-concrete-class
            mappings, and of implicit polymorphism, in Hibernate.
        </p><div class="table"><a name="d0e5795"></a><p class="title"><b>Table&nbsp;8.1.&nbsp;Features of inheritance mappings</b></p><table summary="Features of inheritance mappings" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Inheritance strategy</th><th align="left">Polymorphic many-to-one</th><th align="left">Polymorphic one-to-one</th><th align="left">Polymorphic one-to-many</th><th align="left">Polymorphic many-to-many</th><th align="left">Polymorphic <tt class="literal">load()/get()</tt></th><th align="left">Polymorphic queries</th><th align="left">Polymorphic joins</th><th align="left">Outer join fetching</th></tr></thead><tbody><tr><td align="left">table-per-class-hierarchy</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table-per-subclass</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.get(Payment.class, id)</tt></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><tt class="literal">from Order o join o.payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table-per-concrete-class (implicit polymorphism)</td><td align="left"><tt class="literal">&lt;any&gt;</tt></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><tt class="literal">&lt;many-to-any&gt;</tt></td><td align="left"><span class="emphasis"><em>use a query</em></span></td><td align="left"><tt class="literal">from Payment p</tt></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="manipulatingdata"></a>Chapter&nbsp;9.&nbsp;Manipulating Persistent Data</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-creating"></a>9.1.&nbsp;Creating a persistent object</h2></div></div><div></div></div><p>
            An object (entity instance) is either <span class="emphasis"><em>transient</em></span> or
            <span class="emphasis"><em>persistent</em></span> with respect to a particular
            <tt class="literal">Session</tt>. Newly instantiated objects are, of course, transient. 
            The session offers services for saving (ie. persisting) transient instances:
        </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>
            The single-argument <tt class="literal">save()</tt> generates and assigns a unique
            identifier to <tt class="literal">fritz</tt>. The two-argument form attempts to persist
            <tt class="literal">pk</tt> using the given identifier. We generally discourage the use of 
            the two-argument form since it may be used to create primary keys with business meaning.
            It is most useful in certain special situations like using Hibernate to persist a BMP 
            entity bean.
        </p><p>
            Associated objects may be made persistent in any order you like unless you 
            have a <tt class="literal">NOT NULL</tt> constraint upon a foreign key column.
            There is never a risk of violating foreign key constraints. However, you 
            might violate a <tt class="literal">NOT NULL</tt> constraint if you
            <tt class="literal">save()</tt> the objects in the wrong order.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-loading"></a>9.2.&nbsp;Loading an object</h2></div></div><div></div></div><p>
            The <tt class="literal">load()</tt> methods of <tt class="literal">Session</tt> give you 
            a way to retrieve a persistent instance if you already know its identifier. 
            One version takes a class object and will load the state into a newly instantiated 
            object. The second version allows you to supply an instance into which the state 
            will be loaded. The form which takes an instance is particularly useful if you plan 
            to use Hibernate with BMP entity beans and is provided for exactly that purpose.
            You may discover other uses. (DIY instance pooling etc.)
        </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// you need to wrap primitive identifiers
long pkId = 1234;
DomesticCat pk = (DomesticCat) sess.load( Cat.class, new Long(pkId) );</pre><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>
            Note that <tt class="literal">load()</tt> will throw an unrecoverable exception if there is no matching 
            database row. If the class is mapped with a proxy, <tt class="literal">load()</tt> returns an object
            that is an uninitialized proxy and does not actually hit the database until you invoke a method of 
            the object. This behaviour is very useful if you wish to create an association to an object
            without actually loading it from the database.
        </p><p>
            If you are not certain that a matching row exists, you should use the <tt class="literal">get()</tt>
            method, which hits the database immediately and returns null if there is no matching row.
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>
            You may also load an objects using an SQL <tt class="literal">SELECT ... FOR UPDATE</tt>. See the next
            section for a discussion of Hibernate <tt class="literal">LockMode</tt>s.
        </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>
            Note that any associated instances or contained collections are <span class="emphasis"><em>not</em></span> selected 
            <tt class="literal">FOR UPDATE</tt>.
        </p><p>
            It is possible to re-load an object and all its collections at any time, using the 
            <tt class="literal">refresh()</tt> method. This is useful when database triggers are used to
            initialize some of the properties of the object.
        </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-querying"></a>9.3.&nbsp;Querying</h2></div></div><div></div></div><p>
            If you don't know the identifier(s) of the object(s) you are looking for, use the <tt class="literal">find()
            </tt> methods of <tt class="literal">Session</tt>. Hibernate supports a simple but powerful object 
            oriented query language.
        </p><pre class="programlisting">List cats = sess.find(
    "from Cat as cat where cat.birthdate = ?",
    date,
    Hibernate.DATE
);

List mates = sess.find(
    "select mate from Cat as cat join cat.mate as mate " +
    "where cat.name = ?",
    name,
    Hibernate.STRING
);

List cats = sess.find( "from Cat as cat where cat.mate.bithdate is null" );

List moreCats = sess.find(
    "from Cat as cat where " + 
    "cat.name = 'Fritz' or cat.id = ? or cat.id = ?",
    new Object[] { id1, id2 },
    new Type[] { Hibernate.LONG, Hibernate.LONG }
);

List mates = sess.find(
    "from Cat as cat where cat.mate = ?",
    izi,
    Hibernate.entity(Cat.class)
);

List problems = sess.find(
    "from GoldFish as fish " +
    "where fish.birthday &gt; fish.deceased or fish.birthday is null"
);</pre><p>
            The second argument to <tt class="literal">find()</tt> accepts an object
            or array of objects. The third argument accepts a Hibernate type or array of
            Hibernate types. These given types are used to bind the given objects to the
            <tt class="literal">?</tt> query placeholders (which map to IN
            parameters of a JDBC <tt class="literal">PreparedStatement</tt>). Just
            as in JDBC, you should use this binding mechanism in preference to string
            manipulation.
        </p><p>
            The <tt class="literal">Hibernate</tt> class defines a number of static methods
            and constants, providing access to most of the built-in types, as instances
            of <tt class="literal">net.sf.hibernate.type.Type</tt>.
        </p><p>
            If you expect your query to return a very large number of objects, but you 
            don't expect to use them all, you might get better performance from the
            <tt class="literal">iterate()</tt> methods, which return a
            <tt class="literal">java.util.Iterator</tt>. The iterator will load objects on 
            demand, using the identifiers returned by an initial SQL query (n+1 selects
            total).
        </p><pre class="programlisting">// fetch ids
Iterator iter = sess.iterate("from eg.Qux q order by q.likeliness"); 
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</pre><p>
            Unfortunately <tt class="literal">java.util.Iterator</tt> does not
            declare any exceptions, so any SQL or Hibernate exceptions that occur 
            are wrapped in a <tt class="literal">LazyInitializationException</tt> (a
            subclass of <tt class="literal">RuntimeException</tt>).
        </p><p>
            The <tt class="literal">iterate()</tt> method also performs better if
            you expect that many of the objects are already loaded and cached by 
            the session, or if the query results contain the same objects many
            times. (When no data is cached or repeated, <tt class="literal">find()</tt> 
            is almost always faster.) Heres an example of a query that should be
            called using <tt class="literal">iterate()</tt>:
        </p><pre class="programlisting">
Iterator iter = sess.iterate(
    "select customer, product " + 
    "from Customer customer, " +
    "Product product " +
    "join customer.purchases purchase " +
    "where product = purchase.product"
);</pre><p>
            Calling the previous query using <tt class="literal">find()</tt> would return a very
            large JDBC <tt class="literal">ResultSet</tt> containing the same data many times.
        </p><p>
            Hibernate queries sometimes return tuples of objects, in which case each tuple
            is returned as an array:
        </p><pre class="programlisting">Iterator foosAndBars = sess.iterate(
    "select foo, bar from Foo foo, Bar bar " +
    "where bar.date = foo.date"
);
while ( foosAndBars.hasNext() ) {
    Object[] tuple = (Object[]) foosAndBars.next();
    Foo foo = tuple[0]; Bar bar = tuple[1];
    ....
}</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-scalarqueries"></a>9.3.1.&nbsp;Scalar queries</h3></div></div><div></div></div><p>
                Queries may specify a property of a class in the <tt class="literal">select</tt> clause.
                They may even call SQL aggregate functions. Properties or aggregates are considered
                "scalar" results.
            </p><pre class="programlisting">Iterator results = sess.iterate(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color"
);
while ( results.hasNext() ) {
    Object[] row = results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre><pre class="programlisting">Iterator iter = sess.iterate(
    "select cat.type, cat.birthdate, cat.name from DomesticCat cat"
);</pre><pre class="programlisting">List list = sess.find(
    "select cat, cat.mate.name from DomesticCat cat"
);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-queryinterface"></a>9.3.2.&nbsp;The Query interface</h3></div></div><div></div></div><p>
                If you need to specify bounds upon your result set (the maximum number of rows
                you want to retrieve and / or the first row you want to retrieve) you should
                obtain an instance of <tt class="literal">net.sf.hibernate.Query</tt>:
            </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>
                You may even define a named query in the mapping document. (Remember to use a
                <tt class="literal">CDATA</tt> section if your query contains characters that could
                be interpreted as markup.)
            </p><pre class="programlisting">&lt;query name="eg.DomesticCat.by.name.and.minimum.weight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><pre class="programlisting">Query q = sess.getNamedQuery("eg.DomesticCat.by.name.and.minimum.weight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>
                The query interface supports the use of named parameters. Named parameters
                are identifiers of the form <tt class="literal">:name</tt> in the query string.
                There are methods on <tt class="literal">Query</tt> for binding values to named
                parameters or JDBC-style <tt class="literal">?</tt> parameters. <span class="emphasis"><em>
                Contrary to JDBC, Hibernate numbers parameters from zero.</em></span> The
                advantages of named parameters are:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        named parameters are insensitive to the order they occur in the
                        query string
                    </p></li><li><p>
                        they may occur multiple times in the same query
                    </p></li><li><p>
                        they are self-documenting
                    </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-scrolling"></a>9.3.3.&nbsp;Scrollable iteration</h3></div></div><div></div></div><p>
                If your JDBC driver supports scrollable <tt class="literal">ResultSet</tt>s, the <tt class="literal">Query</tt>
                interface may be used to obtain a <tt class="literal">ScrollableResults</tt> which allows more flexible
                navigation of the query results.
            </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-filtering"></a>9.3.4.&nbsp;Filtering collections</h3></div></div><div></div></div><p>
                A collection <span class="emphasis"><em>filter</em></span> is a special type of query that may be applied to
                a persistent collection or array. The query string may refer to <tt class="literal">this</tt>,
                meaning the current collection element.
            </p><pre class="programlisting">Collection blackKittens = session.filter(
    pk.getKittens(), "where this.color = ?", Color.BLACK, Hibernate.enum(Color.class)
);</pre><p>
                The returned collection is considered a bag.
            </p><p>
                Observe that filters do not require a <tt class="literal">from</tt> clause (though they may have
                one if required). Filters are not limited to returning the collection elements themselves.
            </p><pre class="programlisting">Collection blackKittenMates = session.filter(
    pk.getKittens(), "select this.mate where this.color = eg.Color.BLACK"
);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-criteria"></a>9.3.5.&nbsp;Criteria queries</h3></div></div><div></div></div><p>
                HQL is extremely powerful but some people prefer to build queries dynamically, using an
                object oriented API, rather than embedding strings in their Java code. For these people,
                Hibernate provides an intuitive <tt class="literal">Criteria</tt> query API.
            </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Expression.eq("color", eg.Color.BLACK) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p>
                If you are uncomfortable with SQL-like syntax, this is perhaps the easiest way to get started
                with Hibernate. This API is also more extensible than HQL. Applications might provide their
                own implementations of the <tt class="literal">Criterion</tt> interface.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-nativesql"></a>9.3.6.&nbsp;Queries in native SQL</h3></div></div><div></div></div><p>
                You may express a query in SQL, using <tt class="literal">createSQLQuery()</tt>. You must enclose
                SQL aliases in braces.
            </p><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    Cat.class
).list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    Cat.class
).list()</pre><p>
                SQL queries may contain named and positional parameters, just like Hibernate queries.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-updating"></a>9.4.&nbsp;Updating objects</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-updating-insession"></a>9.4.1.&nbsp;Updating in the same Session</h3></div></div><div></div></div><p>
                <span class="emphasis"><em>Transactional persistent instances</em></span> (ie. objects loaded, saved, created or
                queried by the <tt class="literal">Session</tt>) may be manipulated by the application
                and any changes to persistent state will be persisted when the <tt class="literal">Session</tt>
                is <span class="emphasis"><em>flushed</em></span> (discussed later in this chapter). So the most
                straightforward way to update the state of an object is to <tt class="literal">load()</tt> it,
                and then manipulate it directly, while the <tt class="literal">Session</tt> is open:
            </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</pre><p>
                Sometimes this programming model is inefficient since it would require both an SQL
                <tt class="literal">SELECT</tt> (to load an object) and an SQL <tt class="literal">UPDATE</tt>
                (to persist its updated state) in the same session. Therefore Hibernate offers an
                alternate approach.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-updating-detached"></a>9.4.2.&nbsp;Updating detached objects</h3></div></div><div></div></div><p>
                Many applications need to retrieve an object in one transaction, send it to the
                UI layer for manipulation, then save the changes in a new transaction.
                (Applications  that use this kind of approach in a high-concurrency environment
                usually use versioned  data to ensure transaction isolation.) This approach
                requires a slightly different  programming model to the one described in the
                last section. Hibernate supports this model by providing the
                method <tt class="literal">Session.update()</tt>.
            </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher tier of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre><p>
                If the <tt class="literal">Cat</tt> with identifier <tt class="literal">catId</tt> had already
                been loaded  by <tt class="literal">secondSession</tt> when the application tried to
                update it, an exception would have been thrown.
            </p><p>
                The application should individually <tt class="literal">update()</tt> transient instances
                reachable from the given transient instance if and <span class="emphasis"><em>only</em></span> if it wants
                their state also updated. (Except for lifecycle objects, discussed later.)
            </p><p>
                Hibernate users have requested a general purpose method that either saves a
                transient instance by generating a new identifier or update the persistent
                state associated with its current identifier. The <tt class="literal">saveOrUpdate()</tt>
                method now implements this functionality.
            </p><p>
                Hibernate distinguishes "new" (unsaved) instances from "existing" (saved or
                loaded in a previous session) instances by the value of their identifier
                (or version, or timestamp) property. The <tt class="literal">unsaved-value</tt>
                attribute of the <tt class="literal">&lt;id&gt;</tt> (or <tt class="literal">&lt;version&gt;</tt>,
                or <tt class="literal">&lt;timestamp&gt;</tt>) mapping specifies which values should
                be interpreted as representing a "new" instance.
            </p><pre class="programlisting">&lt;id name="id" type="long" column="uid" unsaved-value="null"&gt;
    &lt;generator class="hilo"/&gt;
&lt;/id&gt;</pre><p>
                The allowed values of <tt class="literal">unsaved-value</tt> are:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">any</tt> - always save
                    </p></li><li><p>
                    <tt class="literal">none</tt> - always update
                    </p></li><li><p>
                    <tt class="literal">null</tt> - save when identifier is null (this is the default)
                    </p></li><li><p>
                    valid identifier value - save when identifier is null or the given value
                    </p></li><li><p>
                    <tt class="literal">undefined</tt> - the default for <tt class="literal">version</tt> or
                        <tt class="literal">timestamp</tt>, then identifier check is used
                    </p></li></ul></div><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p>
                The usage and semantics of <tt class="literal">saveOrUpdate()</tt> seems to be confusing
                for new users. Firstly, so long as you are not trying to use instances from one session
                in another new session, you should not need to use <tt class="literal">update()</tt> or
                <tt class="literal">saveOrUpdate()</tt>. Some whole applications will never use either of
                these methods.
            </p><p>
                Usually <tt class="literal">update()</tt> or <tt class="literal">saveOrUpdate()</tt> are used in
                the following scenario:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        the application loads an object in the first session
                    </p></li><li><p>
                        the object is passed up to the UI tier
                    </p></li><li><p>
                        some modifications are made to the object
                    </p></li><li><p>
                        the object is passed back down to the business logic tier
                    </p></li><li><p>
                        the application persists these modifications by calling
                        <tt class="literal">update()</tt> in a second session
                    </p></li></ul></div><p>
                <tt class="literal">saveOrUpdate()</tt> does the following:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        if the object is already persistent in this session, do nothing
                    </p></li><li><p>
                        if the object has no identifier property, <tt class="literal">save()</tt> it
                    </p></li><li><p>
                        if the object's identifier matches the criteria specified by
                        <tt class="literal">unsaved-value</tt>, <tt class="literal">save()</tt> it
                    </p></li><li><p>
                        if the object is versioned (<tt class="literal">version</tt> or
                        <tt class="literal">timestamp</tt>), then the version will take precedence
                        to identifier check, unless the versions
                        <tt class="literal">unsaved-value="undefined"</tt> (default value)
                    </p></li><li><p>
                        if another object associated with the session has the same
                        identifier, throw an exception
                    </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-update-lock"></a>9.4.3.&nbsp;Reattaching detached objects</h3></div></div><div></div></div><p>
                The <tt class="literal">lock()</tt> method allows the application to reassociate
                an unmodified object with a new session.
            </p><pre class="programlisting">//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-deleting"></a>9.5.&nbsp;Deleting persistent objects</h2></div></div><div></div></div><p>
            <tt class="literal">Session.delete()</tt> will remove an object's state from the database. 
            Of course, your application might still hold a reference to it. So it's best to think 
            of <tt class="literal">delete()</tt> as making a persistent instance transient.
        </p><pre class="programlisting">sess.delete(cat);</pre><p>
            You may also delete many objects at once by passing a Hibernate query string to
            <tt class="literal">delete()</tt>.
        </p><p>
            You may now delete objects in any order you like, without risk of foreign key
            constraint violations. Of course, it is still possible to violate a <tt class="literal">NOT
            NULL</tt> constraint on a foreign key column by deleting objects in
            the wrong order.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-flushing"></a>9.6.&nbsp;Flush</h2></div></div><div></div></div><p>
            From time to time the <tt class="literal">Session</tt> will execute the SQL statements 
            needed to synchronize the JDBC connection's state with the state of objects held in 
            memory. This process, <span class="emphasis"><em>flush</em></span>, occurs by default at the following 
            points
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    from some invocations of <tt class="literal">find()</tt> or <tt class="literal">iterate()</tt>
                </p></li><li><p>
                    from <tt class="literal">net.sf.hibernate.Transaction.commit()</tt>
                </p></li><li><p>
                    from <tt class="literal">Session.flush()</tt>
                </p></li></ul></div><p>
            The SQL statements are issued in the following order
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    all entity insertions, in the same order the corresponding objects
                    were saved using <tt class="literal">Session.save()</tt>
                </p></li><li><p>
                    all entity updates
                </p></li><li><p>
                    all collection deletions
                </p></li><li><p>
                    all collection element deletions, updates and insertions
                </p></li><li><p>
                    all collection insertions
                </p></li><li><p>
                    all entity deletions, in the same order the corresponding objects
                    were deleted using <tt class="literal">Session.delete()</tt>
                </p></li></ol></div><p>
            (An exception is that objects using <tt class="literal">native</tt> ID generation are 
            inserted when they are saved.)
        </p><p>
            Except when you explicity <tt class="literal">flush()</tt>, there are absolutely no 
            guarantees about <span class="emphasis"><em>when</em></span> the <tt class="literal">Session</tt> executes 
            the JDBC calls, only the <span class="emphasis"><em>order</em></span> in which they are executed.
            However, Hibernate does guarantee that the <tt class="literal">Session.find(..)</tt> 
            methods will never return stale data; nor will they return the wrong data.
        </p><p>
            It is possible to change the default behavior so that flush occurs less frequently.
            The <tt class="literal">FlushMode</tt> class defines three different modes. This is most
            useful in the case of "readonly" transactions, where it might be used to achieve a
            (very) slight performance increase.
        </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); //allow queries to return stale state
Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);
// execute some queries....
sess.find("from Cat as cat left outer join cat.kittens kitten");
//change to izi is not flushed!
...
tx.commit(); //flush occurs</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-endingsession"></a>9.7.&nbsp;Ending a Session</h2></div></div><div></div></div><p>
            Ending a session involves four distinct phases:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    flush the session
                </p></li><li><p>
                    commit the transaction
                </p></li><li><p>
                    close the session
                </p></li><li><p>
                    handle exceptions
                </p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-flushing"></a>9.7.1.&nbsp;Flushing the Session</h3></div></div><div></div></div><p>
                If you happen to be using the <tt class="literal">Transaction</tt> API, you don't
                need to worry about this step. It will be performed implicitly when the 
                transaction is committed. Otherwise you should call 
                <tt class="literal">Session.flush()</tt> to ensure that all changes are synchronized
                with the database.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-commit"></a>9.7.2.&nbsp;Committing the database transaction</h3></div></div><div></div></div><p>
                If you are using the Hibernate <tt class="literal">Transaction</tt> API, this looks like:
            </p><pre class="programlisting">tx.commit(); // flush the Session and commit the transaction</pre><p>
                If you are managing JDBC transactions yourself you should manually
                <tt class="literal">commit()</tt> the JDBC connection.
            </p><pre class="programlisting">sess.flush();
sess.connection().commit();  // not necessary for JTA datasource</pre><p>
                If you decide <span class="emphasis"><em>not</em></span> to commit your changes:
            </p><pre class="programlisting">tx.rollback();  // rollback the transaction</pre><p>
                or:
            </p><pre class="programlisting">// not necessary for JTA datasource, important otherwise
sess.connection().rollback();</pre><p>
                If you rollback the transaction you should immediately close and discard the current
                session to ensure that Hibernate's internal state is consistent.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-close"></a>9.7.3.&nbsp;Closing the Session</h3></div></div><div></div></div><p>
                A call to <tt class="literal">Session.close()</tt> marks the end of a session. The main implication
                of <tt class="literal">close()</tt> is that the JDBC connection will be relinquished by the session.
            </p><pre class="programlisting">tx.commit();
sess.close();</pre><pre class="programlisting">sess.flush();
sess.connection().commit();  // not necessary for JTA datasource
sess.close();</pre><p>
                If you provided your own connection, <tt class="literal">close()</tt> returns a reference 
                to it, so you can manually close it or return it to the pool. Otherwise <tt class="literal">close()
                </tt> returns it to the pool.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-exceptions"></a>9.7.4.&nbsp;Exception handling</h3></div></div><div></div></div><p>
                If the <tt class="literal">Session</tt> throws an exception (including
                any <tt class="literal">SQLException</tt>), you should immediately
                rollback the transaction, call <tt class="literal">Session.close()</tt>
                and discard the <tt class="literal">Session</tt> instance. Certain
                methods of <tt class="literal">Session</tt> will <span class="emphasis"><em>not</em></span>
                leave the session in a consistent state.
            </p><p>
                The following exception handling idiom is recommended:
            </p><pre class="programlisting">Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();
    // do some work
    ...
    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    throw e;
}
finally {
    sess.close();
}</pre><p>
                Or, when manually managing JDBC transactions:
            </p><pre class="programlisting">Session sess = factory.openSession();
try {
    // do some work
    ...
    sess.flush();
    sess.connection().commit();
}
catch (Exception e) {
    sess.connection().rollback();
    throw e;
}
finally {
    sess.close();
}</pre><p>
                Or, when using a datasource enlisted with JTA:
            </p><pre class="programlisting">UserTransaction ut = .... ;
Session sess = factory.openSession();
try {
    // do some work
    ...
    sess.flush();
}
catch (Exception e) {
    ut.setRollbackOnly();
    throw e;
}
finally {
    sess.close();
}</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-graphs"></a>9.8.&nbsp;Lifecyles and object graphs</h2></div></div><div></div></div><p>
            To save or update all objects in a graph of associated objects, you must either
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">save()</tt>, <tt class="literal">saveOrUpdate()</tt> or
                    <tt class="literal">update()</tt> each individual object OR
                </p></li><li><p>
                    map associated objects using <tt class="literal">cascade="all"</tt> or
                    <tt class="literal">cascade="save-update"</tt>.
                </p></li></ul></div><p>
            Likewise, to delete all objects in a graph, either
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">delete()</tt> each individual object OR
                </p></li><li><p>
                    map associated objects using <tt class="literal">cascade="all"</tt>,
                    <tt class="literal">cascade="all-delete-orphan"</tt> or
                    <tt class="literal">cascade="delete"</tt>.
                </p></li></ul></div><p>
            Recommendation:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    If the child object's lifespan is bounded by the lifespan of the of the parent
                    object make it a <span class="emphasis"><em>lifecycle object</em></span> by specifying
                    <tt class="literal">cascade="all"</tt>.
                </p></li><li><p>
                    Otherwise, <tt class="literal">save()</tt> and <tt class="literal">delete()</tt> it
                    explicitly from application code. If you really want to save yourself some
                    extra typing, use <tt class="literal">cascade="save-update"</tt> and explicit
                    <tt class="literal">delete()</tt>.
                </p></li></ul></div><p>
            Mapping an association (many-to-one, or collection) with <tt class="literal">cascade="all"</tt>
            marks the association as a <span class="emphasis"><em>parent/child</em></span> style relationship where
            save/update/deletion of the parent results in save/update/deletion of the child(ren).
            Futhermore, a mere reference to a child from a persistent parent will result in save / update
            of the child. The metaphor is incomplete, however. A child which becomes unreferenced by its
            parent is <span class="emphasis"><em>not</em></span> automatically deleted, except in the case of a
            <tt class="literal">&lt;one-to-many&gt;</tt> association mapped with
            <tt class="literal">cascade="all-delete-orphan"</tt>. The precise semantics of cascading operations
            are as follows:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    If a parent is saved, all children are passed to <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    If a parent is passed to <tt class="literal">update()</tt> or <tt class="literal">saveOrUpdate()</tt>,
                    all children are passed to <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    If a transient child becomes referenced by a persistent parent, it is passed to
                    <tt class="literal">saveOrUpdate()</tt>
                </p></li><li><p>
                    If a parent is deleted, all children are passed to <tt class="literal">delete()</tt>
                </p></li><li><p>
                    If a transient child is dereferenced by a persistent parent, <span class="emphasis"><em>nothing
                    special happens</em></span> (the application should explicitly delete the child if
                    necessary) unless <tt class="literal">cascade="all-delete-orphan"</tt>, in which case the
                    "orphaned" child is deleted.
                </p></li></ul></div><p>
            Hibernate does not fully implement "persistence by reachability", which would imply
            (inefficient) persistent garbage collection. However, due to popular demand,
            Hibernate does support the notion of entities becoming persistent when referenced
            by another persistent object. Associations marked
            <tt class="literal">cascade="save-update"</tt> behave in this way. If you wish to use this
            approach throughout your application, its easier to specify the
            <tt class="literal">default-cascade</tt> attribute of the
            <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-interceptors"></a>9.9.&nbsp;Interceptors</h2></div></div><div></div></div><p>
            The <tt class="literal">Interceptor</tt> interface provides callbacks from the session to the 
            application allowing the application to inspect and / or manipulate properties of a 
            persistent object before it is saved, updated, deleted or loaded. One 
            possible use for this is to track auditing information. For example, the following 
            <tt class="literal">Interceptor</tt> automatically sets the  <tt class="literal">createTimestamp</tt> 
            when an <tt class="literal">Auditable</tt> is created and updates the 
            <tt class="literal">lastUpdateTimestamp</tt> property when an <tt class="literal">Auditable</tt> is 
            updated.
        </p><pre class="programlisting">package net.sf.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import net.sf.hibernate.Interceptor;
import net.sf.hibernate.type.Type;

public class AuditInterceptor implements Interceptor, Serializable {

    private int updates;
    private int creates;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // do nothing
    }

    public boolean onFlushDirty(Object entity, 
                                Serializable id, 
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity, 
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        
        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void postFlush(Iterator entities) {
        System.out.println("Creations: " + creates + ", Updates: " + updates);
    }

    public void preFlush(Iterator entities) {
        updates=0;
        creates=0;
    }
    
    ......
    ......
    
}</pre><p>
            The interceptor would be specified when a session is created.
        </p><pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-metadata"></a>9.10.&nbsp;Metadata API</h2></div></div><div></div></div><p>
            Hibernate requires a very rich meta-level model of all entity and value types. From time
            to time, this model is very useful to the application itself. For example, the application
            might use Hibernate's metadata to implement a "smart" deep-copy algorithm that understands
            which objects should be copied (eg. mutable value types) and which should not (eg. 
            immutable value types and, possibly, associated entities).
        </p><p>
            Hibernate exposes metadata via the <tt class="literal">ClassMetadata</tt> and
            <tt class="literal">CollectionMetadata</tt> interfaces and the <tt class="literal">Type</tt>
            hierarchy. Instances of the metadata interfaces may be obtained from the 
            <tt class="literal">SessionFactory</tt>.
        </p><pre class="programlisting">Cat fritz = ......;
Long id = (Long) catMeta.getIdentifier(fritz);
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);
Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();
// get a Map of all properties which are not collections or associations
// TODO: what about components?
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transactions"></a>Chapter&nbsp;10.&nbsp;Transactions And Concurrency</h2></div></div><div></div></div><p>
        Hibernate is not itself a database. It is a lightweight object-relational
        mapping tool. Transaction management is delegated to the underlying database
        connection. If the connection is enlisted with JTA, operations performed by the
        <tt class="literal">Session</tt> are atomically part of the wider JTA
        transaction. Hibernate can be seen as a thin adapter to JDBC, adding object-
        oriented semantics.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-basics"></a>10.1.&nbsp;Configurations, Sessions and Factories</h2></div></div><div></div></div><p>
            A <tt class="literal">SessionFactory</tt> is an expensive-to-create, threadsafe object 
            intended to be shared by all application threads. A <tt class="literal">Session</tt> 
            is an inexpensive, non-threadsafe object that should be used once, for a single
            business process, and then discarded. For example, when using Hibernate in a 
            servlet-based application, servlets could obtain a <tt class="literal">SessionFactory</tt> 
            using
        </p><pre class="programlisting">SessionFactory sf = (SessionFactory)getServletContext().getAttribute("my.session.factory");</pre><p>
            Each call to a service method could create a new <tt class="literal">Session</tt>,
            <tt class="literal">flush()</tt> it, <tt class="literal">commit()</tt> its connection,
            <tt class="literal">close()</tt> it and finally discard it. (The <tt class="literal">SessionFactory</tt>
            may also be kept in JNDI or in a static <span class="emphasis"><em>Singleton</em></span> helper variable.)
        </p><p>
            In a stateless session bean, a similar approach could be used. The bean would
            obtain a <tt class="literal">SessionFactory</tt> in <tt class="literal">setSessionContext()</tt>. 
            Then each business method would create a <tt class="literal">Session</tt>,
            <tt class="literal">flush()</tt> it and <tt class="literal">close()</tt> it. Of course, the 
            application should not <tt class="literal">commit()</tt> the connection. (Leave that to 
            JTA, the database connection participates automatically in container-managed
            transactions.)
        </p><p>
            We use the Hibernate <tt class="literal">Transaction</tt> API as discussed previously,
            a single <tt class="literal">commit()</tt> of a Hibernate <tt class="literal">Transaction</tt>
            flushes the state and commits any underlying database connection (with special
            handling of JTA transactions).
        </p><p>
            Ensure you understand the semantics of <tt class="literal">flush()</tt>.
            Flushing synchronizes the persistent store with in-memory changes but
            <span class="emphasis"><em>not</em></span> vice-versa. Note that for all Hibernate JDBC
            connections/transactions, the transaction isolation level for that connection
            applies to all operations executed by Hibernate!
        </p><p>
            The next few sections will discuss alternative approaches that utilize versioning
            to ensure transaction atomicity. These are considered "advanced" approaches to
            be used with care.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-threads"></a>10.2.&nbsp;Threads and connections</h2></div></div><div></div></div><p>
            You should observe the following practices when creating Hibernate Sessions:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Never create more than one concurrent <tt class="literal">Session</tt> or
                    <tt class="literal">Transaction</tt> instance per database connection.
                </p></li><li><p>
                    Be extremely careful when creating more than one <tt class="literal">Session</tt>
                    per database per transaction. The <tt class="literal">Session</tt> itself keeps
                    track of updates made to loaded objects, so a different <tt class="literal">Session</tt>
                    might see stale data.
                </p></li><li><p>
                    The <tt class="literal">Session</tt> is <span class="emphasis"><em>not</em></span> threadsafe!
                    Never access the same <tt class="literal">Session</tt> in two concurrent threads.
                    A <tt class="literal">Session</tt> is usually only a single unit-of-work!
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-identity"></a>10.3.&nbsp;Considering object identity</h2></div></div><div></div></div><p>
            The application may concurrently access the same persistent state in two
            different units-of-work. However, an instance of a persistent class is never shared
            between two <tt class="literal">Session</tt> instances. Hence there are
            two different notions of identity:
        </p><div class="variablelist"><dl><dt><span class="term">Database Identity</span></dt><dd><p>
                        <tt class="literal">foo.getId().equals( bar.getId() )</tt>
                    </p></dd><dt><span class="term">JVM Identity</span></dt><dd><p>
                        <tt class="literal">foo==bar</tt>
                    </p></dd></dl></div><p>
            Then for objects attached to a <span class="emphasis"><em>particular</em></span> <tt class="literal">Session</tt>,
            the two notions are equivalent. However, while the application might concurrently access
            the "same" (persistent identity) business object in two different sessions, the two
            instances will actually be "different" (JVM identity).
        </p><p>
            This approach leaves Hibernate and the database to worry about concurrency. The
            application never needs to synchronize on any business object, as long as it sticks to a
            single thread per <tt class="literal">Session</tt> or object identity (within a
            <tt class="literal">Session</tt> the  application may safely use <tt class="literal">==</tt> to
            compare objects).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-optimistic"></a>10.4.&nbsp;Optimistic concurrency control</h2></div></div><div></div></div><p>
            Many business processes require a whole series of interactions with the user
            interleaved with database accesses. In web and enterprise applications it is
            not acceptable for a database transaction to span a user interaction.
        </p><p>
            Maintaining isolation of business processes becomes the partial responsibility
            of the application tier, hence we call this process a long running
            <span class="emphasis"><em>application transaction</em></span>. A single application transaction
            usually spans several database transactions. It will be atomar if only one of
            these database transactions (the last one) stores the updated data, all others
            simply read data.
        </p><p>
            The only approach that is consistent with high concurrency and high
            scalability is optimistic concurrency control with versioning. Hibernate
            provides for three possible approaches to writing application code that
            uses optimistic concurrency.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-longsession"></a>10.4.1.&nbsp;Long session with automatic versioning</h3></div></div><div></div></div><p>
                A single <tt class="literal">Session</tt> instance and its persistent instances are
                used for the whole application transaction.
            </p><p>
                The <tt class="literal">Session</tt> uses optimistic locking with versioning to
                ensure that many database transactions appear to the application as a single
                logical application transaction. The <tt class="literal">Session</tt> is disconnected
                from any underlying JDBC connection when waiting for user interaction. This
                approach is the most efficient in terms of database access. The application
                need not concern itself with version checking or with reattaching detached
                instances.
            </p><pre class="programlisting">// foo is an instance loaded earlier by the Session
session.reconnect();
foo.setProperty("bar");
session.flush();
session.connection().commit();
session.disconnect();</pre><p>
                The <tt class="literal">foo</tt> object still knows which <tt class="literal">Session</tt>
                it was loaded it. As soon as the <tt class="literal">Session</tt> has a JDBC connection,
                we commit the changes to the object.
            </p><p>
                This pattern is problematic if our <tt class="literal">Session</tt> is too big to
                be stored during user think time, e.g. an <tt class="literal">HttpSession</tt> should
                be kept as small as possible. As the <tt class="literal">Session</tt> is also the
                (mandatory) first-level cache and contains all loaded objects, we can propably
                use this strategy only for a few request/response cycles. This is indeed
                recommended, as the <tt class="literal">Session</tt> will soon also have stale data.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-detached"></a>10.4.2.&nbsp;Many sessions with automatic versioning</h3></div></div><div></div></div><p>
                Each interaction with the persistent store occurs in a new <tt class="literal">Session</tt>. 
                However, the same persistent instances are reused for each interaction with the database.
                The application manipulates the state of detached instances originally loaded in another
                <tt class="literal">Session</tt> and then "reassociates" them using 
                <tt class="literal">Session.update()</tt> or <tt class="literal">Session.saveOrUpdate()</tt>.
            </p><pre class="programlisting">// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
session.saveOrUpdate(foo);
session.flush();
session.connection().commit();
session.close();</pre><p>
                You may also call <tt class="literal">lock()</tt> instead of <tt class="literal">update()</tt>
                and use <tt class="literal">LockMode.READ</tt> (performing a version check, bypassing all
                caches) if you are sure that the object has not been modified.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-manual"></a>10.4.3.&nbsp;Application version checking</h3></div></div><div></div></div><p>
                Each interaction with the database occurs in a new <tt class="literal">Session</tt>
                that reloads all persistent instances from the database before manipulating them.
                This approach forces the application to carry out its own version checking to ensure 
                application transaction isolation. (Of course, Hibernate will still <span class="emphasis"><em>update</em></span>
                version numbers for you.) This approach is the least efficient in terms of database access. 
                It is the approach most similar to entity EJBs.
            </p><pre class="programlisting">// foo is an instance loaded by a previous Session
session = factory.openSession();
int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() );
if ( oldVersion!=foo.getVersion ) throw new StaleObjectStateException();
foo.setProperty("bar");
session.flush();
session.connection().commit();
session.close();</pre><p>
                Of course, if you are operating in a low-data-concurrency environment and don't
                require version checking, you may use this approach and just skip the version
                check.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-disconnection"></a>10.5.&nbsp;Session disconnection</h2></div></div><div></div></div><p>
            The first approach described above is to maintain a single <tt class="literal">Session</tt> 
            for a whole business process thats spans user think time. (For example, a servlet might 
            keep a <tt class="literal">Session</tt> in the user's <tt class="literal">HttpSession</tt>.) For 
            performance reasons you should
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    commit the <tt class="literal">Transaction</tt> (or JDBC connection) and then
                </p></li><li><p>
                    disconnect the <tt class="literal">Session</tt> from the JDBC connection
                </p></li></ol></div><p>
            before waiting for user activity. The method <tt class="literal">Session.disconnect()</tt> 
            will disconnect the session from the JDBC connection and return the connection to 
            the pool (unless you provided the connection).
        </p><p>
            <tt class="literal">Session.reconnect()</tt> obtains a new connection (or you may supply one) 
            and restarts the session. After reconnection, to force a version check on data you aren't 
            updating, you may call <tt class="literal">Session.lock()</tt> on any objects that might have
            been updated by another transaction. You don't need to lock any data that you
            <span class="emphasis"><em>are</em></span> updating.
        </p><p>
            Heres an example:
        </p><pre class="programlisting">SessionFactory sessions;
List fooList;
Bar bar;
....
Session s = sessions.openSession();

Transaction tx = null;
try {
    tx = s.beginTransaction();

    fooList = s.find(
    	"select foo from eg.Foo foo where foo.Date = current date"
        // uses db2 date function
    );
    bar = (Bar) s.create(Bar.class);

    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    s.close();
    throw e;
}
s.disconnect();</pre><p>
            Later on:
        </p><pre class="programlisting">s.reconnect();

try {
    tx = s.beginTransaction();

    bar.setFooTable( new HashMap() );
    Iterator iter = fooList.iterator();
    while ( iter.hasNext() ) {
        Foo foo = (Foo) iter.next();
        s.lock(foo, LockMode.READ);    //check that foo isn't stale
        bar.getFooTable().put( foo.getName(), foo );
    }

    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    throw e;
}
finally {
    s.close();
}</pre><p>
            You can see from this how the relationship between <tt class="literal">Transaction</tt>s and
            <tt class="literal">Session</tt>s is many-to-one, A <tt class="literal">Session</tt> represents a 
            conversation between the application and the database. The
            <tt class="literal">Transaction</tt> breaks that conversation up into atomic units of work
            at the database level.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-locking"></a>10.6.&nbsp;Pessimistic Locking</h2></div></div><div></div></div><p>
            It is not intended that users spend much time worring about locking strategies. Its usually
            enough to specify an isolation level for the JDBC connections and then simply let the
            database do all the work. However, advanced users may sometimes wish to obtain
            exclusive pessimistic locks, or re-obtain locks at the start of a new transaction.
        </p><p>
            Hibernate will always use the locking mechanism of the database, never lock objects
            in memory!
        </p><p>
            The <tt class="literal">LockMode</tt> class defines the different lock levels that may be acquired
            by Hibernate. A lock is obtained by the following mechanisms:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">LockMode.WRITE</tt> is acquired automatically when Hibernate updates or inserts 
                    a row. 
                </p></li><li><p>
                    <tt class="literal">LockMode.UPGRADE</tt> may be acquired upon explicit user request using 
                    <tt class="literal">SELECT ... FOR UPDATE</tt> on databases which support that syntax.
                </p></li><li><p>
                    <tt class="literal">LockMode.UPGRADE_NOWAIT</tt> may be acquired upon explicit user request using a 
                    <tt class="literal">SELECT ... FOR UPDATE NOWAIT</tt> under Oracle.
                </p></li><li><p>
                    <tt class="literal">LockMode.READ</tt> is acquired automatically when Hibernate reads data
                    under Repeatable Read or Serializable isolation level. May be re-acquired by explicit user 
                    request.
                </p></li><li><p>
            <tt class="literal">LockMode.NONE</tt> represents the absence of a lock. All objects switch to this
            lock mode at the end of a <tt class="literal">Transaction</tt>. Objects associated with the session 
            via a call to <tt class="literal">update()</tt> or <tt class="literal">saveOrUpdate()</tt> also start out 
            in this lock mode.
        </p></li></ul></div><p>
            The "explicit user request" is expressed in one of the following ways:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    A call to <tt class="literal">Session.load()</tt>, specifying a <tt class="literal">LockMode</tt>.
                </p></li><li><p>
                    A call to <tt class="literal">Session.lock()</tt>.
                </p></li><li><p>
                    A call to <tt class="literal">Query.setLockMode()</tt>.
                </p></li></ul></div><p>
            If <tt class="literal">Session.load()</tt> is called with <tt class="literal">UPGRADE</tt> or
            <tt class="literal">UPGRADE_NOWAIT</tt>, and the requested object was not yet loaded by
            the session, the object is loaded using <tt class="literal">SELECT ... FOR UPDATE</tt>.
            If <tt class="literal">load()</tt> is called for an object that is already loaded with
            a less restrictive lock than the one requested, Hibernate calls 
            <tt class="literal">lock()</tt> for that object.
        </p><p>
            <tt class="literal">Session.lock()</tt> performs a version number check if the specified lock
            mode is <tt class="literal">READ</tt>, <tt class="literal">UPGRADE</tt> or 
            <tt class="literal">UPGRADE_NOWAIT</tt>. (In the case of <tt class="literal">UPGRADE</tt> or
            <tt class="literal">UPGRADE_NOWAIT</tt>, <tt class="literal">SELECT ... FOR UPDATE</tt> is used.)
        </p><p>
            If the database does not support the requested lock mode, Hibernate will use an appropriate
            alternate mode (instead of throwing an exception). This ensures that applications will
            be portable.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="queryhql"></a>Chapter&nbsp;11.&nbsp;HQL: The Hibernate Query Language</h2></div></div><div></div></div><p>
        Hibernate is equiped with an extremely powerful query language that (quite intentionally)
        looks very much like SQL. But don't be fooled by the syntax; HQL is fully object-oriented,
        understanding notions like inheritence, polymorphism and association.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-casesensitivity"></a>11.1.&nbsp;Case Sensitivity</h2></div></div><div></div></div><p>
            Queries are case-insensitive, except for names of Java classes and properties.
            So <tt class="literal">SeLeCT</tt> is the same as
            <tt class="literal">sELEct</tt> is the same as
            <tt class="literal">SELECT</tt> but
            <tt class="literal">net.sf.hibernate.eg.FOO</tt> is not
            <tt class="literal">net.sf.hibernate.eg.Foo</tt> and
            <tt class="literal">foo.barSet</tt> is not
            <tt class="literal">foo.BARSET</tt>.
        </p><p>
            This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords 
            more readable, but we find this convention ugly when embedded in Java code.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-from"></a>11.2.&nbsp;The from clause</h2></div></div><div></div></div><p>
            The simplest possible Hibernate query is of the form:
        </p><pre class="programlisting">from eg.Cat</pre><p>
            which simply returns all instances of the class <tt class="literal">eg.Cat</tt>. 
        </p><p>
            Most of the time, you will need to assign an <span class="emphasis"><em>alias</em></span>, since
            you will want to refer to the <tt class="literal">Cat</tt> in other parts of the
            query.
        </p><pre class="programlisting">from eg.Cat as cat</pre><p>
            This query assigns the alias <tt class="literal">cat</tt> to <tt class="literal">Cat</tt>
            instances, so we could use that alias later in the query. The <tt class="literal">as</tt>
            keyword is optional; we could also write:
        </p><pre class="programlisting">from eg.Cat cat</pre><p>
            Multiple classes may appear, resulting in a cartesian product or "cross" join.
        </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>
            It is considered good practice to name query aliases using an initial lowercase,
            consistent with Java naming standards for local variables
            (eg. <tt class="literal">domesticCat</tt>).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-joins"></a>11.3.&nbsp;Associations and joins</h2></div></div><div></div></div><p>
            We may also assign aliases to associated entities, or even to elements of a collection of
            values, using a <tt class="literal">join</tt>.
        </p><pre class="programlisting">from eg.Cat as cat 
    inner join cat.mate as mate
    left outer join cat.kittens as kitten

from eg.Cat as cat left join cat.mate.kittens as kittens

from Formula form full join form.parameter param</pre><p>
            The supported join types are borrowed from ANSI SQL
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">inner join</tt>
                </p></li><li><p>
                    <tt class="literal">left outer join</tt>
                </p></li><li><p>
                    <tt class="literal">right outer join</tt>
                </p></li><li><p>
                    <tt class="literal">full join</tt> (not usually useful)
                </p></li></ul></div><p>
            The <tt class="literal">inner join</tt>, <tt class="literal">left outer join</tt> and 
            <tt class="literal">right outer join</tt> constructs may be abbreviated.
        </p><pre class="programlisting">from eg.Cat as cat 
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>
            In addition, a "fetch" join allows associations or collections of values to be 
            initialized along with their parent objects, using a single select. This is particularly 
            useful in the case of a collection. It effectively overrides the outer join and
            lazy declarations of the mapping file for associations and collections.
        </p><pre class="programlisting">from eg.Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>
            A fetch join does not usually need to assign an alias, because the associated objects 
            should not be used in the <tt class="literal">where</tt> clause (or any other clause). Also, 
            the associated objects are not returned directly in the query results. Instead, they may 
            be accessed via the parent object.
        </p><p>
            Note that, in the current implementation, only one collection role may be fetched
            in a query (everything else would be non-performant). Note also that the
            <tt class="literal">fetch</tt> construct may not be used in queries called using
            <tt class="literal">scroll()</tt> or <tt class="literal">iterate()</tt>. Finally, note that
            <tt class="literal">full join fetch</tt> and <tt class="literal">right join fetch</tt> are not meaningful.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-select"></a>11.4.&nbsp;The select clause</h2></div></div><div></div></div><p>
            The <tt class="literal">select</tt> clause picks which objects and properties to return in 
            the query result set. Consider:
        </p><pre class="programlisting">select mate 
from eg.Cat as cat 
    inner join cat.mate as mate</pre><p>
            The query will select <tt class="literal">mate</tt>s of other <tt class="literal">Cat</tt>s.
            Actually, you may express this query more compactly as:
        </p><pre class="programlisting">select cat.mate from eg.Cat cat</pre><p>
            You may even select collection elements, using the special <tt class="literal">elements</tt>
            function. The following query returns all kittens of any cat.
        </p><pre class="programlisting">select elements(cat.kittens) from eg.Cat cat</pre><p>
            Queries may return properties of any value type including properties of component type:
        </p><pre class="programlisting">select cat.name from eg.DomesticCat cat
where cat.name like 'fri%'

select cust.name.firstName from Customer as cust</pre><p>
            Queries may return multiple objects and/or properties as an array of type 
            <tt class="literal">Object[]</tt>
        </p><pre class="programlisting">select mother, offspr, mate.name 
from eg.DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>
            or as an actual typesafe Java object
        </p><pre class="programlisting">select new Family(mother, mate, offspr)
from eg.DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>
            assuming that the class <tt class="literal">Family</tt> has an appropriate constructor.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-aggregation"></a>11.5.&nbsp;Aggregate functions</h2></div></div><div></div></div><p>
            HQL queries may even return the results of aggregate functions on properties:
        </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from eg.Cat cat</pre><p>
            Collections may also appear inside aggregate functions in the <tt class="literal">select</tt> 
            clause.
        </p><pre class="programlisting">select cat, count( elements(cat.kittens) ) 
from eg.Cat cat group by cat</pre><p>
            The supported aggregate functions are
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">avg(...), sum(...), min(...), max(...)</tt>
                </p></li><li><p>
                    <tt class="literal">count(*)</tt>
                </p></li><li><p>
                    <tt class="literal">count(...), count(distinct ...), count(all...)</tt>
                </p></li></ul></div><p>
            The <tt class="literal">distinct</tt> and <tt class="literal">all</tt> keywords may be used and have
            the same semantics as in SQL.
        </p><pre class="programlisting">select distinct cat.name from eg.Cat cat

select count(distinct cat.name), count(cat) from eg.Cat cat</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-polymorphism"></a>11.6.&nbsp;Polymorphic queries</h2></div></div><div></div></div><p>
            A query like:
        </p><pre class="programlisting">from eg.Cat as cat</pre><p>
            returns instances not only of <tt class="literal">Cat</tt>, but also of subclasses like
            <tt class="literal">DomesticCat</tt>. Hibernate queries may name <span class="emphasis"><em>any</em></span> Java 
            class or interface in the <tt class="literal">from</tt> clause. The query will return instances 
            of all persistent classes that extend that class or implement the interface. The following 
            query would return all persistent objects:
        </p><pre class="programlisting">from java.lang.Object o</pre><p>
            The interface <tt class="literal">Named</tt> might be implemented by various persistent
            classes:
        </p><pre class="programlisting">from eg.Named n, eg.Named m where n.name = m.name</pre><p>
            Note that these last two queries will require more than one SQL <tt class="literal">SELECT</tt>. This
            means that the <tt class="literal">order by</tt> clause does not correctly order the whole result set.
            (It also means you can't call these queries using <tt class="literal">Query.scroll()</tt>.)
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-where"></a>11.7.&nbsp;The where clause</h2></div></div><div></div></div><p>
            The <tt class="literal">where</tt> clause allows you to narrow the list of instances returned.
        </p><pre class="programlisting">from eg.Cat as cat where cat.name='Fritz'</pre><p>
            returns instances of <tt class="literal">Cat</tt> named 'Fritz'.
        </p><pre class="programlisting">select foo 
from eg.Foo foo, eg.Bar bar
where foo.startDate = bar.date</pre><p>
            will return all instances of <tt class="literal">Foo</tt> for which
            there exists an instance of <tt class="literal">bar</tt> with a
            <tt class="literal">date</tt> property equal to the
            <tt class="literal">startDate</tt> property of the
            <tt class="literal">Foo</tt>. Compound path expressions make the
            <tt class="literal">where</tt> clause extremely powerful. Consider:
        </p><pre class="programlisting">from eg.Cat cat where cat.mate.name is not null</pre><p>
            This query translates to an SQL query with a table (inner) join. If you were to write
            something like
        </p><pre class="programlisting">from eg.Foo foo  
where foo.bar.baz.customer.address.city is not null</pre><p>
            you would end up with a query that would require four table joins in SQL.
        </p><p>
            The <tt class="literal">=</tt> operator may be used to compare not only properties, but also 
            instances:
        </p><pre class="programlisting">from eg.Cat cat, eg.Cat rival where cat.mate = rival.mate

select cat, mate 
from eg.Cat cat, eg.Cat mate
where cat.mate = mate</pre><p>
            The special property (lowercase) <tt class="literal">id</tt> may be used to reference the 
            unique identifier of an object. (You may also use its property name.)
        </p><pre class="programlisting">from eg.Cat as cat where cat.id = 123

from eg.Cat as cat where cat.mate.id = 69</pre><p>
            The second query is efficient. No table join is required!
        </p><p>
            Properties of composite identifiers may also be used. Suppose <tt class="literal">Person</tt> 
            has a composite identifier consisting of <tt class="literal">country</tt> and 
            <tt class="literal">medicareNumber</tt>.
        </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU' 
    and person.id.medicareNumber = 123456

from bank.Account account
where account.owner.id.country = 'AU' 
    and account.owner.id.medicareNumber = 123456</pre><p>
            Once again, the second query requires no table join.
        </p><p>
            Likewise, the special property <tt class="literal">class</tt> accesses the discriminator value
            of an instance in the case of polymorphic persistence. A Java class name embedded in the 
            where clause will be translated to its discriminator value.
        </p><pre class="programlisting">from eg.Cat cat where cat.class = eg.DomesticCat</pre><p>
            You may also specify properties of components or composite user types (and of components 
            of components, etc). Never try to use a path-expression that ends in a property of component 
            type (as opposed to a property of a component). For example, if <tt class="literal">store.owner</tt>
            is an entity with a component <tt class="literal">address</tt>
        </p><pre class="programlisting">store.owner.address.city    // okay
store.owner.address         // error!</pre><p>
            An "any" type has the special properties <tt class="literal">id</tt> and <tt class="literal">class</tt>,
            allowing us to express a join in the following way (where <tt class="literal">AuditLog.item</tt>
            is a property mapped with <tt class="literal">&lt;any&gt;</tt>).
        </p><pre class="programlisting">from eg.AuditLog log, eg.Payment payment 
where log.item.class = 'eg.Payment' and log.item.id = payment.id</pre><p>
            Notice that <tt class="literal">log.item.class</tt> and <tt class="literal">payment.class</tt>
            would refer to the values of completely different database columns in the above query.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-expressions"></a>11.8.&nbsp;Expressions</h2></div></div><div></div></div><p>
            Expressions allowed in the <tt class="literal">where</tt> clause include
            most of the kind of things you could write in SQL:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    mathematical operators <tt class="literal">+, -, *, /</tt>
                </p></li><li><p>
                    binary comparison operators <tt class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</tt>
                </p></li><li><p>
                    logical operations <tt class="literal">and, or, not</tt>
                </p></li><li><p>
                    string concatenation ||
                </p></li><li><p>
                    SQL scalar functions like <tt class="literal">upper()</tt> and
                    <tt class="literal">lower()</tt>
                </p></li><li><p>
                    Parentheses <tt class="literal">( )</tt> indicate grouping
                </p></li><li><p>
                    <tt class="literal">in</tt>,
                    <tt class="literal">between</tt>,
                    <tt class="literal">is null</tt>
                </p></li><li><p>
                    JDBC IN parameters <tt class="literal">?</tt>
                </p></li><li><p>
                    named parameters <tt class="literal">:name</tt>, <tt class="literal">:start_date</tt>, <tt class="literal">:x1</tt>
                </p></li><li><p>
                    SQL literals <tt class="literal">'foo'</tt>, <tt class="literal">69</tt>, <tt class="literal">'1970-01-01 10:00:01.0'</tt>
                </p></li><li><p>
                    Java <tt class="literal">public static final</tt> constants <tt class="literal">eg.Color.TABBY</tt>
                </p></li></ul></div><p>
            <tt class="literal">in</tt> and <tt class="literal">between</tt> may be used as follows:
        </p><pre class="programlisting">from eg.DomesticCat cat where cat.name between 'A' and 'B'

from eg.DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            and the negated forms may be written
        </p><pre class="programlisting">from eg.DomesticCat cat where cat.name not between 'A' and 'B'

from eg.DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            Likewise, <tt class="literal">is null</tt> and <tt class="literal">is not null</tt> may be used to test 
            for null values.
        </p><p>
            Booleans may be easily used in expressions by declaring HQL query substitutions in Hibernate
            configuration:
        </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>
            This will replace the keywords <tt class="literal">true</tt> and <tt class="literal">false</tt> with the
            literals <tt class="literal">1</tt> and <tt class="literal">0</tt> in the translated SQL from this HQL:
        </p><pre class="programlisting">from eg.Cat cat where cat.alive = true</pre><p>
            You may test the size of a collection with the special property <tt class="literal">size</tt>, or
            the special <tt class="literal">size()</tt> function.
        </p><pre class="programlisting">from eg.Cat cat where cat.kittens.size &gt; 0

from eg.Cat cat where size(cat.kittens) &gt; 0</pre><p>
            For indexed collections, you may refer to the minimum and maximum indices using
            <tt class="literal">minIndex</tt> and <tt class="literal">maxIndex</tt>. Similarly, you may refer to the
            minimum and maximum elements of a collection of basic type using <tt class="literal">minElement</tt> 
            and <tt class="literal">maxElement</tt>.
        </p><pre class="programlisting">from Calendar cal where cal.holidays.maxElement &gt; current date</pre><p>
            There are also functional forms (which, unlike the constructs above, are not case sensitive):
        </p><pre class="programlisting">from Order order where maxindex(order.items) &gt; 100

from Order order where minelement(order.items) &gt; 10000</pre><p>
            The SQL functions <tt class="literal">any, some, all, exists, in</tt> are supported when passed the element 
            or index set of a collection (<tt class="literal">elements</tt> and <tt class="literal">indices</tt> functions)
            or the result of a subquery (see below).
        </p><pre class="programlisting">select mother from eg.Cat as mother, eg.Cat as kit
where kit in elements(foo.kittens)

select p from eg.NameList list, eg.Person p
where p.name = some elements(list.names)

from eg.Cat cat where exists elements(cat.kittens)

from eg.Player p where 3 &gt; all elements(p.scores)

from eg.Show show where 'fizard' in indices(show.acts)</pre><p>
            Note that these constructs - <tt class="literal">size</tt>, <tt class="literal">elements</tt>,
            <tt class="literal">indices</tt>, <tt class="literal">minIndex</tt>, <tt class="literal">maxIndex</tt>,
            <tt class="literal">minElement</tt>, <tt class="literal">maxElement</tt> - have certain usage 
            restrictions:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    in a <tt class="literal">where</tt> clause: only for databases with subselects
                </p></li><li><p>
                    in a <tt class="literal">select</tt> clause: only <tt class="literal">elements</tt> and 
                    <tt class="literal">indices</tt> make sense
                </p></li></ul></div><p>
            Elements of indexed collections (arrays, lists, maps) may be referred to by
            index (in a where clause only):
        </p><pre class="programlisting">from Order order where order.items[0].id = 1234

select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar

select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11

select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>
            The expression inside <tt class="literal">[]</tt> may even be an arithmetic expression.
        </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>
            HQL also provides the built-in <tt class="literal">index()</tt> function, for elements of
            a one-to-many association or collection of values.
        </p><pre class="programlisting">select item, index(item) from Order order 
    join order.items item
where index(item) &lt; 5</pre><p>
            Scalar SQL functions supported by the underlying database may be used
        </p><pre class="programlisting">from eg.DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>
            If you are not yet convinced by all this, think how much longer and less readable the 
            following query would be in SQL:
        </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p>
            <span class="emphasis"><em>Hint:</em></span> something like
        </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-ordering"></a>11.9.&nbsp;The order by clause</h2></div></div><div></div></div><p>
            The list returned by a query may be ordered by any property of a returned class or components:
        </p><pre class="programlisting">from eg.DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>
            The optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt> indicate ascending or descending order 
            respectively.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-grouping"></a>11.10.&nbsp;The group by clause</h2></div></div><div></div></div><p>
            A query that returns aggregate values may be grouped by any property of a returned class or components:
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from eg.Cat cat
group by cat.color

select foo.id, avg( elements(foo.names) ), max( indices(foo.names) ) 
from eg.Foo foo
group by foo.id</pre><p>
            Note: You may use the <tt class="literal">elements</tt> and <tt class="literal">indices</tt> constructs
            inside a select clause, even on databases with no subselects.
        </p><p>
            A <tt class="literal">having</tt> clause is also allowed.
        </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from eg.Cat cat
group by cat.color 
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>
            SQL functions and aggregate functions are allowed in the <tt class="literal">having</tt>
            and <tt class="literal">order by</tt> clauses, if supported by the underlying database (ie.
            not in MySQL).
        </p><pre class="programlisting">select cat
from eg.Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>
            Note that neither the <tt class="literal">group by</tt> clause nor the
            <tt class="literal">order by</tt> clause may contain arithmetic expressions.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-subqueries"></a>11.11.&nbsp;Subqueries</h2></div></div><div></div></div><p>
            For databases that support subselects, Hibernate supports subqueries within queries. A subquery must
            be surrounded by parentheses (often by an SQL aggregate function call). Even correlated subqueries
            (subqueries that refer to an alias in the outer query) are allowed.
        </p><pre class="programlisting">from eg.Cat as fatcat 
where fatcat.weight &gt; ( 
    select avg(cat.weight) from eg.DomesticCat cat 
)

from eg.DomesticCat as cat 
where cat.name = some ( 
    select name.nickName from eg.Name as name 
)
    
from eg.Cat as cat 
where not exists ( 
    from eg.Cat as mate where mate.mate = cat 
)

from eg.DomesticCat as cat 
where cat.name not in ( 
    select name.nickName from eg.Name as name 
)</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-examples"></a>11.12.&nbsp;HQL examples</h2></div></div><div></div></div><p>
            Hibernate queries can be quite powerful and complex. In fact, the power of the query language
            is one of Hibernate's main selling points. Here are some example queries very similar to queries
            that I used on a recent project. Note that most queries you will write are much simpler than these!
        </p><p>
            The following query returns the order id, number of items and total value of the order for all 
            unpaid orders for a particular customer and given minimum total value, ordering the results by 
            total value. In determining the prices, it uses the current catalog. The resulting SQL query, 
            against the <tt class="literal">ORDER</tt>, <tt class="literal">ORDER_LINE</tt>, <tt class="literal">PRODUCT</tt>,
            <tt class="literal">CATALOG</tt> and <tt class="literal">PRICE</tt> tables has four inner joins and an
            (uncorrelated) subselect.
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate 
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            What a monster! Actually, in real life, I'm not very keen on subqueries, so my query was 
            really more like this:
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>
            The next query counts the number of payments in each status, excluding all payments in the
            <tt class="literal">AWAITING_APPROVAL</tt> status where the most recent status change was made by the 
            current user. It translates to an SQL query with two inner joins and a correlated subselect 
            against the <tt class="literal">PAYMENT</tt>, <tt class="literal">PAYMENT_STATUS</tt> and 
            <tt class="literal">PAYMENT_STATUS_CHANGE</tt> tables.
        </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment 
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = ( 
            select max(change.timeStamp) 
            from PaymentStatusChange change 
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            If I would have mapped the <tt class="literal">statusChanges</tt> collection as a list, instead of a set, 
            the query would have been much simpler to write.
        </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>
            The next query uses the MS SQL Server <tt class="literal">isNull()</tt> function to return all
            the accounts and unpaid payments for the organization to which the current user belongs.
            It translates to an SQL query with three inner joins, an outer join and a subselect against 
            the <tt class="literal">ACCOUNT</tt>, <tt class="literal">PAYMENT</tt>, <tt class="literal">PAYMENT_STATUS</tt>,
            <tt class="literal">ACCOUNT_TYPE</tt>, <tt class="literal">ORGANIZATION</tt> and 
            <tt class="literal">ORG_USER</tt> tables.
        </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>
            For some databases, we would need to do away with the (correlated) subselect.
        </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-tipstricks"></a>11.13.&nbsp;Tips &amp; Tricks</h2></div></div><div></div></div><p>
            You can count the number of query results without actually returning them:
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue()</pre><p>
            To order a result by the size of a collection, use the following query:
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr 
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>
            If your database supports subselects, you can place a condition upon selection
            size in the where clause of your query:
        </p><pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre><p>
            If your database doesn't support subselects, use the following query:
        </p><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre><p>
            As this solution can't return a <tt class="literal">User</tt> with zero messages
            because of the inner join, the following form is also useful:
        </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>
            Properties of a JavaBean can be bound to named query parameters:
        </p><pre class="programlisting">Query q = s.createQuery("from foo in class Foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();</pre><p>
            Collections are pageable by using the <tt class="literal">Query</tt> interface with a filter:
        </p><pre class="programlisting">Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre><p>
            Collection elements may be ordered or grouped using a query filter:
        </p><pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre><p>
            You can find the size of a collection without initializing it:
        </p><pre class="programlisting">( (Integer) session.iterate("select count(*) from ....").next() ).intValue();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querycriteria"></a>Chapter&nbsp;12.&nbsp;Criteria Queries</h2></div></div><div></div></div><p>
        Hibernate now features an intuitive, extensible criteria query API. For now, this API
        is less powerful and than the more mature HQL query facilities. In particular, criteria
        queries do not support projection or aggregation.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-creating"></a>12.1.&nbsp;Creating a <tt class="literal">Criteria</tt> instance</h2></div></div><div></div></div><p>
            The interface <tt class="literal">net.sf.hibernate.Criteria</tt> represents a query against
            a particular persistent class. The <tt class="literal">Session</tt> is a factory for
            <tt class="literal">Criteria</tt> instances.
        </p><pre class="programlisting">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-narrowing"></a>12.2.&nbsp;Narrowing the result set</h2></div></div><div></div></div><p>
            An individual query criterion is an instance of the interface
            <tt class="literal">net.sf.hibernate.expression.Criterion</tt>. The class
            <tt class="literal">net.sf.hibernate.expression.Expression</tt> defines
            factory methods for obtaining certain built-in
            <tt class="literal">Criterion</tt> types.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .add( Expression.between("weight", minWeight, maxWeight) )
    .list();</pre><p>
            Expressions may be grouped logically.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .add( Expression.or(
        Expression.eq( "age", new Integer(0) ),
        Expression.isNull("age")
    ) )
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Expression.disjunction()
        .add( Expression.isNull("age") )
    	.add( Expression.eq("age", new Integer(0) ) )
    	.add( Expression.eq("age", new Integer(1) ) )
    	.add( Expression.eq("age", new Integer(2) ) )
    ) )
    .list();</pre><p>
            There are quite a range of built-in criterion types (<tt class="literal">Expression</tt>
            subclasses), but one that is especially useful lets you specify SQL directly.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.sql("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</pre><p>
            The <tt class="literal">{alias}</tt> placeholder with be replaced by the row alias
            of the queried entity.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-ordering"></a>12.3.&nbsp;Ordering the results</h2></div></div><div></div></div><p>
            You may order the results using <tt class="literal">net.sf.hibernate.expression.Order</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-associations"></a>12.4.&nbsp;Associations</h2></div></div><div></div></div><p>
            You may easily specify constraints upon related entities by navigating
            associations using <tt class="literal">createCriteria()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "F%")
    .createCriteria("kittens")
        .add( Expression.like("name", "F%")
    .list();</pre><p>
            note that the second <tt class="literal">createCriteria()</tt> returns a new
            instance of <tt class="literal">Criteria</tt>, which refers to the elements of
            the <tt class="literal">kittens</tt> collection.
        </p><p>
            The following, alternate form is useful in certain circumstances.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Expression.eqProperty("kt.name", "mt.name") )
    .list();</pre><p>
            (<tt class="literal">createAlias()</tt> does not create a new instance of
            <tt class="literal">Criteria</tt>.)
        </p><p>
            Note that the kittens collections held by the <tt class="literal">Cat</tt> instances
            returned by the previous two queries are <span class="emphasis"><em>not</em></span> pre-filtered
            by the criteria! If you wish to retrieve just the kittens that match the
            criteria, you must use <tt class="literal">returnMaps()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Expression.eq("name", "F%") )
    .returnMaps()
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-dynamicfetching"></a>12.5.&nbsp;Dynamic association fetching</h2></div></div><div></div></div><p>
            You may specify association fetching semantics at runtime using
            <tt class="literal">setFetchMode()</tt>.
        </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</pre><p>
            This query will fetch both <tt class="literal">mate</tt> and <tt class="literal">kittens</tt>
            by outer join.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-examples"></a>12.6.&nbsp;Example queries</h2></div></div><div></div></div><p>
            The class <tt class="literal">net.sf.hibernate.expression.Example</tt> allows
            you to construct a query criterion from a given instance.
        </p><pre class="programlisting">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</pre><p>
           Version properties, identifiers and associations are ignored. By default,
           null valued properties are excluded.
        </p><p>
           You can adjust how the <tt class="literal">Example</tt> is applied.
        </p><pre class="programlisting">Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</pre><p>
            You can even use examples to place criteria upon associated objects.
        </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querysql"></a>Chapter&nbsp;13.&nbsp;Native SQL Queries</h2></div></div><div></div></div><p>
        You may also express queries in the native SQL dialect of your database. This is useful if you
        want to utilize database specific features such as the CONNECT keyword in Oracle.
        This also allows for a cleaner migration path from a direct SQL/JDBC based application to 
        Hibernate.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-creating"></a>13.1.&nbsp;Creating a SQL based <tt class="literal">Query</tt></h2></div></div><div></div></div><p>
            SQL queries are exposed through the same <tt class="literal">Query</tt> interface, just like ordinary
            HQL queries. The only difference is the use of <tt class="literal">Session.createSQLQuery()</tt>.
        </p><pre class="programlisting">Query sqlQuery = sess.createSQLQuery("select {cat.*} from cats {cat}", "cat", Cat.class);
sqlQuery.setMaxResults(50);
List cats = sqlQuery.list();</pre><p>
            The three parameters provided to <tt class="literal">createSQLQuery()</tt> are:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            the SQL query string
        </p></li><li><p>
            a table alias name
        </p></li><li><p>
            the persistent class returned by the query
        </p></li></ul></div><p>
            The alias name is used inside the sql string to refer to the properties of the mapped class
            (in this case  <tt class="literal">Cat</tt>). You may retrieve multiple objects per row by supplying
            a <tt class="literal">String</tt> array of alias names and a <tt class="literal">Class</tt> array of
            corresponding classes.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-aliasreferences"></a>13.2.&nbsp;Alias and property references</h2></div></div><div></div></div><p>
            The <tt class="literal">{cat.*}</tt> notation used above is a shorthand for "all properties". You
            may even list the properties explicity, but you must let Hibernate provide SQL column aliases
            for each property. The placeholders for these column aliases are the property name qualified by
            the table alias. In the following example, we retrieve <tt class="literal">Cat</tt>s from a different
            table (<tt class="literal">cat_log</tt>) to the one declared in the mapping metadata. Notice that we
            may even use the property aliases in the where clause.
        </p><pre class="programlisting">String sql = "select cat.originalId as {cat.id}, "
    + "  cat.mateid as {cat.mate}, cat.sex as {cat.sex}, "
    + "  cat.weight*10 as {cat.weight}, cat.name as {cat.name}"
    + "     from cat_log cat where {cat.mate} = :catId"
List loggedCats = sess.createSQLQuery(sql, "cat", Cat.class)
    .setLong("catId", catId)
    .list();
</pre><p>
            <span class="emphasis"><em>Note:</em></span> if you list each property explicitly, you must include all
            properties of the class <span class="emphasis"><em>and its subclasses</em></span>!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-namedqueries"></a>13.3.&nbsp;Named SQL queries</h2></div></div><div></div></div><p>
            Named SQL queries may be defined in the mapping document and called in exactly the same way
            as a named HQL query.
        </p><pre class="programlisting">List people = sess.getNamedQuery("mySqlQuery")
    .setMaxResults(50)
    .list();</pre><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT {person}.NAME AS {person.name},
           {person}.AGE AS {person.age},
           {person}.SEX AS {person.sex}
    FROM PERSON {person} WHERE {person}.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapter&nbsp;14.&nbsp;Improving performance</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-collections"></a>14.1.&nbsp;Understanding Collection performance</h2></div></div><div></div></div><p>
            We've already spent quite some time talking about collections.
            In this section we will highlight a couple more issues about
            how collections behave at runtime.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-taxonomy"></a>14.1.1.&nbsp;Taxonomy</h3></div></div><div></div></div><p>Hibernate defines three basic kinds of collections:</p><div class="itemizedlist"><ul type="disc"><li><p>collections of values</p></li><li><p>one to many associations</p></li><li><p>many to many associations</p></li></ul></div><p>
                This classification distinguishes the various table and foreign key
                relationships but does not tell us quite everything we need to know
                about the relational model. To fully understand the relational structure
                and performance characteristics, we must also consider the structure of
                the primary key that is used by Hibernate to update or delete collection
                rows. This suggests the following classification:
            </p><div class="itemizedlist"><ul type="disc"><li><p>indexed collections</p></li><li><p>sets</p></li><li><p>bags</p></li></ul></div><p>
                All indexed collections (maps, lists, arrays) have a primary key consisting
                of the <tt class="literal">&lt;key&gt;</tt> and <tt class="literal">&lt;index&gt;</tt>
                columns. In this case collection updates are usually extremely efficient -
                the primary key may be efficiently indexed and a particular row may be efficiently
                located when Hibernate tries to update or delete it.
            </p><p>
                Sets have a primary key consisting of <tt class="literal">&lt;key&gt;</tt> and element
                columns. This may be less efficient for some types of collection element, particularly
                composite elements or large text or binary fields; the database may not be able to index
                a complex primary key as efficently.  On the other hand, for one to many or many to many
                associations, particularly in the case of synthetic identifiers, it is likely to be just
                as efficient. (Side-note: if you want <tt class="literal">SchemaExport</tt> to actually create
                the primary key of a <tt class="literal">&lt;set&gt;</tt> for you, you must declare all columns
                as <tt class="literal">not-null="true"</tt>.)
            </p><p>
                Bags are the worst case. Since a bag permits duplicate element values and has no
                index column, no primary key may be defined. Hibernate has no way of distinguishing
                between duplicate rows. Hibernate resolves this problem by completely removing
                (in a single <tt class="literal">DELETE</tt>) and recreating the collection whenever it
                changes. This might be very inefficient.
            </p><p>
                Note that for a one-to-many association, the "primary key" may not be the physical
                primary key of the database table - but even in this case, the above classification
                is still useful. (It still reflects how Hibernate "locates" individual rows of the
                collection.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficientupdate"></a>14.1.2.&nbsp;Lists, maps and sets are the most efficient collections to update</h3></div></div><div></div></div><p>
                From the discussion above, it should be clear that indexed collections
                and (usually) sets allow the most efficient operation in terms of adding,
                removing and updating elements.
            </p><p>
                There is, arguably, one more advantage that indexed collections have over sets for
                many to many associations or collections of values. Because of the structure of a
                <tt class="literal">Set</tt>, Hibernate doesn't ever <tt class="literal">UPDATE</tt> a row when
                an element is "changed". Changes to a <tt class="literal">Set</tt> always work via
                <tt class="literal">INSERT</tt> and <tt class="literal">DELETE</tt> (of individual rows). Once
                again, this consideration does not apply to one to many associations.
            </p><p>
                After observing that arrays cannot be lazy, we would conclude that lists, maps and sets
                are the most performant collection types. (With the caveat that a set might be less
                efficient for some collections of values.)
            </p><p>
                Sets are expected to be the most common kind of collection in Hibernate applications.
            </p><p>
                <span class="emphasis"><em>There is an undocumented feature in this release of Hibernate. The
                <tt class="literal">&lt;idbag&gt;</tt> mapping implements bag semantics for a collection
                of values or a many to many association and is more efficient that any other
                style of collection in this case!</em></span>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficentinverse"></a>14.1.3.&nbsp;Bags and lists are the most efficient inverse collections</h3></div></div><div></div></div><p>
                Just before you ditch bags forever, there is a particular case in which bags (and also lists)
                are much more performant than sets. For a collection with <tt class="literal">inverse="true"</tt>
                (the standard bidirectional one-to-many relationship idiom, for example) we can add elements
                to a bag or list without needing to initialize (fetch) the bag elements! This is because
                <tt class="literal">Collection.add()</tt> or <tt class="literal">Collection.addAll()</tt> must always
                return true for a bag or <tt class="literal">List</tt> (unlike a <tt class="literal">Set</tt>). This can
                make the following common code much faster.
            </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
    Child c = new Child();
    c.setParent(p);
    p.getChildren().add(c);  //no need to fetch the collection!
    sess.flush();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-oneshotdelete"></a>14.1.4.&nbsp;One shot delete</h3></div></div><div></div></div><p>
                Occasionally, deleting collection elements one by one can be extremely inefficient. Hibernate
                isn't completly stupid, so it knows not to do that in the case of an newly-empty collection
                (if you called <tt class="literal">list.clear()</tt>, for example). In this case, Hibernate will
                issue a single <tt class="literal">DELETE</tt> and we are done!
            </p><p>
                Suppose we add a single element to a collection of size twenty and then remove two elements.
                Hibernate will issue one <tt class="literal">INSERT</tt> statement and two <tt class="literal">DELETE</tt>
                statements (unless the collection is a bag). This is certainly desirable.
            </p><p>
                However, suppose that we remove eighteen elements, leaving two and then add thee new elements.
                There are two possible ways to proceed
            </p><div class="itemizedlist"><ul type="disc"><li><p>delete eighteen rows one by one and then insert three rows</p></li><li><p>remove the whole collection (in one SQL <tt class="literal">DELETE</tt>) and insert
                all five current elements (one by one)</p></li></ul></div><p>
                Hibernate isn't smart enough to know that the second option is probably quicker in this case.
                (And it would probably be undesirable for Hibernate to be that smart; such behaviour might
                confuse database triggers, etc.)
            </p><p>
                Fortunately, you can force this behaviour (ie. the second strategy) at any time by discarding
                (ie. dereferencing) the original collection and returning a newly instantiated collection with
                all the current elements. This can be very useful and powerful from time to time.
            </p></div></div><p>
        We have already shown how you can use lazy initialization for persistent collections
        in the chapter about collection mappings. A similar effect is achievable for ordinary object
        references, using CGLIB proxies. We have also mentioned how Hibernate caches persistent
        objects at the level of a <tt class="literal">Session</tt>. More aggressive caching strategies
        may be configured upon a class-by-class basis.
    </p><p>
        In the next section, we show you how to use these features, which may be used to
        achieve much higher performance, where necessary.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-proxies"></a>14.2.&nbsp;Proxies for Lazy Initialization</h2></div></div><div></div></div><p>
            Hibernate implements lazy initializing proxies for persistent objects using runtime
            bytecode enhancement (via the excellent CGLIB library).
        </p><p>
            The mapping file declares a class or interface to use as the proxy interface
            for that class. The recommended approach is to specify the class itself:
        </p><pre class="programlisting">&lt;class name="eg.Order" proxy="eg.Order"&gt;</pre><p>
            The runtime type of the proxies will be a subclass of <tt class="literal">Order</tt>. Note that
            the proxied class must implement a default constructor with at least package visibility.
        </p><p>
            There are some gotchas to be aware of when extending this approach to polymorphic
            classes, eg.
        </p><pre class="programlisting">&lt;class name="eg.Cat" proxy="eg.Cat"&gt;
    ......
    &lt;subclass name="eg.DomesticCat" proxy="eg.DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Firstly, instances of <tt class="literal">Cat</tt> will never be castable to 
            <tt class="literal">DomesticCat</tt>, even if the underlying instance is an
            instance of <tt class="literal">DomesticCat</tt>.
        </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>
            Secondly, it is possible to break proxy <tt class="literal">==</tt>.
        </p><pre class="programlisting">
Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
    (DomesticCat) session.load(DomesticCat.class, id);  // required new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>
            However, the situation is not quite as bad as it looks. Even though we now have two references
            to different proxy objects, the underlying instance will still be the same object:
        </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>
            Third, you may not use a CGLIB proxy for a <tt class="literal">final</tt> class or a class
            with any <tt class="literal">final</tt> methods.
        </p><p>
            Finally, if your persistent object acquires any resources upon instantiation (eg. in 
            initializers or default constructor), then those resources will also be acquired by
            the proxy. The proxy class is an actual subclass of the persistent class.
        </p><p>
            These problems are all due to fundamental limitations in Java's single inheritence model.
            If you wish to avoid these problems your persistent classes must each implement an interface 
            that declares its business methods. You should specify these interfaces in the mapping file. eg.
        </p><pre class="programlisting">&lt;class name="eg.Cat" proxy="eg.ICat"&gt;
    ......
    &lt;subclass name="eg.DomesticCat" proxy="eg.IDomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            where <tt class="literal">Cat</tt> implements the interface <tt class="literal">ICat</tt> and
            <tt class="literal">DomesticCat</tt> implements the interface <tt class="literal">IDomesticCat</tt>. Then 
            proxies for instances of <tt class="literal">Cat</tt> and <tt class="literal">DomesticCat</tt> may be returned 
            by <tt class="literal">load()</tt> or <tt class="literal">iterate()</tt>. (Note that <tt class="literal">find()</tt> 
            does not return proxies.)
        </p><pre class="programlisting">ICat cat = (ICat) session.load(Cat.class, catid);
Iterator iter = session.iterate("from cat in class eg.Cat where cat.name='fritz'");
ICat fritz = (ICat) iter.next();</pre><p>
            Relationships are also lazily initialized. This means you must declare any properties to be of 
            type <tt class="literal">ICat</tt>, not <tt class="literal">Cat</tt>.
        </p><p>
            Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">equals()</tt>, if the persistent class does not override
                    <tt class="literal">equals()</tt>
                </p></li><li><p>
                    <tt class="literal">hashCode()</tt>, if the persistent class does not override
                    <tt class="literal">hashCode()</tt>
                </p></li><li><p>
                    The identifier getter method
                </p></li></ul></div><p>
            Hibernate will detect persistent classes that override <tt class="literal">equals()</tt> or
            <tt class="literal">hashCode()</tt>.
        </p><p>
            Exceptions that occur while initializing a proxy are wrapped in a
            <tt class="literal">LazyInitializationException</tt>.
        </p><p>
            Sometimes we need to ensure that a proxy or collection is initialized before closing the
            <tt class="literal">Session</tt>. Of course, we can alway force initialization by calling 
            <tt class="literal">cat.getSex()</tt> or <tt class="literal">cat.getKittens().size()</tt>, for example.
            But that is confusing to readers of the code and is not convenient for generic code.
            The static methods <tt class="literal">Hibernate.initialize()</tt> and <tt class="literal">Hibernate.isInitialized()</tt>
            provide the application with a convenient way of working with lazyily initialized collections or
            proxies. <tt class="literal">Hibernate.initialize(cat)</tt> will force the initialization of a proxy,
            <tt class="literal">cat</tt>, as long as its <tt class="literal">Session</tt> is still open.
            <tt class="literal">Hibernate.initialize( cat.getKittens() )</tt> has a similar effect for the collection
            of kittens. 
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-cache"></a>14.3.&nbsp;The Second Level Cache</h2></div></div><div></div></div><p>
            A Hibernate <tt class="literal">Session</tt> is a transaction-level cache of persistent data. It is
            possible to configure a cluster or JVM-level (<tt class="literal">SessionFactory</tt>-level) cache on 
            a class-by-class and collection-by-collection basis. You may even plug in a clustered cache. Be 
            careful. Caches are never aware of changes made to the persistent store by another application 
            (though they may be configured to regularly expire cached data).
        </p><p>
            By default, Hibernate uses EHCache for JVM-level caching. (JCS support is now deprecated and will 
            be removed in a future version of Hibernate.) You may choose a different implementation by 
            specifying the name of a class that implements <tt class="literal">net.sf.hibernate.cache.CacheProvider</tt> 
            using the property <tt class="literal">hibernate.cache.provider_class</tt>.
        </p><div class="table"><a name="d0e8747"></a><p class="title"><b>Table&nbsp;14.1.&nbsp;Cache Providers</b></p><table summary="Cache Providers" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">Provider class</th><th align="left">Type</th><th align="left">Cluster Safe</th><th align="left">Query Cache Supported</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><tt class="literal">net.sf.hibernate.cache.HashtableCacheProvider</tt></td><td align="left">memory</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.EhCacheProvider</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.OSCacheProvider</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.SwarmCacheProvider</tt></td><td align="left">clustered (ip multicast)</td><td align="left">yes (clustered invalidation)</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left"><tt class="literal">net.sf.hibernate.cache.TreeCacheProvider</tt></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication)</td><td align="left">&nbsp;</td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-mapping"></a>14.3.1.&nbsp;Cache mappings</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;cache&gt;</tt> element of a class or collection mapping has the
                following form:
            </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span class="co">(1)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">usage</tt> specifies the caching strategy:
                            <tt class="literal">transactional</tt>,
                            <tt class="literal">read-write</tt>,
                            <tt class="literal">nonstrict-read-write</tt> or
                            <tt class="literal">read-only</tt>
                        </p></td></tr></table></div></div><p>
                Alternatively (preferrably?), you may specify <tt class="literal">&lt;class-cache&gt;</tt> and 
                <tt class="literal">&lt;collection-cache&gt;</tt> elements in <tt class="literal">hibernate.cfg.xml</tt>.
            </p><p>
                The <tt class="literal">usage</tt> attribute specifies a <span class="emphasis"><em>cache concurrency strategy</em></span>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readonly"></a>14.3.2.&nbsp;Strategy: read only</h3></div></div><div></div></div><p>
                If your application needs to read but never modify instances of a persistent class, a 
                <tt class="literal">read-only</tt> cache may be used. This is the simplest and best performing
                strategy. Its even perfectly safe for use in a cluster.
            </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readwrite"></a>14.3.3.&nbsp;Strategy: read/write</h3></div></div><div></div></div><p>
                If the application needs to update data, a <tt class="literal">read-write</tt> cache might be appropriate. 
                This cache strategy should never be used if serializable transaction isolation level is required. 
                If the cache is used in a JTA environment, you must specify the property 
                <tt class="literal">hibernate.transaction.manager_lookup_class</tt>, naming a strategy for obtaining the 
                JTA <tt class="literal">TransactionManager</tt>. In other environments, you should ensure that the transaction 
                is completed when <tt class="literal">Session.close()</tt> or <tt class="literal">Session.disconnect()</tt> is called. 
                If you wish to use this strategy in a cluster, you should ensure that the underlying cache implementation 
                supports locking. The built-in cache providers do <span class="emphasis"><em>not</em></span>.
            </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-nonstrict"></a>14.3.4.&nbsp;Strategy: nonstrict read/write</h3></div></div><div></div></div><p>
                If the application only occasionally needs to update data (ie. if it is extremely unlikely that two 
                transactions would try to update the same item simultaneously) and strict transaction isolation is
                not required, a <tt class="literal">nonstrict-read-write</tt> cache might be appropriate. If the cache is 
                used in a JTA environment, you must specify <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
                In other environments, you should ensure that the transaction is completed when 
                <tt class="literal">Session.close()</tt> or <tt class="literal">Session.disconnect()</tt> is called.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-transactional"></a>14.3.5.&nbsp;Strategy: transactional</h3></div></div><div></div></div><p>
                The <tt class="literal">transactional</tt> cache strategy provides support for fully transactional cache
                providers such as JBoss TreeCache. Such a cache may only be used in a JTA environment and you must 
                specify <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
            </p></div><p>
            None of the cache providers support all of the cache concurrency strategies. The following table shows
            which providers are compatible with which concurrency strategies.
        </p><div class="table"><a name="d0e8940"></a><p class="title"><b>Table&nbsp;14.2.&nbsp;Cache Concurrency Strategy Support</b></p><table summary="Cache Concurrency Strategy Support" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left">yes</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td><td align="left">yes</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-sessioncache"></a>14.4.&nbsp;Managing the <tt class="literal">Session</tt> Cache</h2></div></div><div></div></div><p>
            Whenever you pass an object to <tt class="literal">save()</tt>, <tt class="literal">update()</tt>
            or <tt class="literal">saveOrUpdate()</tt> and whenever you retrieve an object using 
            <tt class="literal">load()</tt>, <tt class="literal">find()</tt>, <tt class="literal">iterate()</tt>,
            or <tt class="literal">filter()</tt>, that object is added to the internal cache of the
            <tt class="literal">Session</tt>. When <tt class="literal">flush()</tt> is subsequently called,
            the state of that object will be synchronized with the database. If you do not want
            this synchronization to occur or if you are processing a huge number of objects and
            need to manage memory efficiently, the <tt class="literal">evict()</tt> method may be
            used to remove the object and its collections from the cache.
        </p><pre class="programlisting">Iterator cats = sess.iterate("from eg.Cat as cat"); //a huge result set
while ( cats.hasNext() ) {
    Cat cat = (Cat) iter.next();
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p>
			Hibernate will evict associated entities automatically if the association is mapped
			with <tt class="literal">cascade="all"</tt> or <tt class="literal">cascade="all-delete-orphan"</tt>.
		</p><p>
            The <tt class="literal">Session</tt> also provides a <tt class="literal">contains()</tt> method
            to determine if an instance belongs to the session cache.
        </p><p>
            To completely evict all objects from the session cache, call <tt class="literal">Session.clear()</tt>
        </p><p>
            For the second-level cache, there are methods defined on <tt class="literal">SessionFactory</tt> for 
            evicting the cached state of an instance, entire class, collection instance or entire collection 
            role.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-querycache"></a>14.5.&nbsp;The Query Cache</h2></div></div><div></div></div><p>
            Query result sets may also be cached. This is only useful for queries that are run
            frequently with the same parameters. To use the query cache you must first enable it
            by setting the property <tt class="literal">hibernate.cache.use_query_cache=true</tt>. This
            causes the creation of two cache regions - one holding cached query result sets 
            (<tt class="literal">net.sf.hibernate.cache.QueryCache</tt>), the other holding timestamps 
            of most recent updates to queried tables 
            (<tt class="literal">net.sf.hibernate.cache.UpdateTimestampsCache</tt>). Note that the query
            cache does not cache the state of any entities in the result set; it caches only 
            identifier values and results of value type. So the query cache is usually used in
            conjunction with the second-level cache.
        </p><p>
            Most queries do not benefit from caching, so by default queries are not cached. To
            enable caching, call <tt class="literal">Query.setCacheable(true)</tt>. This call allows
            the query to look for existing cache results or add its results to the cache when
            it is executed.
        </p><p>
            If you require fine-grained control over query cache expiration policies, you may
            specify a named cache region for a particular query by calling 
            <tt class="literal">Query.setCacheRegion()</tt>.
        </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>
            If the query should force a refresh of its query cache region, you may call
            <tt class="literal">Query.setForceCacheRefresh()</tt> to <tt class="literal">true</tt>.
            This is particularly useful in cases where underlying data may have been updated
            via a seperate process (i.e., not modified through Hibernate) and allows the
            application to selectively refresh the query cache regions based on its
            knowledge of those events. This is an alternative to eviction of a query
            cache region. If you need fine-grained refresh control for many queries, use
            this function instead of a new region for each query.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="toolsetguide"></a>Chapter&nbsp;15.&nbsp;Toolset Guide</h2></div></div><div></div></div><p>
        Roundtrip engineering with Hibernate is possible using a set of commandline tools 
        maintained as part of the Hibernate project, along with Hibernate support built into
        XDoclet, Middlegen and AndroMDA.
    </p><p>
        The Hibernate main package comes bundled with the most important tool (it can even
        be used from "inside" Hibernate on-the-fly):
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            DDL schema generation from a mapping file
            (aka <tt class="literal">SchemaExport</tt>, <tt class="literal">hbm2ddl</tt>)
        </p></li></ul></div><p>
        Other tools directly provided by the Hibernate project are delivered with a separate
        package, <span class="emphasis"><em>Hibernate Extensions</em></span>. This package includes tools for
        the following tasks:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            Java source generation from a mapping file (aka <tt class="literal">CodeGenerator</tt>,
            <tt class="literal">hbm2java</tt>)
        </p></li><li><p>
            mapping file generation from compiled Java classes or from
            Java source with XDoclet markup (aka <tt class="literal">MapGenerator</tt>,
            <tt class="literal">class2hbm</tt>)
        </p></li></ul></div><p>
        There's actually another utitily living in Hibernate Extensions: <tt class="literal">ddl2hbm</tt>.
        It is considered deprecated and will no longer be maintained, Middlegen does a better job
        for the same task.
    </p><p>
        Third party tools with Hibernate support are:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            Middlegen (mapping file generation from an existing database schema)
        </p></li><li><p>
            AndroMDA (MDA (Model-Driven Architecture) approach generating code for
            persistent classes from UML diagrams and their XML/XMI representation)
        </p></li></ul></div><p>
        These 3rd party tools are not documented in this reference. Please refer to the Hibernate
        website for up-to-date information (a snapshot of the site is included in the Hibernate
        main package).
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s1"></a>15.1.&nbsp;Schema Generation</h2></div></div><div></div></div><p>
            DDL may be generated from your mapping files by a command line utility. A batch file
            is located in the <tt class="literal">hibernate-x.x.x/bin</tt> directory of the core
            Hibernate package.
        </p><p>
            The generated schema include referential integrity constraints (primary and foreign keys) for entity
            and collection tables. Tables and sequences are also created for mapped identifier generators.
        </p><p>
            You <span class="emphasis"><em>must</em></span> specify a SQL <tt class="literal">Dialect</tt> via the 
            <tt class="literal">hibernate.dialect</tt> property when using this tool.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-2"></a>15.1.1.&nbsp;Customizing the schema</h3></div></div><div></div></div><p>
                Many Hibernate mapping elements define an optional attribute named <tt class="literal">length</tt>. You may set 
                the length of a column with this attribute. (Or, for numeric/decimal data types, the precision.)
            </p><p>
                Some tags also accept a <tt class="literal">not-null</tt> attribute (for generating a <tt class="literal">NOT NULL</tt>
                constraint on table columns) and a <tt class="literal">unique</tt> attribute (for generating <tt class="literal">UNIQUE</tt>
                constraint on table columns).
            </p><p>
                Some tags accept an <tt class="literal">index</tt> attribute for specifying the
                name of an index for that column. A <tt class="literal">unique-key</tt> attribute
                can be used to group columns in a single unit key constraint. Currently, the
                specified value of the <tt class="literal">unique-key</tt> attribute is
                <span class="emphasis"><em>not</em></span> used to name the constraint, only to group the
                columns in the mapping file.
            </p><p>
                Examples:
            </p><pre class="programlisting">&lt;property name="foo" type="string" length="64" not-null="true"/&gt;

&lt;many-to-one name="bar" foreign-key="fk_foo_bar" not-null="true"/&gt;

&lt;element column="serial_number" type="long" not-null="true" unique="true"/&gt;</pre><p>
                Alternatively, these elements also accept a child <tt class="literal">&lt;column&gt;</tt> element. This is
                particularly useful for multi-column types:
            </p><pre class="programlisting">&lt;property name="foo" type="string"&gt;
    &lt;column name="foo" length="64" not-null="true" sql-type="text"/&gt;
&lt;/property&gt;

&lt;property name="bar" type="my.customtypes.MultiColumnType"/&gt;
    &lt;column name="fee" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fi" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fo" not-null="true" index="bar_idx"/&gt;
&lt;/property&gt;</pre><p>
                The <tt class="literal">sql-type</tt> attribute allows the user to override the default mapping
                of Hibernate type to SQL datatype.
            </p><p>
                The <tt class="literal">check</tt> attribute allows you to specify a check constraint.
            </p><pre class="programlisting">&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;

&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class&gt;</pre><div class="table"><a name="schemattributes-summary"></a><p class="title"><b>Table&nbsp;15.1.&nbsp;Summary</b></p><table summary="Summary" border="1"><colgroup><col><col></colgroup><thead><tr><th>Attribute</th><th>Values</th><th>Interpretation</th></tr></thead><tbody><tr><td><tt class="literal">length</tt></td><td>number</td><td>column length/decimal precision</td></tr><tr><td><tt class="literal">not-null</tt></td><td><tt class="literal">true|false</tt></td><td>specfies that the column should be non-nullable</td></tr><tr><td><tt class="literal">unique</tt></td><td><tt class="literal">true|false</tt></td><td>specifies that the column should have a unique constraint</td></tr><tr><td><tt class="literal">index</tt></td><td><tt class="literal">index_name</tt></td><td>specifies the name of a (multi-column) index</td></tr><tr><td><tt class="literal">unique-key</tt></td><td><tt class="literal">unique_key_name</tt></td><td>specifies the name of a multi-column unique constraint</td></tr><tr><td><tt class="literal">foreign-key</tt></td><td><tt class="literal">foreign_key_name</tt></td><td>
                                specifies the name of the foreign key constraint generated
                                for an association
                            </td></tr><tr><td><tt class="literal">sql-type</tt></td><td><tt class="literal">column_type</tt></td><td>
                                overrides the default column type (attribute of 
                                <tt class="literal">&lt;column&gt;</tt> element only)
                            </td></tr><tr><td><tt class="literal">check</tt></td><td>SQL expression</td><td>
                                create an SQL check constraint on either column or table
                            </td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-3"></a>15.1.2.&nbsp;Running the tool</h3></div></div><div></div></div><p>
                The <tt class="literal">SchemaExport</tt> tool writes a DDL script to standard out and/or
                executes the DDL statements.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>hibernate_classpaths</em></span>
                <tt class="literal">net.sf.hibernate.tool.hbm2ddl.SchemaExport</tt> <span class="emphasis"><em>options mapping_files</em></span>
            </p><div class="table"><a name="d0e9356"></a><p class="title"><b>Table&nbsp;15.2.&nbsp;<tt class="literal">SchemaExport</tt> Command Line Options</b></p><table summary="SchemaExport Command Line Options" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>don't output the script to stdout</td></tr><tr><td><tt class="literal">--drop</tt></td><td>only drop the tables</td></tr><tr><td><tt class="literal">--text</tt></td><td>don't export to the database</td></tr><tr><td><tt class="literal">--output=my_schema.ddl</tt></td><td>output the ddl script to a file</td></tr><tr><td><tt class="literal">--config=hibernate.cfg.xml</tt></td><td>read Hibernate configuration from an XML file</td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>read database properties from a file</td></tr><tr><td><tt class="literal">--format</tt></td><td>format the generated SQL nicely in the script</td></tr><tr><td><tt class="literal">--delimiter=x</tt></td><td>set an end of line delimiter for the script</td></tr></tbody></table></div><p>
                You may even embed <tt class="literal">SchemaExport</tt> in your application:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-4"></a>15.1.3.&nbsp;Properties</h3></div></div><div></div></div><p>
                Database properties may be specified
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>as system properties with <tt class="literal">-D</tt><span class="emphasis"><em>&lt;property&gt;</em></span></p></li><li><p>in <tt class="literal">hibernate.properties</tt></p></li><li><p>in a named properties file with <tt class="literal">--properties</tt></p></li></ul></div><p>
                The needed properties are:
            </p><div class="table"><a name="d0e9451"></a><p class="title"><b>Table&nbsp;15.3.&nbsp;SchemaExport Connection Properties</b></p><table summary="SchemaExport Connection Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td>jdbc driver class</td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td>jdbc url</td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td>database user</td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td>user password</td></tr><tr><td><tt class="literal">hibernate.dialect</tt></td><td>dialect</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-5"></a>15.1.4.&nbsp;Using Ant</h3></div></div><div></div></div><p>
                You can call <tt class="literal">SchemaExport</tt> from your Ant build script:
            </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="net.sf.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-6"></a>15.1.5.&nbsp;Incremental schema updates</h3></div></div><div></div></div><p>
                The <tt class="literal">SchemaUpdate</tt> tool will update an existing schema with "incremental" changes.
                Note that <tt class="literal">SchemaUpdate</tt> depends heavily upon the JDBC metadata API, so it will
                not work with all JDBC drivers.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>hibernate_classpaths</em></span>
                <tt class="literal">net.sf.hibernate.tool.hbm2ddl.SchemaUpdate</tt> <span class="emphasis"><em>options mapping_files</em></span>
            </p><div class="table"><a name="d0e9528"></a><p class="title"><b>Table&nbsp;15.4.&nbsp;<tt class="literal">SchemaUpdate</tt> Command Line Options</b></p><table summary="SchemaUpdate Command Line Options" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>don't output the script to stdout</td></tr><tr><td><tt class="literal">--properties=hibernate.properties</tt></td><td>read database properties from a file</td></tr></tbody></table></div><p>
                You may embed <tt class="literal">SchemaUpdate</tt> in your application:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-7"></a>15.1.6.&nbsp;Using Ant for incremental schema updates</h3></div></div><div></div></div><p>
                You can call <tt class="literal">SchemaUpdate</tt> from the Ant script:
            </p><pre class="programlisting">&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="net.sf.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s2"></a>15.2.&nbsp;Code Generation</h2></div></div><div></div></div><p>
            The Hibernate code generator may be used to generate skeletal Java implementation classes
            from a Hibernate mapping file. This tool is included in the Hibernate Extensions package
            (a seperate download).
        </p><p>
            <tt class="literal">hbm2java</tt> parses the mapping files and generates fully working Java
            source files from these. Thus with <tt class="literal">hbm2java</tt> one could "just" provide the
            <tt class="literal">.hbm</tt> files, and then don't worry about hand-writing/coding the Java files.
        </p><p>
            <tt class="literal">java -cp</tt> <span class="emphasis"><em>hibernate_classpaths</em></span>
            <tt class="literal">net.sf.hibernate.tool.hbm2java.CodeGenerator</tt> <span class="emphasis"><em> options
            mapping_files</em></span>
        </p><div class="table"><a name="d0e9602"></a><p class="title"><b>Table&nbsp;15.5.&nbsp;Code Generator Command Line Options</b></p><table summary="Code Generator Command Line Options" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--output=</tt><span class="emphasis"><em>output_dir</em></span></td><td>root directory for generated code</td></tr><tr><td><tt class="literal">--config=</tt><span class="emphasis"><em>config_file</em></span></td><td>optional file for configuring hbm2java</td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-1"></a>15.2.1.&nbsp;The config file (optional)</h3></div></div><div></div></div><p>
                The config file provides for a way to specify multiple "renderers" for the source code
                and to declare <tt class="literal">&lt;meta&gt;</tt> attributes that is "global" in scope. See
                more about this in the <tt class="literal">&lt;meta&gt;</tt> attribute section.
            </p><pre class="programlisting">&lt;codegen&gt;
    &lt;meta attribute="implements"&gt;codegen.test.IAuditable&lt;/meta&gt;
    &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt;
    &lt;generate
        package="autofinders.only"
        suffix="Finder"
        renderer="net.sf.hibernate.tool.hbm2java.FinderRenderer"/&gt;
&lt;/codegen&gt;</pre><p>
                This config file declares a global meta attribute "implements" and specify two renderers, the
                default one (BasicRenderer) and a renderer that generates Finder's (See more in "Basic Finder
                generation" below).
            </p><p>
                The second renderer is provided with a package and suffix attribute.
            </p><p>
                The package attribute specifies that the generated source files from this renderer should be
                placed here instead of the package scope specified in the <tt class="literal">.hbm</tt> files.
            </p><p>
                The suffix attribute specifies the suffix for generated files. E.g. here a file named
                <tt class="literal">Foo.java</tt> would be <tt class="literal">FooFinder.java</tt> instead.
            </p><p>
              It is also possible to send down arbitrary parameters to the renders by adding <tt class="literal">&lt;param&gt;</tt> attributes
              to the <tt class="literal">&lt;generate&gt;</tt> elements.
            </p><p>
              hbm2java currently has support for one such parameter,
              namely
              <tt class="literal">generate-concrete-empty-classes</tt> which
              informs the BasicRenderer to only generate empty
              concrete classes that extends a base class for all your
              classes. The following config.xml example illustrate
              this feature
            </p><pre class="programlisting">
            &lt;codegen&gt;
              &lt;generate prefix="Base" renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt; 
              &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"&gt;
                &lt;param name="generate-concrete-empty-classes"&gt;true&lt;/param&gt;
                &lt;param name="baseclass-prefix"&gt;Base&lt;/param&gt;
              &lt;/generate&gt;
            &lt;/codegen&gt;</pre><p>
              Notice that this config.xml configure 2 (two)
              renderers. One that generates the Base classes, and a
              second one that just generates empty concrete classes.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-2"></a>15.2.2.&nbsp;The <tt class="literal">meta</tt> attribute</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;meta&gt;</tt> tag is a simple way of annotating the <tt class="literal">hbm.xml</tt>
                with information, so tools have a natural place to store/read information that is not directly related
                to the Hibernate core.
            </p><p>
                You can use the <tt class="literal">&lt;meta&gt;</tt> tag to tell <tt class="literal">hbm2java</tt> to only
                generate "protected" setters, have classes always implement a certain set of interfaces or
                even have them extend a certain base class and even more.
            </p><p>
                The following example:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;meta attribute="class-description"&gt;
        Javadoc for the Person class
        @author Frodo
    &lt;/meta&gt;
    &lt;meta attribute="implements"&gt;IAuditable&lt;/meta&gt;
    &lt;id name="id" type="long"&gt;
        &lt;meta attribute="scope-set"&gt;protected&lt;/meta&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" type="string"&gt;
        &lt;meta attribute="field-description"&gt;The name of the person&lt;/meta&gt;
    &lt;/property&gt;
&lt;/class&gt;</pre><p>
                will produce something like the following (code shortened for better understanding). Notice the
                Javadoc comment and the protected set methods:
            </p><pre class="programlisting">// default package

import java.io.Serializable;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.commons.lang.builder.ToStringBuilder;

/** 
 *         Javadoc for the Person class
 *         @author Frodo
 *     
 */
public class Person implements Serializable, IAuditable {

    /** identifier field */
    public Long id;

    /** nullable persistent field */
    public String name;

    /** full constructor */
    public Person(java.lang.String name) {
        this.name = name;
    }

    /** default constructor */
    public Person() {
    }

    public java.lang.Long getId() {
        return this.id;
    }

    protected void setId(java.lang.Long id) {
        this.id = id;
    }

    /** 
     * The name of the person
     */
    public java.lang.String getName() {
        return this.name;
    }

    public void setName(java.lang.String name) {
        this.name = name;
    }

}</pre><div class="table"><a name="d0e9708"></a><p class="title"><b>Table&nbsp;15.6.&nbsp;Supported meta tags</b></p><table summary="Supported meta tags" border="1"><colgroup><col><col></colgroup><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">class-description</tt></td><td>inserted into the javadoc for classes</td></tr><tr><td><tt class="literal">field-description</tt></td><td>inserted into the javadoc for fields/properties</td></tr><tr><td><tt class="literal">interface</tt></td><td>If true an interface is generated instead of an class.</td></tr><tr><td><tt class="literal">implements</tt></td><td>interface the class should implement</td></tr><tr><td><tt class="literal">extends</tt></td><td>class the class should extend (ignored for subclasses)</td></tr><tr><td><tt class="literal">generated-class</tt></td><td>overrule the name of the actual class generated</td></tr><tr><td><tt class="literal">scope-class</tt></td><td>scope for class </td></tr><tr><td><tt class="literal">scope-set</tt></td><td>scope for setter method</td></tr><tr><td><tt class="literal">scope-get</tt></td><td>scope for getter method</td></tr><tr><td><tt class="literal">scope-field</tt></td><td>scope for actual field</td></tr><tr><td><tt class="literal">use-in-tostring</tt></td><td>include this property in the <tt class="literal">toString()</tt></td></tr><tr><td><tt class="literal">implement-equals</tt></td><td>include a <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt> method in this class.</td></tr><tr><td><tt class="literal">use-in-equals</tt></td><td>include this property in the <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt> method.</td></tr><tr><td><tt class="literal">bound</tt></td><td>add propertyChangeListener support for a property</td></tr><tr><td><tt class="literal">constrained</tt></td><td>bound + vetoChangeListener support for a property</td></tr><tr><td><tt class="literal">gen-property</tt></td><td>property will not be generated if false (use with care)</td></tr><tr><td><tt class="literal">property-type</tt></td><td>Overrides the default type of property. Use this with any tag's to specify the concrete type instead of just Object.</td></tr><tr><td><tt class="literal">class-code</tt></td><td>Extra code that will inserted at the end of the class</td></tr><tr><td><tt class="literal">extra-import</tt></td><td>Extra import that will inserted at the end of all other imports</td></tr><tr><td><tt class="literal">finder-method</tt></td><td>see "Basic finder generator" below</td></tr><tr><td><tt class="literal">session-method</tt></td><td>see "Basic finder generator" below</td></tr></tbody></table></div><p>
                Attributes declared via the <tt class="literal">&lt;meta&gt;</tt> tag are per default
                "inherited" inside an <tt class="literal">hbm.xml</tt> file.
            </p><p>
                What does that mean? It means that if you e.g want to have all your classes
                implement <tt class="literal">IAuditable</tt> then you just add an
                <tt class="literal">&lt;meta attribute="implements"&gt;IAuditable&lt;/meta&gt;</tt> in the top of
                the <tt class="literal">hbm.xml</tt> file, just after
                <tt class="literal">&lt;hibernate-mapping&gt;</tt>. Now all classes defined in that
                <tt class="literal">hbm.xml</tt> file will implement <tt class="literal">IAuditable</tt>!
                (Except if a class also has an "implements" meta attribute, because local specified
                meta tags always overrules/replaces any inherited meta tags).
            </p><p>
                Note: This applies to <span class="emphasis"><em>all</em></span> <tt class="literal">&lt;meta&gt;</tt>-tags.
                Thus it can also e.g. be used to specify that all fields should be declare protected,
                instead of the default private. This is done by adding <tt class="literal">&lt;meta
                attribute="scope-field"&gt;protected&lt;/meta&gt;</tt> at e.g. just under the
                <tt class="literal">&lt;class&gt;</tt> tag and all fields of that class will be protected.
            </p><p>
                To avoid having a <tt class="literal">&lt;meta&gt;</tt>-tag inherited then you can simply
                specify <tt class="literal">inherit="false"</tt> for the attribute, e.g.
                <tt class="literal">&lt;meta attribute="scope-class" inherit="false"&gt;public abstract&lt;/meta&gt;</tt>
                will restrict the "class-scope" to the current class, not the subclasses.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-3"></a>15.2.3.&nbsp;Basic finder generator</h3></div></div><div></div></div><p>
                It is now possible to have <tt class="literal">hbm2java</tt> generate basic finders for
                Hibernate properties. This requires two things in the <tt class="literal">hbm.xml</tt>
                files.
            </p><p>
                The first is an indication of which fields you want to generate finders for. You indicate
                that with a meta block inside a property tag such as:
            </p><pre class="programlisting">&lt;property name="name" column="name" type="string"&gt;
     &lt;meta attribute="finder-method"&gt;findByName&lt;/meta&gt;
&lt;/property&gt;</pre><p>
                The finder method name will be the text enclosed in the meta tags.
            </p><p>
                The second is to create a config file for hbm2java of the format:
            </p><pre class="programlisting">&lt;codegen&gt;
    &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt;
    &lt;generate suffix="Finder" renderer="net.sf.hibernate.tool.hbm2java.FinderRenderer"/&gt;
&lt;/codegen&gt;</pre><p>
                 And then use the param to <tt class="literal">hbm2java --config=xxx.xml</tt> where
                 <tt class="literal">xxx.xml</tt> is the config file you just created.
            </p><p>
                 An optional parameter is meta tag at the class level of the format:
            </p><pre class="programlisting">&lt;meta attribute="session-method"&gt;
    com.whatever.SessionTable.getSessionTable().getSession();
&lt;/meta&gt;</pre><p>
                 Which would be the way in which you get sessions if you use the
                 <span class="emphasis"><em>Thread Local Session</em></span> pattern (documented in the Design Patterns
                 area of the Hibernate website).
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s2-4"></a>15.2.4.&nbsp;Velocity based renderer/generator</h3></div></div><div></div></div><p>It is now possible to use velocity as an alternative rendering mechanism.
      The follwing config.xml shows how to configure hbm2java to use its velocity renderer.
      </p><pre class="programlisting">
    &lt;codegen&gt;
     &lt;generate renderer="net.sf.hibernate.tool.hbm2java.VelocityRenderer"&gt;
      &lt;param name="template"&gt;pojo.vm&lt;/param&gt;
     &lt;/generate&gt;
    &lt;/codegen&gt;</pre><p>
        The parameter named <tt class="literal">template</tt> is a resource path to the velocity macro file you want to use.
        This file must be available via the classpath for hbm2java. Thus remember to add the directory where pojo.vm
        is located to your ant task or shell script. (The default location is <tt class="literal">./tools/src/velocity</tt>)
      </p><p>
        Be aware that the current <tt class="literal">pojo.vm</tt> generates only the most basic parts of the java beans.
        It is not as complete and feature rich as the default renderer - primarily a lot of the <tt class="literal">meta</tt> tags
        are not supported.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s3"></a>15.3.&nbsp;Mapping File Generation</h2></div></div><div></div></div><p>
            A skeletal mapping file may be generated from compiled persistent classes using
            a command line utility called <tt class="literal">MapGenerator</tt>. This utility is part of 
            the Hibernate Extensions package.
        </p><p>
            The Hibernate mapping generator provides a mechanism to produce mappings from
            compiled classes. It uses Java reflection to find <span class="emphasis"><em>properties</em></span>
            and uses heuristics to guess an appropriate mapping from the property type.
            The generated mapping is intended to be a starting point only. There is no way to produce
            a full Hibernate mapping without extra input from the user. However, the tool does
            take away some of the repetitive "grunt" work involved in producing a mapping.
        </p><p>
            Classes are added to the mapping one at a time. The tool will reject
            classes that it judges are are not <span class="emphasis"><em>Hibernate persistable</em></span>.
        </p><p>
            To be <span class="emphasis"><em>Hibernate persistable</em></span> a class
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>must not be a primitive type</p></li><li><p>must not be an array</p></li><li><p>must not be an interface</p></li><li><p>must not be a nested class</p></li><li><p>must have a default (zero argument) constructor.</p></li></ul></div><p>
            Note that interfaces and nested classes actually are persistable by Hibernate, but
            this would not usually be intended by the user.
        </p><p>
            <tt class="literal">MapGenerator</tt> will climb the superclass chain of all added classes attempting
            to add as many Hibernate persistable superclasses as possible to the same database table.
            The search stops as soon as a property is found that has a name appearing on a list of
            <span class="emphasis"><em>candidate UID names</em></span>.
        </p><p>
            The default list of candidate UID property names is: <tt class="literal">uid</tt>, <tt class="literal">UID</tt>,
            <tt class="literal">id</tt>, <tt class="literal">ID</tt>, <tt class="literal">key</tt>, <tt class="literal">KEY</tt>,
            <tt class="literal">pk</tt>, <tt class="literal">PK</tt>.
        </p><p>
            Properties are discovered when there are two methods in the class, a setter and a getter, where the
            type of the setter's single argument is the same as the return type of the zero argument getter,
            and the setter returns <tt class="literal">void</tt>. Furthermore, the setter's name must start with the
            string <tt class="literal">set</tt> and either the getter's name starts with <tt class="literal">get</tt> or
            the getter's name starts with <tt class="literal">is</tt> and the type of the property is boolean. In
            either case, the remainder of their names must match. This matching portion is the name of
            the property, except that the initial character of the property name is made lower case if
            the second letter is lower case.
        </p><p>
            The rules for determining the database type of each property are as follows:
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    If the Java type is <tt class="literal">Hibernate.basic()</tt>, then the property is a
                    simple column of that type.
                </p></li><li><p>
                    For <tt class="literal">hibernate.type.Type</tt> custom types and <tt class="literal">PersistentEnum</tt>
                    a simple column is used as well.
                </p></li><li><p>
                    If the property type is an array, then a Hibernate array is used, and <tt class="literal">MapGenerator</tt>
                    attempts to reflect on the array element type.
                </p></li><li><p>
                    If the property has type <tt class="literal">java.util.List</tt>, <tt class="literal">java.util.Map</tt>, or
                    <tt class="literal">java.util.Set</tt>, then the corresponding Hibernate types are used, but
                    <tt class="literal">MapGenerator</tt> cannot further process the insides of these types.
                </p></li><li><p>
                    If the property's type is any other class, <tt class="literal">MapGenerator</tt> defers the decision
                    on the database representation until all classes have been processed. At this point, if the
                    class was discovered through the superclass search described above, then the property is
                    an <tt class="literal">many-to-one</tt> association. If the class has any properties, then it is
                    a <tt class="literal">component</tt>. Otherwise it is serializable, or not persistable.
                </p></li></ol></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s3-1"></a>15.3.1.&nbsp;Running the tool</h3></div></div><div></div></div><p>
                The tool writes XML mappings to standard out and/or to a file.
            </p><p>
                When invoking the tool you must place your compiled classes on the classpath.
            </p><p>
                <tt class="literal">java -cp </tt><span class="emphasis"><em>hibernate_and_your_class_classpaths</em></span>
                <tt class="literal">net.sf.hibernate.tool.class2hbm.MapGenerator</tt> <span class="emphasis"><em>options and
                classnames</em></span>
            </p><p>
                There are two modes of operation: command line or interactive.
            </p><p>
                The interactive mode is selected by providing the single command line argument
                <tt class="literal">--interact</tt>. This mode provides a prompt response console. Using it you
                can set the UID property name for each class using the <tt class="literal">uid=XXX</tt> command
                where <tt class="literal">XXX</tt> is the UID property name. Other command alternatives are simply
                a fully qualified class name, or the command done which emits the XML and terminates.
            </p><p>
                In command line mode the arguments are the options below interspersed with fully qualified
                class names of the classes to be processed. Most of the options are meant to be used
                multiple times; each use affects subsequently added classes.
            </p><div class="table"><a name="d0e10150"></a><p class="title"><b>Table&nbsp;15.7.&nbsp;MapGenerator Command Line Options</b></p><table summary="MapGenerator Command Line Options" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">--quiet</tt></td><td>don't output the O-R Mapping to stdout</td></tr><tr><td><tt class="literal">--setUID=uid</tt></td><td>set the list of candidate UIDs to the singleton uid</td></tr><tr><td><tt class="literal">--addUID=uid</tt></td><td>add uid to the front of the list of candidate UIDs</td></tr><tr><td><tt class="literal">--select=</tt><span class="emphasis"><em>mode</em></span></td><td>mode use select mode <span class="emphasis"><em>mode</em></span>(e.g.,
                            <span class="emphasis"><em>distinct</em></span> or <span class="emphasis"><em>all</em></span>) for subsequently
                            added classes</td></tr><tr><td><tt class="literal">--depth=&lt;small-int&gt;</tt></td><td>limit the depth of component data recursion for subsequently added classes</td></tr><tr><td><tt class="literal">--output=my_mapping.xml</tt></td><td>output the O-R Mapping to a file</td></tr><tr><td><span class="emphasis"><em>full.class.Name</em></span></td><td>add the class to the mapping</td></tr><tr><td><tt class="literal">--abstract=</tt><span class="emphasis"><em>full.class.Name</em></span></td><td>see below</td></tr></tbody></table></div><p>
                The abstract switch directs the map generator tool to ignore specific super classes so
                that classes with common inheritance are not mapped to one large table. For instance,
                consider these class hierarchies:
            </p><p>
                <tt class="literal">Animal--&gt;Mammal--&gt;Human</tt>
            </p><p>
                <tt class="literal">Animal--&gt;Mammal--&gt;Marsupial--&gt;Kangaroo</tt>
            </p><p>
                If the <tt class="literal">--abstract</tt>switch is <span class="emphasis"><em>not</em></span> used, all classes will
                be mapped as subclasses of <tt class="literal">Animal</tt>, resulting in one large table containing
                all the properties of all the classes plus a discriminator column to indicate which subclass is
                actually stored. If <tt class="literal">Mammal</tt> is marked as <tt class="literal">abstract</tt>,
                <tt class="literal">Human</tt> and <tt class="literal">Marsupial</tt> will be mapped to
                separate <tt class="literal">&lt;class&gt;</tt> declarations and stored in separate tables.
                <tt class="literal">Kangaroo</tt> will still be a subclass of <tt class="literal">Marsupial</tt>
                unless <tt class="literal">Marsupial</tt> is also marked as <tt class="literal">abstract</tt>.
            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-parentchild"></a>Chapter&nbsp;16.&nbsp;Example: Parent/Child</h2></div></div><div></div></div><p>
        One of the very first things that new users try to do with Hibernate is to model a parent / child type 
        relationship. There are two different approaches to this. For various reasons the most convenient 
        approach, especially for new users, is to model both <tt class="literal">Parent</tt> and <tt class="literal">Child</tt> 
        as entity classes with a <tt class="literal">&lt;one-to-many&gt;</tt> association from <tt class="literal">Parent</tt> 
        to <tt class="literal">Child</tt>. (The alternative approach is to declare the <tt class="literal">Child</tt> as a 
        <tt class="literal">&lt;composite-element&gt;</tt>.) Now, it turns out that default semantics of a one to many 
        association (in Hibernate) are much less close to the usual semantics of a parent / child relationship than 
        those of a composite element mapping. We will explain how to use a <span class="emphasis"><em>bidirectional one to many 
        association with cascades</em></span> to model a parent / child relationship efficiently and elegantly. It's 
        not at all difficult!
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-collections"></a>16.1.&nbsp;A note about collections</h2></div></div><div></div></div><p>
            Hibernate collections are considered to be a logical part of their owning entity; never of the
            contained entities. This is a crucial distinction! It has the following consequences:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                When we remove / add an object from / to a collection, the version number of the collection owner
                is incremented.
            </p></li><li><p>
                If an object that was removed from a collection is an instance of a value type (eg, a composite
                element), that object will cease to be persistent and its state will be completely removed from
                the database. Likewise, adding a value type instance to the collection will cause its state to be
                immediately persistent.
            </p></li><li><p>
                On the other hand, if an entity is removed from a collection (a one-to-many or many-to-many
                association), it will not be deleted, by default. This behaviour is completely consistent - a
                change to the internal state of another entity should not cause the associated entity to vanish!
                Likewise, adding an entity to a collection does not cause that entity to become persistent, by
                default.
            </p></li></ul></div><p>
            Instead, the default behaviour is that adding an entity to a collection merely creates a link between
            the two entities, while removing it removes the link. This is very appropriate for all sorts of cases.
            Where it is not appropriate at all is the case of a parent / child relationship, where the life of the
            child is bound to the lifecycle of the parent.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-bidir"></a>16.2.&nbsp;Bidirectional one-to-many</h2></div></div><div></div></div><p>
            Suppose we start with a simple <tt class="literal">&lt;one-to-many&gt;</tt> association from
            <tt class="literal">Parent</tt> to <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            If we were to execute the following code
        </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            Hibernate would issue two SQL statements:
        </p><div class="itemizedlist"><ul type="disc"><li><p>an <tt class="literal">INSERT</tt> to create the record for <tt class="literal">c</tt></p></li><li><p>
                an <tt class="literal">UPDATE</tt> to create the link from <tt class="literal">p</tt> to
                <tt class="literal">c</tt>
            </p></li></ul></div><p>
            This is not only inefficient, but also violates any <tt class="literal">NOT NULL</tt> constraint on the
            <tt class="literal">parent_id</tt> column.
        </p><p>
            The underlying cause is that the link (the foreign key <tt class="literal">parent_id</tt>) from
            <tt class="literal">p</tt> to <tt class="literal">c</tt> is not considered part of the state of the <tt class="literal">Child</tt>
            object and is therefore not created in the <tt class="literal">INSERT</tt>. So the solution is to make the link part
            of the <tt class="literal">Child</tt> mapping.
        </p><pre class="programlisting">&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</pre><p>
            (We also need to add the <tt class="literal">parent</tt> property to the <tt class="literal">Child</tt> class.)
        </p><p>
            Now that the <tt class="literal">Child</tt> entity is managing the state of the link, we tell the collection not
            to update the link. We use the <tt class="literal">inverse</tt> attribute.
        </p><pre class="programlisting">&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            The following code would be used to add a new <tt class="literal">Child</tt>
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>
            And now, only one SQL <tt class="literal">INSERT</tt> would be issued!
        </p><p>
            To tighten things up a bit, we could create an <tt class="literal">addChild()</tt> method of
            <tt class="literal">Parent</tt>.
        </p><pre class="programlisting">public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</pre><p>
            Now, the code to add a <tt class="literal">Child</tt> looks like
        </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-cascades"></a>16.3.&nbsp;Cascading lifecycle</h2></div></div><div></div></div><p>
             The explicit call to <tt class="literal">save()</tt> is still annoying. We will address this by
             using cascades.
         </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             This simplifies the code above to
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</pre><p>
             Similarly, we don't need to iterate over the children when saving or deleting a <tt class="literal">Parent</tt>.
             The following removes <tt class="literal">p</tt> and all its children from the database.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</pre><p>
             However, this code
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</pre><p>
             will not remove <tt class="literal">c</tt> from the database; it will ony remove the link to <tt class="literal">p</tt>
             (and cause a <tt class="literal">NOT NULL</tt> constraint violation, in this case). You need to explicitly
             <tt class="literal">delete()</tt> the <tt class="literal">Child</tt>.
         </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</pre><p>
             Now, in our case, a <tt class="literal">Child</tt> can't really exist without its parent. So if we remove
             a <tt class="literal">Child</tt> from the collection, we really do want it to be deleted. For this, we must
             use <tt class="literal">cascade="all-delete-orphan"</tt>.
         </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             Note: even though the collection mapping specifies <tt class="literal">inverse="true"</tt>, cascades are still
             processed by iterating the collection elements. So if you require that an object be saved, deleted or
             updated by cascade, you must add it to the collection. It is not enough to simply call
             <tt class="literal">setParent()</tt>.
         </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-update"></a>16.4.&nbsp;Using cascading <tt class="literal">update()</tt></h2></div></div><div></div></div><p>
             Suppose we loaded up a <tt class="literal">Parent</tt> in one <tt class="literal">Session</tt>, made some changes in a UI
             action and wish to persist these changes in a new Session (by calling <tt class="literal">update()</tt>). The
             <tt class="literal">Parent</tt> will contain a collection of childen and, since cascading update is enabled, Hibernate
             needs to know which children are newly instantiated and which represent existing rows in the database. Lets assume
             that both <tt class="literal">Parent</tt> and <tt class="literal">Child</tt> have (synthetic) identifier properties of type
             <tt class="literal">java.lang.Long</tt>. Hibernate will use the identifier property value to determine which of the
             children are new. (You may also use the version or timestamp property, see
             <a href="#manipulatingdata-updating-detached" title="9.4.2.&nbsp;Updating detached objects">Section&nbsp;9.4.2, &#8220;Updating detached objects&#8221;</a>.)
         </p><p>
             The <tt class="literal">unsaved-value</tt> attribute is used to specify the identifier value of a newly instantiated
             instance. <tt class="literal">unsaved-value</tt> defaults to "null", which is perfect for a <tt class="literal">Long</tt>
             identifier type. If we would have used a primitive identitifier property, we would need to specify
         </p><pre class="programlisting">&lt;id name="id" type="long" unsaved-value="0"&gt;</pre><p>
             for the <tt class="literal">Child</tt> mapping. (There is also an <tt class="literal">unsaved-value</tt> attribute
             for version and timestamp property mappings.)
         </p><p>
             The following code will update <tt class="literal">parent</tt> and <tt class="literal">child</tt> and insert
             <tt class="literal">newChild</tt>.
         </p><pre class="programlisting">//parent and child were both loaded in a previous session
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre><p>
             Well, thats all very well for the case of a generated identifier, but what about assigned identifiers
             and composite identifiers? This is more difficult, since <tt class="literal">unsaved-value</tt> can't
             distinguish between a newly instantiated object (with an identifier assigned by the user) and an object
             loaded in a previous session. In these cases, you will probably need to give Hibernate a hint; either
         </p><div class="itemizedlist"><ul type="disc"><li><p>
                 define <tt class="literal">unsaved-value="null"</tt> or <tt class="literal">unsaved-value="negative"</tt>
                 on a <tt class="literal">&lt;version&gt;</tt> or <tt class="literal">&lt;timestamp&gt;</tt> property
                 mapping for the class.
             </p></li><li><p>
                 set <tt class="literal">unsaved-value="none"</tt> and explicitly <tt class="literal">save()</tt>
                 newly instantiated children before calling <tt class="literal">update(parent)</tt>
             </p></li><li><p>
                 set <tt class="literal">unsaved-value="any"</tt> and explicitly <tt class="literal">update()</tt>
                 previously persistent children before calling <tt class="literal">update(parent)</tt>
             </p></li></ul></div><p>
             <tt class="literal">none</tt> is the default <tt class="literal">unsaved-value</tt> for assigned and composite
             identifiers.
         </p><p>
             There is one further possibility. There is a new <tt class="literal">Interceptor</tt> method named
             <tt class="literal">isUnsaved()</tt> which lets the application implement its own strategy for distinguishing
             newly instantiated objects. For example, you could define a base class for your persistent classes.
         </p><pre class="programlisting">public class Persistent {
    private boolean _saved = false;
    public void onSave() {
        _saved=true;
    }
    public void onLoad() {
        _saved=true;
    }
    ......
    public boolean isSaved() {
        return _saved;
    }
}</pre><p>
             (The <tt class="literal">saved</tt> property is non-persistent.)
             Now implement <tt class="literal">isUnsaved()</tt>, along with <tt class="literal">onLoad()</tt>
             and <tt class="literal">onSave()</tt> as follows.
         </p><pre class="programlisting">public Boolean isUnsaved(Object entity) {
    if (entity instanceof Persistent) {
        return new Boolean( !( (Persistent) entity ).isSaved() );
    }
    else {
        return null;
    }
}

public boolean onLoad(Object entity, 
    Serializable id,
    Object[] state,
    String[] propertyNames,
    Type[] types) {

    if (entity instanceof Persistent) ( (Persistent) entity ).onLoad();
    return false;
}

public boolean onSave(Object entity,
    Serializable id,
    Object[] state,
    String[] propertyNames,
    Type[] types) {
        
    if (entity instanceof Persistent) ( (Persistent) entity ).onSave();
    return false;
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-conclusion"></a>16.5.&nbsp;Conclusion</h2></div></div><div></div></div><p>
             There is quite a bit to digest here and it might look confusing first time around. However, in practice, it
             all works out quite nicely. Most Hibernate applications use the parent / child pattern in many places.
         </p><p>
             We mentioned an alternative in the first paragraph. None of the above issues exist in the case of
             <tt class="literal">&lt;composite-element&gt;</tt> mappings, which have exactly the semantics of a parent / child
             relationship. Unfortunately, there are two big limitations to composite element classes: composite elements may
             not own collections, and they should not be the child of any entity other than the unique parent. (However,
             they <span class="emphasis"><em>may</em></span> have a surrogate primary key, using an <tt class="literal">&lt;idbag&gt;</tt> mapping.)
         </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-weblog"></a>Chapter&nbsp;17.&nbsp;Example: Weblog Application</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-classes"></a>17.1.&nbsp;Persistent Classes</h2></div></div><div></div></div><p>
            The persistent classes represent a weblog, and an item posted
            in a weblog. They are to be modelled as a standard parent/child
            relationship, but we will use an ordered bag, instead of a set.
        </p><pre class="programlisting">package eg;

import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {
        _name = string;
    }
}</pre><pre class="programlisting">package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-mappings"></a>17.2.&nbsp;Hibernate Mappings</h2></div></div><div></div></div><p>
            The XML mappings should now be quite straightforward.
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class 
        name="Blog" 
        table="BLOGS" 
        lazy="true"&gt;
        
        &lt;id 
            name="id" 
            column="BLOG_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="name" 
            column="NAME" 
            not-null="true" 
            unique="true"/&gt;
            
        &lt;bag 
            name="items" 
            inverse="true" 
            lazy="true"
            order-by="DATE_TIME" 
            cascade="all"&gt;
            
            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;
            
        &lt;/bag&gt;
        
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;
    
    &lt;class 
        name="BlogItem" 
        table="BLOG_ITEMS" 
        dynamic-update="true"&gt;
        
        &lt;id 
            name="id" 
            column="BLOG_ITEM_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="title" 
            column="TITLE" 
            not-null="true"/&gt;
            
        &lt;property 
            name="text" 
            column="TEXT" 
            not-null="true"/&gt;
            
        &lt;property 
            name="datetime" 
            column="DATE_TIME" 
            not-null="true"/&gt;
            
        &lt;many-to-one 
            name="blog" 
            column="BLOG_ID" 
            not-null="true"/&gt;
            
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-code"></a>17.3.&nbsp;Hibernate Code</h2></div></div><div></div></div><p>
            The following class demonstrates some of the kinds of things
            we can do with these classes, using Hibernate.
        </p><pre class="programlisting">package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import net.sf.hibernate.HibernateException;
import net.sf.hibernate.Query;
import net.sf.hibernate.Session;
import net.sf.hibernate.SessionFactory;
import net.sf.hibernate.Transaction;
import net.sf.hibernate.cfg.Configuration;
import net.sf.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {
    
    private SessionFactory _sessions;
    
    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }
    
    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }
    
    public Blog createBlog(String name) throws HibernateException {
        
        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.save(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {
        
        item.setText(text);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {
    
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
    
    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.list().get(0);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public List listBlogsAndRecentItems() throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime &gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);
            
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-mappings"></a>Chapter&nbsp;18.&nbsp;Example: Various Mappings</h2></div></div><div></div></div><p>
        This chapters shows off some more complex association mappings.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-emp"></a>18.1.&nbsp;Employer/Employee</h2></div></div><div></div></div><p>
            The following model of the relationship between <tt class="literal">Employer</tt> and 
            <tt class="literal">Employee</tt> uses an actual entity class (<tt class="literal">Employment</tt>) 
            to represent the association. This is done because there might be more than one
            period of employment for the same two parties. Components are used to model monetory 
            values and employee names.
        </p><div class="mediaobject" align="center"><img src="../shared/images/EmployerEmployee.gif" align="middle"></div><p>
            Heres a possible mapping document:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
        
    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetoryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        And heres the table schema generated by <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table employers (
    id BIGINT not null, 
    name VARCHAR(255), 
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (id)
)

create table employees (
    id BIGINT not null, 
    firstName VARCHAR(255), 
    initial CHAR(1), 
    lastName VARCHAR(255), 
    taxfileNumber VARCHAR(255), 
    primary key (id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-authorwork"></a>18.2.&nbsp;Author/Work</h2></div></div><div></div></div><p>
            Consider the following model of the relationships between <tt class="literal">Work</tt>,
            <tt class="literal">Author</tt> and <tt class="literal">Person</tt>. We represent the relationship
            between <tt class="literal">Work</tt> and <tt class="literal">Author</tt> as a many-to-many
            association. We choose to represent the relationship between <tt class="literal">Author</tt> 
            and <tt class="literal">Person</tt> as one-to-one association. Another possibility would be to 
            have <tt class="literal">Author</tt> extend <tt class="literal">Person</tt>.  
        </p><div class="mediaobject" align="center"><img src="../shared/images/AuthorWork.gif" align="middle"></div><p>
            The following mapping document correctly represents these relationships:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work" lazy="true"&gt;
            &lt;key&gt;
                &lt;column name="work_id" not-null="true"/&gt;
            &lt;/key&gt;
            &lt;many-to-many class="Author"&gt;
                &lt;column name="author_id" not-null="true"/&gt;
            &lt;/many-to-many&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true" lazy="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        There are four tables in this mapping. <tt class="literal">works</tt>, 
        <tt class="literal">authors</tt> and <tt class="literal">persons</tt> hold work, author
        and person data respectively. <tt class="literal">author_work</tt> is an association
        table linking authors to works. Heres the table schema, as generated by
        <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-customerorderproduct"></a>18.3.&nbsp;Customer/Order/Product</h2></div></div><div></div></div><p>
            Now consider a model of the relationships between <tt class="literal">Customer</tt>,
            <tt class="literal">Order</tt> and <tt class="literal">LineItem</tt> and <tt class="literal">Product</tt>.
            There is a one-to-many association between <tt class="literal">Customer</tt> and
            <tt class="literal">Order</tt>, but how should we represent <tt class="literal">Order</tt> / 
            <tt class="literal">LineItem</tt> / <tt class="literal">Product</tt>? I've chosen to map
            <tt class="literal">LineItem</tt> as an association class representing the many-to-many
            association between <tt class="literal">Order</tt> and <tt class="literal">Product</tt>. In
            Hibernate, this is called a composite element.
        </p><div class="mediaobject" align="center"><img src="../shared/images/CustomerOrderProduct.gif" align="middle"></div><p>
            The mapping document:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true" lazy="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items" lazy="true"&gt;
            &lt;key column="order_id"/&gt;
            &lt;index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        <tt class="literal">customers</tt>, <tt class="literal">orders</tt>, <tt class="literal">line_items</tt> and 
        <tt class="literal">products</tt> hold customer, order, order line item and product data
        respectively. <tt class="literal">line_items</tt> also acts as an association table linking
        orders with products.
    </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serialNumber VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="best-practices"></a>Chapter&nbsp;19.&nbsp;Best Practices</h2></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term">Write fine-grained classes and map them using <tt class="literal">&lt;component&gt;</tt>.</span></dt><dd><p>
                    Use an <tt class="literal">Address</tt> class to encapsulate <tt class="literal">street</tt>,
                    <tt class="literal">suburb</tt>, <tt class="literal">state</tt>, <tt class="literal">postcode</tt>.
                    This encourages code reuse and simplifies refactoring.
                </p></dd><dt><span class="term">Declare identifier properties on persistent classes.</span></dt><dd><p>
                    Hibernate makes identifier properties optional. There are all sorts of reasons why
                    you should use them. We recommend that identifiers be 'synthetic' (generated, with
                    no business meaning) and of a non-primitive type. For maximum flexibility, use
                    <tt class="literal">java.lang.Long</tt> or <tt class="literal">java.lang.String</tt>.
                </p></dd><dt><span class="term">Place each class mapping in its own file.</span></dt><dd><p>
                     Don't use a single monolithic mapping document. Map <tt class="literal">com.eg.Foo</tt> in 
                     the file <tt class="literal">com/eg/Foo.hbm.xml</tt>. This makes particularly good sense in 
                     a team environment.
                </p></dd><dt><span class="term">Load mappings as resources.</span></dt><dd><p>
                    Deploy the mappings along with the classes they map.
                </p></dd><dt><span class="term">Consider externalising query strings.</span></dt><dd><p>
                    This is a good practice if your queries call non-ANSI-standard SQL functions. 
                    Externalising the query strings to mapping files will make the application more portable.
                </p></dd><dt><span class="term">Use bind variables.</span></dt><dd><p>
                     As in JDBC, always replace non-constant values by "?". Never use string manipulation to 
                     bind a non-constant value in a query! Even better, consider using named parameters in
                     queries.
                </p></dd><dt><span class="term">Don't manage your own JDBC connections.</span></dt><dd><p>
                    Hibernate lets the application manage JDBC connections. This approach should be considered 
                    a last-resort. If you can't use the built-in connections providers, consider providing your 
                    own implementation of <tt class="literal">net.sf.hibernate.connection.ConnectionProvider</tt>.
                </p></dd><dt><span class="term">Consider using a custom type.</span></dt><dd><p>
                    Suppose you have a Java type, say from some library, that needs to be persisted but doesn't 
                    provide the accessors needed to map it as a component. You should consider implementing
                    <tt class="literal">net.sf.hibernate.UserType</tt>. This approach frees the application
                    code from implementing transformations to / from a Hibernate type.
                </p></dd><dt><span class="term">Use hand-coded JDBC in bottlenecks.</span></dt><dd><p>
                    In performance-critical areas of the system, some kinds of operations (eg. mass update /
                    delete) might benefit from direct JDBC. But please, wait until you <span class="emphasis"><em>know</em></span> 
                    something is a bottleneck. And don't assume that direct JDBC is necessarily faster. If need to 
                    use direct JDBC, it might be worth opening a Hibernate <tt class="literal">Session</tt> and using that SQL 
                    connection. That way you can still use the same transaction strategy and underlying connection 
                    provider.
                </p></dd><dt><span class="term">Understand <tt class="literal">Session</tt> flushing.</span></dt><dd><p>
                    From time to time the Session synchronizes its persistent state with the database. Performance will
                    be affected if this process occurs too often. You may sometimes minimize unnecessary flushing by 
                    disabling automatic flushing or even by changing the order of queries and other operations within a 
                    particular transaction.      
                </p></dd><dt><span class="term">In a three tiered architecture, consider using <tt class="literal">saveOrUpdate()</tt>.</span></dt><dd><p>
                    When using a servlet / session bean architecture, you could pass persistent objects loaded in
                    the session bean to and from the servlet / JSP layer. Use a new session to service each request. 
                    Use <tt class="literal">Session.update()</tt> or <tt class="literal">Session.saveOrUpdate()</tt> to update the 
                    persistent state of an object.
                </p></dd><dt><span class="term">In a two tiered architecture, consider using session disconnection.</span></dt><dd><p>
                    Database Transactions have to be as short as possible for best scalability. However, it is often
                    neccessary to implement long running Application Transactions, a single unit-of-work from the
                    point of view of a user. This Application Transaction might span several client requests and
                    response cycles. Either use Detached Objects or, in two tiered architectures, simply disconnect
                    the Hibernate Session from the JDBC connection and reconnect it for each subsequent request. Never
                    use a single Session for more than one Application Transaction usecase, otherwise, you will run
                    into stale data.
                </p></dd><dt><span class="term">Don't treat exceptions as recoverable.</span></dt><dd><p>
                    This is more of a necessary practice than a "best" practice. When an exception occurs, roll back
                    the <tt class="literal">Transaction</tt> and close the <tt class="literal">Session</tt>. If you don't, Hibernate
                    can't guarantee that in-memory state accurately represents persistent state. As a special case of this,
                    do not use <tt class="literal">Session.load()</tt> to determine if an instance with the given identifier 
                    exists on the database; use <tt class="literal">find()</tt> instead. Some exceptions are recoverable, for
                    example the <tt class="literal">StaleObjectStateException</tt> and <tt class="literal">ObjectNotFoundException</tt>.
                </p></dd><dt><span class="term">Prefer lazy fetching for associations.</span></dt><dd><p>
                    Use eager (outer-join) fetching sparingly. Use proxies and/or lazy collections for most associations
                    to classes that are not cached at the JVM-level. For associations to cached classes, where there is
                    a high probability of a cache hit, explicitly disable eager fetching using 
                    <tt class="literal">outer-join="false"</tt>. When an outer-join fetch is appropriate to a particular use
                    case, use a query with a <tt class="literal">left join</tt>.
                </p></dd><dt><span class="term">Consider abstracting your business logic from Hibernate.</span></dt><dd><p>
                    Hide (Hibernate) data-access code behind an interface. Combine the <span class="emphasis"><em>DAO</em></span> and 
                    <span class="emphasis"><em>Thread Local Session</em></span> patterns. You can even have some classes persisted by
                    handcoded JDBC, associated to Hibernate via a <tt class="literal">UserType</tt>. (This advice is 
                    intended for "sufficiently large" applications; it is not appropriate for an application with
                    five tables!)
                </p></dd><dt><span class="term">Implement <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt> using a unique business key.</span></dt><dd><p>
                    If you compare objects outside of the Session scope, you have to implement <tt class="literal">equals()</tt>
                    and <tt class="literal">hashCode()</tt>. Inside the Session scope, Java object identity is guaranteed. If
                    you implement these methods, never ever use the database identifier! A transient object doesn't have
                    an identifier value and Hibernate would assign a value when the object is saved. If the object
                    is in a Set while being saved, the hash code changes, breaking the contract. To implement
                    <tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt>, use a unique business key, that is,
                    compare a unique combination of class properties. Remember that this key has to be stable and unique
                    only while the object is in a Set, not for the whole lifetime (not as stable as a database primary
                    key). Never use collections in the <tt class="literal">equals()</tt> comparison (lazy loading) and be careful
                    with other associated classes that might be proxied.
                </p></dd><dt><span class="term">Don't use exotic association mappings.</span></dt><dd><p>
                    Good usecases for a real many-to-many associations are rare. Most of the time you need
                    additional information stored in the "link table". In this case, it is much better to
                    use two one-to-many associations to an intermediate link class. In fact, we think that
                    most associations are one-to-many and many-to-one, you should be careful when using any
                    other association style and ask yourself if it is really neccessary.
                </p></dd></dl></div></div></div></body></html>